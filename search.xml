<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>css3动画常用属性和阴影圆角</title>
    <url>/2020/08/30/css/css3%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/bled-1899264_1280.jpg" alt=""></p>
<hr>
<h2 id="CSS3的含义">CSS3的含义</h2>
<p>​	<code>CSS3</code>是<code>CSS</code>（层叠样式表）技术的升级版本。<code>CSS3</code>完全向后兼容，不必改变现有的设计，浏览器将永远支持<code>CSS2</code>。<code>W3C</code>的<code>CSS3</code>规范仍在开发。但是，许多新的<code>CSS3</code>属性已在现代浏览器使用。</p>
<h2 id="浏览器内核以及其前缀">浏览器内核以及其前缀</h2>
<p>​	<code>CSS</code>标准中各个属性都要经历从草案到推荐的过程，<code>css3</code>中的属性进展都不一样，浏览器厂商在标准尚未明确情况下提前支持会有风险，浏览器厂商对新属性的支持情况也不同，所以会加厂商前缀加以区分。如果某个属性已经从草案变为了或接近推荐方案，并且厂商已经完全实现了推荐属性，那就不用加厂商前缀。如<code>border-radius</code>已经很成熟，不用加前缀。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306103253008.png" alt="image-20210306103253008"></p>
<p>​	<code>根据不同的浏览器内核，css前缀会有不同</code>。最基本的浏览器内核有如下四种，其它的内核都是基于此四种进行再研发的。</p>
<ol>
<li>
<p><code>Gecko内核</code>      前缀为<code>-moz-</code>   火狐浏览器</p>
</li>
<li>
<p><code>Webkit内核</code>    前缀为<code>-webkit-</code>   也叫谷歌内核，chrome浏览器最先开发使用，safari浏览器也使用 该内核。国内很多浏览器也使用了<code>webkit内核</code>，如360极速、世界之窗、猎豹等。</p>
</li>
<li>
<p><code>Trident内核</code>    前缀为<code>-ms-</code>  也称IE内核</p>
</li>
<li>
<p><code>Presto内核</code>      前缀<code>-o-</code>   目前只有opera采用</p>
</li>
</ol>
<h3 id="圆角border-radius">圆角border-radius</h3>
<p>语法</p>
<pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>：value；四个角
<span class="hljs-attribute">border-radius</span>：value value；左上右下、右上左下
<span class="hljs-attribute">border-radius</span>：value value value value；		
        代表设置对象左上角、右上角、右下角、左下角</code></pre>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306103337192.png" alt="image-20210306103337192" style="zoom:50%;">
<h3 id="盒阴影box-shadow">盒阴影box-shadow</h3>
<pre><code class="hljs css">语法：<span class="hljs-attribute">box-shadow</span>: h-shadow v-shadow blur spread color inset;</code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306103327261.png" alt="image-20210306103327261"></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
    .shadow{
<span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span>
<span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span>
<span class="css">            <span class="hljs-attribute">background-color</span>: red;</span>
<span class="css">            <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">5px</span> <span class="hljs-number">3px</span> darkred;</span>
        }
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"shadow"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306103724901.png" alt="image-20210306103724901"></p>
<h3 id="文字阴影text-shadow">文字阴影text-shadow</h3>
<pre><code class="hljs css">语法：<span class="hljs-attribute">text-shadow</span>: h-shadow v-shadow blur color;</code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306103735569.png" alt="image-20210306103735569"></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
    .text1{
<span class="css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span>
<span class="css">            <span class="hljs-attribute">font-weight</span>: bold;</span>
<span class="css">            <span class="hljs-attribute">color</span>: palegreen;</span>
<span class="css">            <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">10px</span> -<span class="hljs-number">5px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#ccc</span> ;</span>
       }
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text1"</span>&gt;</span>学习猿地<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306103747132.png" alt="image-20210306103747132"></p>
<h2 id="CSS3-渐变">CSS3 渐变</h2>
<p><a class="link" href="https://www.runoob.com/css3/css3-gradients.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a></p>
<p>​	<code>CSS3 渐变（gradients）</code>可以让你在两个或多个指定的颜色之间显示平稳的过渡。以前，你必须使用图像来实现这些效果。现在，使用 <code>CSS3 渐变（gradients）</code>，通过代码来实现渐变可以减少请求和节约带宽。</p>
<p><code>CSS3</code> 定义了两种类型的渐变（gradients）:</p>
<ul>
<li>线性渐变（Linear Gradients）: 向下/向上/向左/向右/对角方向<br>
<code>background: linear-gradient(direction, color-stop1, color-stop2, ...);</code></li>
<li>径向渐变（Radial Gradients）: 由它们的中心定义<br>
<code>background: radial-gradient(center, shape， size, start-color, ..., last-color);</code><br>
默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），它可以是值 <code>circle</code> 或 <code>ellipse</code>。其中，circle 表示圆形，ellipse 表示椭圆形</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306103803293.png" alt="image-20210306103803293"></p>
<h2 id="CSS3-转换Transform（2D转换）">CSS3 转换Transform（2D转换）</h2>
<p><a class="link" href="https://www.cnblogs.com/aspnetjia/p/5139020.html">transform详解<i class="fas fa-external-link-alt"></i></a></p>
<p>​	<code>CSS3</code>中的转换允许我们对元素进行旋转、缩放、移动或倾斜。它为分<code>2D转换 或 3D 转换。</code>在css2时代，如果要做一些图片转换角度，都依赖于<code>图片、Flash或JavaScript才能完成</code>。但是现在借助<code>CSS3</code>就可以轻松倾斜、缩放、移动以及翻转元素。通过<code>CSS</code>变形，可以让元素生成静态视觉效果，但也可以很容易结合<code>CSS3的transition和动画的keyframe</code>产生一些动画效果。</p>
<h3 id="转换Transform-2D的属性">转换Transform 2D的属性</h3>
<p>​	通常的属性包含了属性名和属性值，而CSS3的transform属性是用函数来定义的。Transform 2D函数包括了<code>translate()、scale()、rotate()和skew()。</code></p>
<p>书写格式:<br>
<code>transform:函数名(x轴值，y轴值);</code></p>
<p>转换的效果：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306104641628.png" alt="image-20210306104641628"></p>
<ol>
<li>
<p><code>translate()</code><br>
translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。接受CSS的标准度量单位（px），translate(x,y)：转换，沿着X和Y轴移动元素。</p>
</li>
<li>
<p><code>rotate()</code><br>
通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。它以deg为单位，代表了旋转的角度。</p>
</li>
<li>
<p><code>scale()</code><br>
通过值把宽和高转换为原始尺寸的n倍，接受两个参数，前面的为宽，后面的为高。可取值：默认值为1，缩小：0-1 之间的数，放大：大于1的数</p>
</li>
<li>
<p><code>skew()</code><br>
根据水平轴和垂直轴翻转，接受两个或一个值，两个值时前面为水平，后面为垂直的角度 ，一个值只是水平轴的角度。此函数是指元素的倾斜角度。</p>
</li>
</ol>
<h3 id="转换Transform-3D的属性">转换Transform 3D的属性</h3>
<p>Transform 3D常用函数有：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306104709948.png" alt="image-20210306104709948"></p>
<h2 id="CSS3-过渡Transition">CSS3 过渡Transition</h2>
<p><a class="link" href="https://www.cnblogs.com/afighter/p/5731293.html">transition演示<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="什么是过渡">什么是过渡</h3>
<p>使用<code>css</code>的属性值在一段时间内平滑的过渡，比如，鼠标悬停后，背景色在<code>1s</code>内，由白色平滑的过渡到红色<br>
指定四个要素：</p>
<ul>
<li>
<p>过渡属性，如background、color等</p>
</li>
<li>
<p>过渡所需时间</p>
</li>
<li>
<p>过渡函数，即过渡的速度、方式等</p>
</li>
<li>
<p>过渡延迟时间，表示开始执行的时间</p>
</li>
</ul>
<p>触发过渡：通过用户的行为触发，如点击、悬浮等</p>
<h3 id="过渡属性">过渡属性</h3>
<p><code>transition-property: none|all|property;</code><br>
多个属性用逗号隔开，可设置过渡的属性，颜色属性。取值为数值的属性：转换属性，渐变属性，阴影属性</p>
<h3 id="过渡时间">过渡时间</h3>
<p><code>transition-duration: s|ms;</code><br>
默认值为0，意味着不会有效果，所以必须设置transition-duration属性</p>
<h3 id="过渡函数">过渡函数</h3>
<p><code>transition-timing-function: ;</code><br>
取值：<br>
ease：默认值，规定慢速开始，然后变快，然后慢速结束的过渡效果<br>
linear：匀速<br>
ease-in：规定以慢速开始，加速效果<br>
ease-out：规定以慢速结束，减速效果<br>
ease-in-out：规定以慢速开始和结束，先加速后减速效果</p>
<h3 id="过渡延迟">过渡延迟</h3>
<p><code>transition-delay: s|ms;</code><br>
改变元素属性值后多长时间开始执行过渡效果</p>
<h3 id="简写属性transition">简写属性transition</h3>
<p>transition属性是一个简写属性，用于设置四个过渡属性<br>
<code>语法：transition:property duration timing-function delay;</code></p>
<pre><code class="hljs css"><span class="hljs-selector-id">#box</span>{
     <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
     <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#1fb57b</span>;
     <span class="hljs-attribute">transition</span>: background <span class="hljs-number">4s</span> linear <span class="hljs-number">1s</span>;
 }
 <span class="hljs-selector-id">#box</span><span class="hljs-selector-pseudo">:hover</span>{
     <span class="hljs-attribute">background-color</span>: red;
}</code></pre>
<h2 id="CSS3-animation动画">CSS3 animation动画</h2>
<p><a class="link" href="https://www.runoob.com/css3/css3-animations.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a></p>
<p>过渡属性只能模拟动画效果，animation属性可以制作类似Flash动画，通过关键帧控制动画的每一步，使元素从一种样式逐渐变化为另一种样式，实现复杂的动画效果。</p>
<h3 id="keyframes">@keyframes</h3>
<p>作用：用于声明动画，指定关键帧<br>
帧：用于分解动画动作，每个帧代表某个时间点。定义每个帧上的动作</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306105920430.png" alt="image-20210306105920430"></p>
<h3 id="keyframes的语法">@keyframes的语法</h3>
<pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> name  {
    from|0%{
        css样式
    }
    percent{
        css样式
    }
    to|100%{
        css样式
    }
 }</code></pre>
<h3 id="animation属性">animation属性</h3>
<p><code>animation</code>属性用于控制动画，调用由<code>@keyframes</code>定义的动画，设置动画属性，如时间、次数等。animation属性是一个简写属性。<br>
语法为：<code>animation:name  duration timing-function delay iteration-count direction;</code></p>
<h3 id="动画子属性">动画子属性</h3>
<pre><code class="hljs css"><span class="hljs-attribute">animation-name</span>: ;	调用动画，规定需要和keyframes的名字一致

<span class="hljs-attribute">animation-duration</span>: s|ms;	动画完成一个周期所需要的时间

<span class="hljs-attribute">animation-timing-function</span>: ;	规定动画的速度变化类型

<span class="hljs-attribute">animation-delay</span>:s|ms ;	播放之前的延迟时间

<span class="hljs-attribute">animation-iteration-count</span>: 数值|infinite;	播放次数 infinite表示无限次播放

<span class="hljs-attribute">animation-direction</span>: normal|alternate;	动画播放方向,<span class="hljs-attribute">normal</span>为默认值，表示正常播放,alternate表示轮流播放，即动画会在奇数次正常播放，而在偶数次向后播放

<span class="hljs-attribute">animation-fill-mode</span>: forwards;	动画停在最后一帧，默认值为<span class="hljs-attribute">none</span>

<span class="hljs-attribute">animation-play-state</span>:paused|running; 属性规定动画正在运行还是暂停，默认值为running</code></pre>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>media媒体查询</title>
    <url>/2020/09/04/css/css%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/mountains-615428_1280.jpg" alt=""></p>
<hr>
<h2 id="Media-Query响应式布局—媒体查询">Media Query响应式布局—媒体查询</h2>
<p>​	响应式布局是在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。<br>
​	响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，越来越多的网站采用这个技术。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306113916951.png" alt="image-20210306113916951"></p>
<h3 id="响应式设计一定是最佳选择吗？">响应式设计一定是最佳选择吗？</h3>
<p>​	如果预算充足且形势需要，做一个真正的“手机版”网站是首选。因为响应式设计没有专门设计一个手机版网站的功能多，比如获取当前用户的<code>GPS定位</code>，只是用响应式设计会很难实现。但如果只是根据视口大小为用户提供匹配的视觉效果还是优先选择响应式设计。</p>
<p>优点：</p>
<ol>
<li>面对不同分辨率设备灵活性强</li>
<li>能够快捷解决多设备显示适应问题</li>
</ol>
<p>缺点：</p>
<ol>
<li>兼容各种设备工作量大，效率略慢</li>
<li>代码累赘，会出现隐藏无用的元素，加载时间加长</li>
<li>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li>
<li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li>
</ol>
<h3 id="CSS中的Media-Query（媒介查询）是什么？">CSS中的Media Query（媒介查询）是什么？</h3>
<p>​	作为<code>CSS3</code>规范的一部分，媒体查询可以针对不同的屏幕尺寸设置不同的样式，它为每种类型的用户提供了最佳的体验，网站在任何尺寸设置下都能有最佳的显示效果。通过不同的媒体类型和条件定义样式表规则。<br>
​	<br>
​	媒体查询让<code>CSS</code>可以更精确作用于不同的媒体类型和同一媒体的不同条件。媒体查询的大部分媒体特性都接受min和max用于表达“大于或等于”和“小与或等于”。如：<code>width会有min-width和max-width</code><br>
​	<br>
​	<code>Media Queries</code>功能是非常强大的，他可以让你定制不同的分辨率和设备，并在不改变内容的情况下，让你制作的web页面在不同的分辨率和设备下都能显示正常，并且不会因此而丢失样式</p>
<h4 id="媒体查询实例">媒体查询实例</h4>
<p>​	通过此实例观察媒体查询的功能后，再来分析语法</p>
<pre><code class="hljs css">
 	
<span class="hljs-selector-tag">body</span>{<span class="hljs-attribute">background-color</span>:grey; }   //正常情况是灰色
<span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">992px</span>) {//宽度大于 <span class="hljs-number">992px</span> 的时候被应用 pc端
 	 	<span class="hljs-selector-class">.class</span> {<span class="hljs-attribute">background</span>: <span class="hljs-number">#666</span>;}  }  
   			  			      
<span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) { //宽度小于<span class="hljs-number">768px</span>的时候被应用  移动端
  		<span class="hljs-selector-class">.class</span> { <span class="hljs-attribute">background</span>: <span class="hljs-number">#ccc</span>; }  }
             
<span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">768</span>x) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">992px</span>) {  //宽度在 <span class="hljs-number">768px</span> 和 <span class="hljs-number">992px</span> 之间的时候被应用
  		<span class="hljs-selector-class">.class</span> {  <span class="hljs-attribute">background</span>: <span class="hljs-number">#333</span>;  }   }</code></pre>
<h4 id="使用Media-Query的基本语法">使用Media Query的基本语法</h4>
<pre><code class="hljs css"><span class="hljs-keyword">@media</span> mediatype <span class="hljs-keyword">and</span>|<span class="hljs-keyword">not</span>|<span class="hljs-keyword">only</span> (media feature) {
       CSS-<span class="hljs-selector-tag">Code</span>;
 }</code></pre>
<p>​	以上通过<code>@media</code>定义媒体查询，<code>mediatype</code>代表了设备类型，目前只有<code>screen</code>最常用，<code>and|not|only</code>为条件，<code>media feature</code>为媒体特点，通常是写设备的宽度。</p>
<p>​	<code>@media screen and (max-width:960px)</code> 的意思为：当前设备为screen（电脑、平板、手机）时，并且最大宽度为960时，显示的样式。</p>
<p>媒体类型有：</p>
<ul>
<li>all   所有设备</li>
<li>print	用于打印机和打印预览</li>
<li>screen	用于电脑屏幕，平板电脑，智能手机等</li>
<li>speech	应用于屏幕阅读器等发声设备</li>
</ul>
<h3 id="用媒体查询改造我们的设计">用媒体查询改造我们的设计</h3>
<p>​	我们都知道，样式表里面，后面的样式会覆盖前面的样式。因此，我们可以在设置好网站基本样式后，使用媒体查询来进一步重写相应的部分。例如，在PC端将导航显示成简单的链接，然后再针对小视口，使用媒体查询重写这一部分。理论上讲最好是从小屏幕设备开始设计，然后渐进增强。但实际上我们使用媒体查询要解决的问题，都是已经存在PC端站点了，<code>更多的是要将现有的桌面版网页改造成响应式的</code>。</p>
<p>加载媒体查询的最佳方法：</p>
<p>​	使用<code>多个独立的CSS文件会增加HTTP请求的数量</code>，使页面加载变慢。所以我们的媒体查询样式的文件尽量放在一个里面，以注释加以区分。</p>
<p>阻止移动浏览器自动调整页面大小</p>
<p>​	<code>ios和android浏览器都基于webkit内核</code>，这两种浏览器和许多其它浏览器都支持用<code>viewport，meta元素覆盖默认的画布缩放设置</code>。只需要在HTML的<code>&lt;head&gt;</code>标签中插入一个<code>&lt;meta&gt;</code>标签，<code>meta</code>标签中可以设置具体的宽度或缩放比。下面为示例</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span>  <span class="hljs-attr">content</span>=<span class="hljs-string">"initial-scale=1.0,width=device-width"</span> /&gt;</span></code></pre>
<p><code>name=”viewport”</code>  说明此meta标签定义视口的属性<br>
<code>​initial-scale=2.0</code>   意思是将页面放大两倍<br>
<code>​width=device-width</code>   告诉浏览器页面的宽度等于设备宽度</p>
<p>允许用户将页面最大放大至设备宽度3倍，最小压缩至设备宽度的一半</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”viewport”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”width</span>=<span class="hljs-string">device-width,</span> <span class="hljs-attr">maximum-scale</span>=<span class="hljs-string">3,</span> <span class="hljs-attr">minimum-scale</span>=<span class="hljs-string">0.5”</span> /&gt;</span></code></pre>
<p>禁止用户缩放，可以在混合<code>APP</code>时，为了使<code>html</code>页面更逼真，使页面无法缩放</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”viewport”</span> <span class="hljs-attr">content</span>=<span class="hljs-string">”initial-scale</span>=<span class="hljs-string">1.0,</span> <span class="hljs-attr">user-scalable</span>=<span class="hljs-string">no”</span> /&gt;</span>   //user-scalable=no是禁止缩放</code></pre>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>display属性和盒子模型</title>
    <url>/2020/09/02/css/display%E5%92%8C%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/mountains-190055_1280.jpg" alt=""></p>
<hr>
<h2 id="display属性">display属性</h2>
<p>​	根据CSS规范的规定，每一个网页元素都有一个display属性，用于确定该元素的类型，每一个元素都有默认的display属性值，比如div元素，它的默认display属性值为“block”，称为块元素，而span元素的默认display属性值为“inline”，称为“行内”元素。</p>
<p>​       块元素与行元素是可以转换的，也就是说display的属性值可以由我们来改变 。</p>
<h3 id="display常见属性值">display常见属性值</h3>
<ol>
<li>none：隐藏对象</li>
<li>inline：指定对象为内联元素</li>
<li>block：指定对象为块元素</li>
<li>inline-block：指定对象为内联块元素</li>
<li>table-cell：指定对象作为表格单元格</li>
<li>flex：弹性盒</li>
</ol>
<h3 id="visibility-hidden和display-none和opacity-0的区别：">visibility:hidden和display:none和opacity:0的区别：</h3>
<ol>
<li>
<p><code>visibility:hidden</code>和<code>opacity:0</code>会将元素隐藏，但是物理位置实际存在。</p>
</li>
<li>
<p><code>display:none</code> 隐藏元素，不保留物理位置。</p>
</li>
</ol>
<p>​	网页中大部分对象<code>默认是占用文档流</code>，也有一些对象是不占文档流的，比如表单中隐藏域。当然我们也可以让占用文档流的元素转换成不占文档流，这就要用到CSS中属性position、float、display来控制。默认情况下，所有元素都处在文档流中。</p>
<p>四种情况将<code>使得元素离开文档流：浮动float、绝对定位absolute、固定定位fixed、元素不显示display:none</code>，这种情况不占文档流的空间，而普通元素的位置基于文档流。</p>
<h2 id="盒子模型">盒子模型</h2>
<h3 id="W3C盒模型">W3C盒模型</h3>
<p>盒模型由内容(content)、填充(padding)、边框(border)、边界(margin)组成</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305211024837.png" alt="image-20210305211024837"></p>
<h3 id="margin（外边距）">margin（外边距）</h3>
<p>围绕在元素边框周围的空白区域，会在元素外创建额外的空白区域，外边距是透明的。<br>
语法：<code>margin:value;</code><br>
<code>margin-top/right/bottom/left: value;</code><br>
value可取值为<code>像素，%，auto，负值</code></p>
<p>外边距简写</p>
<pre><code class="hljs css"><span class="hljs-attribute">margin</span>:<span class="hljs-built_in">value</span>(四个方向相同) ;
<span class="hljs-attribute">margin</span>: <span class="hljs-built_in">value</span>(上下) <span class="hljs-built_in">value</span>(左右);
<span class="hljs-attribute">margin</span>: <span class="hljs-built_in">value</span>(上) <span class="hljs-built_in">value</span>(左右) <span class="hljs-built_in">value</span>(下);
<span class="hljs-attribute">margin</span>: <span class="hljs-built_in">value</span>(上) <span class="hljs-built_in">value</span>(右) <span class="hljs-built_in">value</span>(下) <span class="hljs-built_in">value</span>(左);</code></pre>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305211118212.png" alt="image-20210305211118212" style="zoom:80%;">
<p>margin设置元素外边距的宽度，它有这么几个特点：</p>
<ol>
<li>块级元素的垂直相邻外边距会合并</li>
<li>行内元素实际上不占上下外边距。行内元素的的左右外边距不合并</li>
<li>浮动元素的外边距也不会合并</li>
<li>允许指定负的外边距值，不过使用时要小心</li>
</ol>
<h3 id="border（边框）">border（边框）</h3>
<p>border属性设置一个元素的边框，它有三个要素：<code>宽、样式、颜色</code>，统称“边框三要素”。三要素书写的时候一般如下顺序：</p>
<p>​	<code>border：宽度 样式 颜色        border: 1px solid red;</code></p>
<p>​	不过不按此顺序来写依然能正常显示。<code>div{ border: red solid 2px; }</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305211414164.png" alt="image-20210305211414164"></p>
<p><code>border-style</code>设置边框的样式，有五种常用样式可选：</p>
<ul>
<li>点状dotted</li>
<li>实线solid</li>
<li>双线double   （ 需要最起码设置为3像素，不然显示不下）</li>
<li>虚线dashed</li>
<li>无边框none</li>
</ul>
<p>border的三要素可以统一写在”border”属性中，也可以单独设置。</p>
<p>​	统一的写法：<code>border: 1px solid  red;</code><br>
​	单独设置的写法：</p>
<pre><code class="hljs css"><span class="hljs-attribute">border-width</span>: ; 
<span class="hljs-attribute">border-style</span>: ;
<span class="hljs-attribute">border-color</span>: ;</code></pre>
<h3 id="padding（内边距）">padding（内边距）</h3>
<p>内容区域和边框之间的空间。会扩大元素边框所占用的区域<br>
语法：<code>padding:value;</code><br>
单边设置<br>
<code>padding-top/right/bottom/left:value;</code>value可取值为像素，百分比，但不能为负数</p>
<p>内边距的简写</p>
<pre><code class="hljs css"><span class="hljs-attribute">padding</span>:<span class="hljs-built_in">value</span>(四个方向相同) ;
<span class="hljs-attribute">padding</span>: <span class="hljs-built_in">value</span>(上下) <span class="hljs-built_in">value</span>(左右);
<span class="hljs-attribute">padding</span>: <span class="hljs-built_in">value</span>(上) <span class="hljs-built_in">value</span>(左右) <span class="hljs-built_in">value</span>(下);
<span class="hljs-attribute">padding</span>: <span class="hljs-built_in">value</span>(上) <span class="hljs-built_in">value</span>(右) <span class="hljs-built_in">value</span>(下) <span class="hljs-built_in">value</span>(左);</code></pre>
<h3 id="怪异盒模型">怪异盒模型</h3>
<p>​	盒子模型分两种，一种是符合W3C规范的标准例子模型，另一种是IE的盒子模型，IE的盒子模型也被叫怪异盒子。<br>
​	可以看到 IE 盒子模型也包括 margin、border、padding、content，不过，和标准 盒子模型不同的是：IE 盒子模型的宽，包含了 border 和 pading。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305211844651.png" alt="image-20210305211844651"></p>
<h3 id="Box-sizing">Box-sizing</h3>
<p>​	<code>box-sizing</code> 属性允许你以“W3C的盒模型”或“IE盒模型”来定义元素，以适应区域。换句话说，当前元素使用哪种盒模型，<code>可以由box-sizing属性来指定</code><br>
​	它有两个值<br>
​	<code>content-box（标准）</code><br>
​	padding和border不被包含在width和height内，<code>元素的实际大小为宽高+border+padding</code>，此为标准模式下的盒模型。</p>
<p>​	<code>border-box（怪异）</code><br>
​	padding和border被包含在定义的width和height中，<code>元素实际的大小为你定义了多宽就是多宽</code>。此属性为怪异模式下的盒模型。</p>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>flex布局</title>
    <url>/2020/09/03/css/flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/beach-1236581_1280.jpg" alt=""></p>
<hr>
<h2 id="伸缩盒模型flexbox">伸缩盒模型flexbox</h2>
<p>伸缩盒模型也叫弹性盒模型，或<code>flexBox</code>。它决定一个盒子在其它盒子中的分布，以及如何处理可用的空间。使用该模型，可以轻松的创建“自适应”浏览器窗口的流动布局。</p>
<blockquote>
<p><code>flexbox</code>是一个很新的东西，在<code>w3c</code>希望可以使用<code>flexbox</code>实现一些更复杂的布局和应用。传统盒模型基于HTML文档流排列，使用弹性盒模型可以规定特定的顺序。要开启弹性盒模型，只需要设置display的属性值 flex，因为它是<code>CSS3</code>中为display新添加的值类型。</p>
</blockquote>
<p>目的：在浏览器窗口变化时，盒子相应改变大小。<br>
<code>设置了弹性盒模型后，float，clear和vertical-align在flex中不起作用。</code></p>
<h3 id="旧的伸缩盒">旧的伸缩盒</h3>
<p>​       伸缩盒从被提出到如今一直在修改，所以这里涉及到了新老写法。伸缩盒最老版本<br>
​	<code>display:box;</code>  将对象作为弹性伸缩盒显示（火狐和<code>webkit</code>内核都支持<code>display:-webkit-box;</code>或<code>display:-moz-box;</code>）。子元素   <code>box-flex:;</code><br>
伸缩盒过渡版本：<code>display:flexbox;</code>  将对象作为弹性伸缩盒显示<br>
伸缩盒最新版本：<code>display:flex;</code>  将对象作为弹性伸缩盒显示</p>
<h3 id="flexbox的基础知识">flexbox的基础知识</h3>
<p>​	由于 <code>flexbox</code>是一个整体的模块，它们之中一些属性是在父容器上设置，而一些是在子容器上设置。一个<code>flexbox</code>的基本结构：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
<span class="css">         <span class="hljs-selector-class">.box</span>{ <span class="hljs-attribute">display</span>: flex;}    //最外层的为父容器，定义此容器为弹性布局</span>
<span class="css">        <span class="hljs-selector-class">.item1</span>{ <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>; <span class="hljs-attribute">background</span>:pink}       <span class="hljs-attribute">flex-grow</span>占<span class="hljs-number">1</span>比例</span>
<span class="css">        <span class="hljs-selector-class">.item2</span>{ <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">2</span>; <span class="hljs-attribute">background</span>:orange}     占<span class="hljs-number">2</span>比例</span>
<span class="css">        <span class="hljs-selector-class">.item3</span>{ <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">3</span>; <span class="hljs-attribute">background</span>:red}        占<span class="hljs-number">3</span>比例</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>   
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item1"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item2"</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item3"</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>1.首先规定哪个是父容器，父容器中包含多个“项目”（每个子div），项目是可以在父容器中弹性布局的。<br>
2.其次还可以规定父容器中要怎么来显示它里面的项目，如是否换行、项目排列方向等</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306112154902.png" alt="image-20210306112154902"></p>
<h3 id="父容器常用属性">父容器常用属性</h3>
<p><code>display: flex;</code>   定义一个flex容器。新弹性盒  设置父元素是一个弹性盒，子元素会自动水平排列</p>
<p><code>justify-content: flex-end;</code>   设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306112215032.png" alt="image-20210306112215032"></p>
<p><code>align-items</code> 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306112226193.png" alt="image-20210306112226193"></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
   .container{
<span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span>
<span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span>
<span class="css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span>
<span class="css">        <span class="hljs-attribute">display</span>: flex;</span>
<span class="css">        <span class="hljs-attribute">justify-content</span>: center;</span>
<span class="css">        <span class="hljs-attribute">align-items</span>: center;</span>
    }
<span class="css">    <span class="hljs-selector-class">.container</span> <span class="hljs-selector-tag">div</span>{</span>
<span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span>
<span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span>
<span class="css">     <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blueviolet;</span>
     }   
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306112238867.png" alt="image-20210306112238867"></p>
<p><code>flex-wrap</code>  让弹性盒元素在必要的时候拆行</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306112251352.png" alt="image-20210306112251352"></p>
<h3 id="子元素常用属性">子元素常用属性</h3>
<p>伸缩盒中的每一个元素称为一个项目。<br>
<code>flex-grow: number;</code>   一个数字，规定项目将相对于其他灵活的项目进行扩展的量。默认值是 0。</p>
<pre><code class="hljs css"><span class="hljs-selector-class">.item1</span>{ <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>; <span class="hljs-attribute">background</span>:pink}                
<span class="hljs-selector-class">.item2</span>{ <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>; <span class="hljs-attribute">background</span>:orange}             
<span class="hljs-selector-class">.item3</span>{ <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>; <span class="hljs-attribute">background</span>:red}</code></pre>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>Position定位和z-index</title>
    <url>/2020/09/01/css/position%E5%92%8Cz-index/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/lake-1581879_1280.jpg" alt=""></p>
<hr>
<h2 id="position定位">position定位</h2>
<p>position属性指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305201823730.png" alt="image-20210305201823730"></p>
<h3 id="realtive">realtive</h3>
<p>以<code>自身为参照物</code>移动到指定的位置，并且<code>被定位的元素会占据原有的位置</code></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
<span class="css">		<span class="hljs-selector-tag">div</span>{</span>
<span class="css">			<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span>
        }
        .d1{
<span class="css">			<span class="hljs-attribute">background-color</span>: red;</span>
        }
        .d2{
<span class="css">			<span class="hljs-attribute">background-color</span>: black;</span>
<span class="css">			<span class="hljs-attribute">position</span>: relative;</span>
/* 			left: 200px;
<span class="css">			<span class="hljs-attribute">top</span>: <span class="hljs-number">200px</span>; */</span>
        }
        .d3{
<span class="css">			<span class="hljs-attribute">background-color</span>: aliceblue;</span>
        }
    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305203011083.png" alt="image-20210305203011083" style="zoom:50%;">
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
<span class="css">		<span class="hljs-selector-tag">div</span>{</span>
<span class="css">			<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span>
        }
        .d1{
<span class="css">			<span class="hljs-attribute">background-color</span>: red;</span>
        }
        .d2{
<span class="css">			<span class="hljs-attribute">background-color</span>: black;</span>
<span class="css">			<span class="hljs-attribute">position</span>: relative;</span>
/* 			left: 200px;
<span class="css">			<span class="hljs-attribute">top</span>: <span class="hljs-number">200px</span>; */</span>
        }
        .d3{
<span class="css">			<span class="hljs-attribute">background-color</span>: aliceblue;</span>
        }
    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305203041348.png" alt="image-20210305203041348" style="zoom:50%;">
<h3 id="absolute">absolute</h3>
<p>以其他元素作为参照物，移动指定距离，且不会占据原有的位置，关于 <code>absolute</code> 定位参考点的选择：</p>
<ol>
<li>如果元素的外层元素是非 <code>static</code> 定位（有除默认属性之外的定位属性），那么外层元素就成为了该元素的定位参考点。</li>
<li>如果元素的外层元素没有设置任何 <code>position</code> 的值，那么该元素将寻找离自己最近的设定过非默认 <code>position</code> 属性的外层元素作为参照物。</li>
<li>如果元素的外层元素没有找到设定为非默认 <code>positon</code> 属性的外层元素，那么此时定位参考元素变为 <code>body</code> ，或者说页面</li>
</ol>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
<span class="css">		<span class="hljs-selector-tag">div</span>{</span>
<span class="css">			<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span>
        }
        .d1{
<span class="css">			<span class="hljs-attribute">background-color</span>: red;</span>
        }
        .d2{
<span class="css">			<span class="hljs-attribute">background-color</span>: black;</span>
<span class="css">			<span class="hljs-attribute">position</span>: absolute;</span>
        }
        .d3{
<span class="css">			<span class="hljs-attribute">background-color</span>: aliceblue;</span>
        }
    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305203556950.png" alt="image-20210305203556950" style="zoom:50%;">
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
<span class="css">		<span class="hljs-selector-tag">div</span>{</span>
<span class="css">			<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span>
        }
        .d1{
<span class="css">			<span class="hljs-attribute">background-color</span>: red;</span>
        }
        .d2{
<span class="css">			<span class="hljs-attribute">background-color</span>: black;</span>
<span class="css">			<span class="hljs-attribute">position</span>: absolute;</span>
<span class="css">			<span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">top</span>: <span class="hljs-number">200px</span>;</span>
        }
        .d3{
<span class="css">			<span class="hljs-attribute">background-color</span>: aliceblue;</span>
        }
    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305203705689.png" alt="image-20210305203705689" style="zoom:50%;">
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
<span class="css">	<span class="hljs-selector-tag">div</span>{</span>
<span class="css">		<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">		<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span>
    }
    .d1{
<span class="css">		<span class="hljs-attribute">background-color</span>: red;</span>
    }
    .d2{
<span class="css">		<span class="hljs-attribute">background-color</span>: black;</span>
<span class="css">		<span class="hljs-attribute">position</span>: relative;</span>
<span class="css">		<span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span>
<span class="css">		<span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span>
    }
    .d22{
<span class="css">		<span class="hljs-attribute">position</span>: absolute;</span>
<span class="css">		<span class="hljs-attribute">background-color</span>: aqua;</span>
<span class="css">		<span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;</span>
<span class="css">		<span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;</span>
    }
    .d3{
<span class="css">		<span class="hljs-attribute">background-color</span>: aliceblue;</span>
    }
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d22"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305204434371.png" alt="image-20210305204434371" style="zoom:50%;">
<h3 id="fixed">fixed</h3>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
        .d1{
<span class="css">			<span class="hljs-attribute">background-color</span>: bisque;</span>
<span class="css">			<span class="hljs-attribute">width</span>: <span class="hljs-number">1000px</span>;</span>
<span class="css">			<span class="hljs-attribute">height</span>: <span class="hljs-number">1000px</span>;</span>
        }
        .d2{
<span class="css">			<span class="hljs-attribute">position</span>: fixed;</span>
<span class="css">			<span class="hljs-attribute">background-color</span>: aqua;</span>
<span class="css">			<span class="hljs-attribute">right</span>: <span class="hljs-number">0px</span>;</span>
<span class="css">			<span class="hljs-attribute">top</span>: <span class="hljs-number">0px</span>;</span>
<span class="css">			<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span>
        }
    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        &gt;&gt;&gt;&gt;&gt;&gt;1
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        &gt;&gt;&gt;&gt;&gt;&gt;2
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305205431227.png" alt="image-20210305205431227"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305205442554.png" alt="image-20210305205442554"></p>
<h2 id="z-index堆叠顺序">z-index堆叠顺序</h2>
<p>一旦修改了元素的定位方式，则元素可能会发生堆叠。可以<code>使用z-index属性来控制定位元素的出现顺序</code>。z-index仅能在定位的元素（使用了 <code>position</code> 非默认属性的元素）上生效<br>
z-index属性：<br>
值为数值，数值越大表示堆叠顺序越高，即离用户越近，可以设置为负值，表示离用户更远 ，一般不设置负值</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
        .d1{
<span class="css">			<span class="hljs-attribute">background-color</span>: black;</span>
<span class="css">			<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">position</span>: absolute;</span>
<span class="css">			<span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">top</span>: <span class="hljs-number">200px</span>;</span>
        }
        .d2{
<span class="css">			<span class="hljs-attribute">position</span>: fixed;</span>
<span class="css">			<span class="hljs-attribute">background-color</span>: red;</span>
<span class="css">			<span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;</span>
<span class="css">			<span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;</span>
<span class="css">			<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span>
        }
    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305210239608.png" alt="image-20210305210239608" style="zoom:50%;">
<p>可以发现后面的<code>div</code>会覆盖前面的，如果想让前面的覆盖后面的，可以设置 <code>z-index</code>：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
        .d1{
<span class="css">			<span class="hljs-attribute">background-color</span>: black;</span>
<span class="css">			<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">position</span>: absolute;</span>
<span class="css">			<span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">top</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;</span>
        }
        .d2{
<span class="css">			<span class="hljs-attribute">position</span>: fixed;</span>
<span class="css">			<span class="hljs-attribute">background-color</span>: red;</span>
<span class="css">			<span class="hljs-attribute">left</span>: <span class="hljs-number">100px</span>;</span>
<span class="css">			<span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;</span>
<span class="css">			<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span>
<span class="css">			<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span>
        }
    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210305210411571.png" alt="image-20210305210411571" style="zoom:50%;">
]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>栅格布局基本概念</title>
    <url>/2020/09/04/css/%E6%A0%85%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/mountain-547363_1280.jpg" alt=""></p>
<hr>
<h2 id="栅格化布局">栅格化布局</h2>
<p>网格布局<code>（Grid）</code>是最强大的 CSS 布局方案。</p>
<p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 <code>CSS 框架</code>达到的效果，现在浏览器内置了。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306123208640.png" alt="image-20210306123208640"></p>
<p>Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p>
<p>Flex 布局是轴线布局，只能指定"项目"针对轴线的位置，可以看作是一维布局。</p>
<p>Grid 布局则是将容器划分成"行"和"列"，产生单元格，然后指定"项目所在"的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。</p>
<h3 id="基本概念">基本概念</h3>
<p>容器和项目<br>
采用网格布局的区域，称为<code>"容器"（container）</code>。容器内部采用网格定位的子元素，称为<code>"项目"（item）</code>。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306123226964.png" alt="image-20210306123226964"></p>
<p>上面代码中，最外层的<code>&lt;div&gt;</code>元素就是容器，内层的三个<code>&lt;div&gt;</code>元素就是项目。</p>
<p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<code>&lt;p&gt;</code>元素就不是项目。Grid 布局只对项目生效。</p>
<p>行和列<br>
容器里面的水平区域称为"行"（row），垂直区域称为"列"（column）。水平的深色区域就是"行"，垂直的深色区域就是"列"</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306123236954.png" alt="image-20210306123236954"></p>
<h3 id="容器中的属性">容器中的属性</h3>
<p><code>display：grid</code>  指定一个容器采用网格布局，默认情况下，容器元素都是块元素。inline-grid  设置为行内元素网格布局</p>
<p><code>grid-template-columns</code> 属性定义每一列的列宽。<br>
<code>grid-template-rows</code> 属性定义每一行的行高</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210306123247282.png" alt="image-20210306123247282"></p>
<p>注意，设为网格布局以后，<code>容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</code></p>
<p>科普视频：</p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=629123551&amp;bvid=BV1Gt4y1z7NQ&amp;cid=293320928&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">
    </iframe>
</div>
]]></content>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis入门01环境搭建和原理概述</title>
    <url>/2020/01/01/Mybatis/MyBatis%E5%85%A5%E9%97%A801%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/cover/tree.png" alt=""></p>
<hr>
<h1>MyBatis入门01环境搭建和原理概述</h1>
<h2 id="1-Mybatis概述">1. Mybatis概述</h2>
<p>mybatis 是一个优秀的基于 java 的持久层框架</p>
<ol>
<li><code>它内部封装了 jdbc</code>，使开发者只需要关注 sql 语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。</li>
<li>mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中<br>
sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并<br>
返回。</li>
<li>采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，<code>屏蔽了 jdbc api 底层访问细节</code>，使我<br>
们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。</li>
</ol>
<h2 id="2-搭建MyBatis框架环境">2.  搭建MyBatis框架环境</h2>
<h3 id="2-1-创建maven工程">2.1. 创建maven工程</h3>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/mybatis01/image-20200528100131635.png" alt="image-20200528100131635">
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/mybatis01/image-20200528100240919.png" alt="image-20200528100240919">
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/mybatis01/image-20200528100320103.png" alt="image-20200528100320103">
<hr>
<h3 id="2-2-导入依赖">2.2. 导入依赖</h3>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3 id="2-3-编写实体类（如：User类）持久层接口（如：UserDao-UserMapper）">2.3. 编写实体类（如：User类）持久层接口（如：UserDao/UserMapper）</h3>
<h3 id="2-4-编写接口的映射文件">2.4. 编写接口的映射文件</h3>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/mybatis01/image-20200528100817522.png" alt="image-20200528100817522">
<hr>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span>
<span class="hljs-meta">PUBLIC <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span>
<span class="hljs-meta"><span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.itheima.dao.IUserDao"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置查询所有操作 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"com.itheima.domain.User"</span>&gt;</span>
select * from user
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre>
<h3 id="2-5-编写核心配置文件-SqlMapConfig-xml-resources目录下">2.5. 编写核心配置文件 SqlMapConfig.xml  (resources目录下)</h3>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span>
<span class="hljs-meta">PUBLIC <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span>
<span class="hljs-meta"><span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置 mybatis 的环境 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"mysql"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置 mysql 的环境 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mysql"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置事务的类型 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/ee50"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1234"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 告知 mybatis 映射配置的位置 resource表明其在resources文件上 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"com/itheima/dao/IUserDao.xml"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>
<h2 id="3-MyBatis框架原理">3. MyBatis框架原理</h2>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisTest</span> </span>{
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>{
<span class="hljs-comment">//1.读取配置文件</span>
InputStream in = Resources.getResourceAsStream(<span class="hljs-string">"SqlMapConfig.xml"</span>);
<span class="hljs-comment">//2.创建 SqlSessionFactory 的构建者对象</span>
SqlSessionFactoryBuilder builder = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();
<span class="hljs-comment">//3.使用构建者创建工厂对象 SqlSessionFactory</span>
SqlSessionFactory factory = builder.build(in);
<span class="hljs-comment">//4.使用 SqlSessionFactory 生产 SqlSession 对象</span>
SqlSession session = factory.openSession();
<span class="hljs-comment">//5.使用 SqlSession 创建 dao 接口的代理对象</span>
IUserDao userDao = session.getMapper(IUserDao.class);
<span class="hljs-comment">//6.使用代理对象执行查询所有方法</span>
List&lt;User&gt; users = userDao.findAll();
<span class="hljs-keyword">for</span>(User user : users) {
System.out.println(user);
}
<span class="hljs-comment">//7.释放资源</span>
session.close();
in.close();
}
}</code></pre>
<h3 id="3-1-构建者模式">3.1 构建者模式</h3>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/mybatis01/image-20200528140047789.png" alt="image-20200528140047789"></p>
<hr>
<h4 id="3-2-工厂模式">3.2 工厂模式</h4>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/mybatis01/image-20200528143748636.png" alt="image-20200528143748636">
<hr>
]]></content>
      <tags>
        <tag>Mybatis框架</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis入门02参数映射和结果封装</title>
    <url>/2020/01/02/Mybatis/MyBatis%E5%85%A5%E9%97%A802%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%E5%92%8C%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2021/01/13/22/50/waterford-5915361_1280.jpg" alt=""></p>
<hr>
<h1>MyBatis入门02参数映射和结果封装和配置文件</h1>
<h2 id="1-parameterType-配置参数">1. parameterType 配置参数</h2>
<p>实体类型：全类名</p>
<p>基本类型和String ：直接写类名称（首字母大写），也可以使用别名（首字母小写）</p>
<h2 id="2-Mybatis-的输出结果封装">2. Mybatis 的输出结果封装</h2>
<h3 id="2-1-resultType">2.1 resultType</h3>
<p>实体类型：全类名，<strong>实体类中的属性名称必须和查询语句中的列名保持一致，否则无法实现封装</strong></p>
<p>基本类型和String ：直接写类名称（首字母大写），也可以使用别名（首字母小写）</p>
<h3 id="2-2-resultMap">2.2 resultMap</h3>
<p>resultMap 标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 建立 User 实体和数据库表的对应关系</span>
<span class="hljs-comment">type 属性：指定实体类的全限定类名</span>
<span class="hljs-comment">id 属性：给定一个唯一标识，是给查询 select 标签引用用的。</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.itheima.domain.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userMap"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userId"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userName"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userSex"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"address"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userAddress"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"userBirthday"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>
id 标签：用于指定主键字段
result 标签：用于指定非主键字段
column 属性：用于指定数据库列名
property 属性：用于指定实体类属性名称</code></pre>
<h2 id="3-SqlMapConfig-xml配置文件">3. SqlMapConfig.xml配置文件</h2>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span>
<span class="hljs-meta">PUBLIC <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span>
<span class="hljs-meta"><span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>
<h3 id="3-1-typeAliases（类型别名）">3.1 typeAliases（类型别名）</h3>
<p>在 <code>&lt;configuration&gt;&lt;/configuration&gt;</code>中配置</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 单个别名定义 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"com.itheima.domain.User"</span>/&gt;</span>
<span class="hljs-comment">&lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.itheima.domain"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"其它包"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre>
<h3 id="3-2-mappers（映射器）">3.2 mappers（映射器）</h3>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
    
<span class="hljs-comment">&lt;!-- 注册指定包下的所有 mapper 接口,直接写包名，注意目录结构要相同，接口名和配置文件名相同--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.hnust.dao"</span>/&gt;</span>
    
<span class="hljs-comment">&lt;!-- 映射某个配置文件，注意目录结构要相同，接口名和配置文件名相同--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"com.hnust/dao/UserDao.xml"</span>/&gt;</span>
    
<span class="hljs-comment">&lt;!--用于注解 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"cn.hnust.UserDAO"</span>/&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre>
]]></content>
      <tags>
        <tag>Mybatis框架</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis入门03动态SQL和多表查询</title>
    <url>/2020/01/03/Mybatis/MyBatis%E5%85%A5%E9%97%A803%E5%8A%A8%E6%80%81SQL%E5%92%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2021/01/18/18/55/sheep-5929158_1280.jpg" alt=""></p>
<hr>
<h1>MyBatis入门03动态SQL和多表查询</h1>
<h2 id="1-动态SQL语句">1. 动态SQL语句</h2>
<h3 id="1-1-动态-SQL-之if标签">1.1 动态 SQL 之if标签</h3>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findByUser"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"user"</span>&gt;</span>
    
select * from user where 1=1
    
<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username!=null and username != '' "</span>&gt;</span>
and username like #{username}
<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"address != null"</span>&gt;</span>
and address like #{address}
<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<h3 id="1-2-动态-SQL-之where标签">1.2 动态 SQL 之where标签</h3>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 根据用户信息查询  if标签的 "and" 不能不写 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findByUser"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"user"</span>&gt;</span>
    
select * from user
    
<span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"username!=null and username != '' "</span>&gt;</span>
and username like #{username}
<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"address != null"</span>&gt;</span>
and address like #{address}
<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<h3 id="1-3-动态标签之foreach标签">1.3 动态标签之foreach标签</h3>
<p>传入多个 id 查询用户信息，用下边两个 sql 实现：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> USERS <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%zhangruwang%'</span> <span class="hljs-keyword">AND</span> (id <span class="hljs-operator">=</span><span class="hljs-number">10</span> <span class="hljs-keyword">OR</span> id <span class="hljs-operator">=</span><span class="hljs-number">89</span> <span class="hljs-keyword">OR</span> id<span class="hljs-operator">=</span><span class="hljs-number">16</span>)
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> USERS <span class="hljs-keyword">WHERE</span> username <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'%zhangruwang%'</span> <span class="hljs-keyword">AND</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-number">10</span>,<span class="hljs-number">89</span>,<span class="hljs-number">16</span>)</code></pre>
<p>这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。  注意不能直接用集合作为参数，只能将它包装在一个对象中（如   Queryvo  queryvo 中包含一个   <code>List&lt;Integer&gt; ids</code>  ）</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 查询所有用户在 id 的集合之中 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findInIds"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"queryvo"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- select * from user where id in (1,2,3,4,5); --&gt;</span>
select * from user 
<span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"ids != null and ids.size() &gt; 0"</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"ids"</span> <span class="hljs-attr">open</span>=<span class="hljs-string">"id in ( "</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"uid"</span></span>
<span class="hljs-tag"><span class="hljs-attr">separator</span>=<span class="hljs-string">","</span>&gt;</span>
#{uid}
<span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
SQL 语句：
select 字段 from user where id in (?)
<span class="hljs-tag">&lt;<span class="hljs-name">foreach</span>&gt;</span>标签用于遍历集合，它的属性：
collection:代表要遍历的集合元素，注意编写时不要写#{}
open:代表语句的开始部分
close:代表结束部分
item:代表遍历集合的每个元素，生成的变量名
sperator:代表分隔符</code></pre>
<h3 id="1-4-include标签抽取重复sql">1.4 include标签抽取重复sql</h3>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 抽取重复的语句代码片段 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"defaultSql"</span>&gt;</span>
select * from user
<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 配置查询所有操作 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"defaultSql"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<h2 id="2-Mybatis-多表查询">2. Mybatis 多表查询</h2>
<h3 id="2-1-一对一查询-多对一">2.1 一对一查询(多对一)</h3>
<p>因为一个账户信息只能供某个用户使用，所以从查询账户信息出发关联查询用户信息为一对一查询。如<br>
果从用户信息出发查询用户下的账户信息则为一对多查询，因为一个用户可以有多个账户。</p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> account.<span class="hljs-operator">*</span>,user.username,user.address
<span class="hljs-keyword">FROM</span> account,<span class="hljs-keyword">user</span>
<span class="hljs-keyword">WHERE</span> account.uid <span class="hljs-operator">=</span> user.id</code></pre>
<p>第一种方式</p>
<pre><code class="hljs xml">定义了一个 AccountUser 类用于接收结果

<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"accountuser"</span>&gt;</span>
select a.*,u.username,u.address from account a,user u where a.uid =u.id;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<p>第二种方式</p>
<pre><code class="hljs xml">在 Account 类中加入 User 类的对象作为 Account 类的一个属性。

<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"account"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountMap"</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"aid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"uid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"uid"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"money"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"money"</span>/&gt;</span>
    
<span class="hljs-comment">&lt;!-- 它是用于指定从表方的引用实体属性的 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"user"</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"username"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"birthday"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"address"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"address"</span>/&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"accountMap"</span>&gt;</span>
select u.*,a.id as aid,a.uid,a.money from account a,user u where a.uid =u.id;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<h3 id="2-2-一对多查询">2.2 一对多查询</h3>
<p>用户信息和他的账户信息为一对多关系，并且查询过程中如果用户没有账户信息，此时也要将用户信息<br>
查询出来，我们想到了左外连接查询比较合适</p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> u.<span class="hljs-operator">*</span>, acc.id id,acc.uid,acc.money
<span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> u
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> account acc <span class="hljs-keyword">ON</span> u.id <span class="hljs-operator">=</span> acc.uid</code></pre>
<pre><code class="hljs xml">User 类加入 List<span class="hljs-tag">&lt;<span class="hljs-name">Account</span>&gt;</span>  

<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userMap"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"username"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"address"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"address"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"birthday"</span>/&gt;</span>
    
<span class="hljs-comment">&lt;!-- collection 是用于建立一对多中集合属性的对应关系  ofType 用于指定集合元素的数据类型--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"accounts"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"account"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"aid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"uid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"uid"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"money"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"money"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 配置查询所有操作 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"userMap"</span>&gt;</span>
select u.*,a.id as aid ,a.uid,a.money from user u left outer join account
a on u.id =a.uid
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>

collection部分定义了用户关联的账户信息。表示关联查询结果集
property="accounts"：关联查询的结果集存储在 User 对象的上哪个属性。
ofType="account"：指定关联查询的结果集中的对象类型即List中的对象类型。此处可以使用别名，也可以使用全限定名。</code></pre>
<h3 id="2-3-多对多查询">2.3 多对多查询</h3>
<p>查询角色我们需要用到Role表，但角色分配的用户的信息我们并不能直接找到用户信息，而是要通过中<br>
间表(USER_ROLE 表)才能关联到用户信息。</p>
<pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> r.<span class="hljs-operator">*</span>,u.id uid,u.username username,u.birthday birthday,u.sex sex,u.address address
<span class="hljs-keyword">FROM</span> ROLE r <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> USER_ROLE ur
<span class="hljs-keyword">ON</span> ( r.id <span class="hljs-operator">=</span> ur.rid)
<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">USER</span> u
<span class="hljs-keyword">ON</span> (ur.uid <span class="hljs-operator">=</span> u.id)</code></pre>
<pre><code class="hljs xml">Role 类加入 List<span class="hljs-tag">&lt;<span class="hljs-name">User</span>&gt;</span>  
    
<span class="hljs-comment">&lt;!--定义 role 表的 ResultMap--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"roleMap"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"role"</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleId"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"rid"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleName"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"role_name"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"roleDesc"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"role_desc"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"users"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"user"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"address"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"address"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"birthday"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>
    
    
<span class="hljs-comment">&lt;!--查询所有--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"roleMap"</span>&gt;</span>
select u.*,r.id as rid,r.role_name,r.role_desc from role r
left outer join user_role ur on r.id = ur.rid
left outer join user u on u.id = ur.uid
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
]]></content>
      <tags>
        <tag>Mybatis框架</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis入门04延迟加载和缓存功能</title>
    <url>/2020/01/04/Mybatis/MyBatis%E5%85%A5%E9%97%A804%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2013/05/15/09/12/tourist-attraction-111329_1280.jpg" alt=""></p>
<hr>
<h1>MyBatis入门04延迟加载和缓存功能</h1>
<h2 id="1-Mybatis-延迟加载策略">1. Mybatis 延迟加载策略</h2>
<p>延迟加载：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载.<br>
好处： 先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多zhangruwang表速度要快。</p>
<p>坏处：因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。</p>
<pre><code class="hljs xml">需先在 SqlMapConfig.xml 中配置开启功能
<span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"lazyLoadingEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"aggressiveLazyLoading"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"false"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre>
<h3 id="1-1-使用-assocation-实现延迟加载">1.1 使用 assocation 实现延迟加载</h3>
<p>查询账户信息同时查询用户信息  Account 中有 User 类</p>
<pre><code class="hljs xml">AccountDao.xml
List<span class="hljs-tag">&lt;<span class="hljs-name">Account</span>&gt;</span> findAll();

<span class="hljs-comment">&lt;!-- 建立对应关系 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"account"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountMap"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"aid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"uid"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"uid"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"money"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"money"</span>/&gt;</span>
    
<span class="hljs-comment">&lt;!-- 它是用于指定从表方的引用实体属性的 --&gt;</span>
    select： 填写我们要调用的 select 映射的 id
    column ： 填写我们要传递给 select 映射的参数
<span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"com.itheima.dao.IUserDao.findById"</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"uid"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"accountMap"</span>&gt;</span>
select * from account
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<pre><code class="hljs xml">UserDao.xml
User findById(Integer userId);

<span class="hljs-comment">&lt;!-- 根据 id 查询 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span> &gt;</span>
select * from user where id = #{uid}
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<h3 id="1-2-使用-Collection-实现延迟加载">1.2 使用 Collection 实现延迟加载</h3>
<p>完成加载用户对象时，查询该用户所拥有的账户信息。</p>
<p>User 中有 List<account></account></p>
<pre><code class="hljs xml">UserDao.xml

<span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userMap"</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"id"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"username"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"address"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"address"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"sex"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"birthday"</span>/&gt;</span>
    
<span class="hljs-comment">&lt;!-- collection 是用于建立一对多中集合属性的对应关系</span>
<span class="hljs-comment">ofType 用于指定集合元素的数据类型</span>
<span class="hljs-comment">select 是用于指定查询账户的唯一标识（账户的 dao 全限定类名加上方法名称）</span>
<span class="hljs-comment">column 是用于指定使用哪个字段的值作为条件查询</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">"accounts"</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">"account"</span></span>
<span class="hljs-tag"><span class="hljs-attr">select</span>=<span class="hljs-string">"com.itheima.dao.IAccountDao.findByUid"</span></span>
<span class="hljs-tag"><span class="hljs-attr">column</span>=<span class="hljs-string">"id"</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 配置查询所有操作 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"userMap"</span>&gt;</span>
select * from user
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<pre><code class="hljs xml">AccountDao.xml

<span class="hljs-comment">&lt;!-- 根据用户 id 查询账户信息 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findByUid"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"account"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span>&gt;</span>
select * from account where uid = #{uid}
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre>
<h2 id="2-Mybatis-缓存">2. Mybatis 缓存</h2>
<p>提供了缓存策略，通过缓存策略来减少数据库的查询次数， 从而提高性能。Mybatis 中缓存分为一级缓存，二级缓存。</p>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/mybatis01/image-20200528174434282.png" alt="image-20200528174434282">
<hr>
<h3 id="2-1-一级缓存">2.1 一级缓存</h3>
<p>一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除， commit()， close()等 方法时，就会清空一级缓存</p>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/mybatis01/image-20200528175000842.png" alt="image-20200528175000842">
<hr>
<h3 id="2-2-二级缓存">2.2 二级缓存</h3>
<p>二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。</p>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/mybatis01/image-20200528175101555.png" alt="image-20200528175101555">
<hr>
<h5 id="二级缓存的开启与关闭">二级缓存的开启与关闭</h5>
<p>在 SqlMapConfig.xml 文件开启二级缓存</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 开启二级缓存的支持 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>
因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为
false 代表不开启二级缓存。</code></pre>
<p>配置相关的 Mapper 映射文件</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>&gt;</span>标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。

<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span>
<span class="hljs-meta">PUBLIC <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span>
<span class="hljs-meta"><span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.itheima.dao.IUserDao"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 开启二级缓存的支持 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">cache</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre>
<p>配置 statement 上面的 useCache 属性</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 根据 id 查询 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"int"</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">"true"</span>&gt;</span>
select * from user where id = #{uid}
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>

将 UserDao.xml 映射文件中的<span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span>标签中设置 useCache=”true”代表当前这个 statement 要使用
二级缓存，如果不使用二级缓存可以设置为 false。
注意： 针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。
当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化方式来保存对象。</code></pre>
]]></content>
      <tags>
        <tag>Mybatis框架</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis入门05基于注解的Mybatis</title>
    <url>/2020/01/05/Mybatis/MyBatis%E5%85%A5%E9%97%A805%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84Mybatis/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2020/04/04/16/07/stadttheater-5002861_1280.jpg" alt=""></p>
<hr>
<h1>MyBatis入门05基于注解的Mybatis</h1>
<h2 id="1-配置方式">1.配置方式</h2>
<p>修改Dao,SqlMapConfig.xml,并移除Dao.xml</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>{
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 查询所有用户</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
Select(<span class="hljs-string">"select * from user"</span>)
<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;
}</code></pre>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 告知 mybatis 映射配置的位置 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.dao.IUserDao"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre>
<h2 id="2-使用方法">2. 使用方法</h2>
<pre><code class="hljs java"><span class="hljs-meta">@Insert</span>:实现新增
<span class="hljs-meta">@Update</span>:实现更新
<span class="hljs-meta">@Delete</span>:实现删除
<span class="hljs-meta">@Select</span>:实现查询
<span class="hljs-meta">@Result</span>:实现结果集封装
<span class="hljs-meta">@Results</span>:可以与<span class="hljs-meta">@Result</span> 一起使用，封装多个结果集
<span class="hljs-meta">@ResultMap</span>:实现引用<span class="hljs-meta">@Results</span> 定义的封装
<span class="hljs-meta">@One</span>:实现一对一结果集封装
<span class="hljs-meta">@Many</span>:实现一对多结果集封装
<span class="hljs-meta">@SelectProvider</span>: 实现动态 SQL 映射
<span class="hljs-meta">@CacheNamespace</span>:实现注解二级缓存的使用</code></pre>
<pre><code class="hljs Java"><span class="hljs-comment">//UserDao中</span>

<span class="hljs-meta">@Select("select * from user")</span>
<span class="hljs-meta">@Results(id="userMap",</span>
<span class="hljs-meta">value= {</span>
<span class="hljs-meta">@Result(id=true,column="id",property="userId"),</span>
<span class="hljs-meta">@Result(column="username",property="userName"),</span>
<span class="hljs-meta">@Result(column="sex",property="userSex"),</span>
<span class="hljs-meta">@Result(column="address",property="userAddress"),</span>
<span class="hljs-meta">@Result(column="birthday",property="userBirthday")</span>
<span class="hljs-meta">})</span>
<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;


<span class="hljs-meta">@Select("select * from user where id = #{uid} ")</span>
<span class="hljs-meta">@ResultMap("userMap")</span>
<span class="hljs-function">User <span class="hljs-title">findById</span><span class="hljs-params">(Integer userId)</span></span>;


<span class="hljs-meta">@Insert("insert into</span>
<span class="hljs-meta">user(username,sex,birthday,address)values(#{username},#{sex},#{birthday},#{address}</span>
<span class="hljs-meta">)")</span>
<span class="hljs-meta">@SelectKey(keyColumn="id",keyProperty="id",resultType=Integer.class,before =</span>
<span class="hljs-meta">false, statement = { "select last_insert_id()" })</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">saveUser</span><span class="hljs-params">(User user)</span></span>;</code></pre>
<p><code>获取插入数据的 id</code></p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"saveUser"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"USER"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置保存时获取插入的 id --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"int"</span>&gt;</span>
select last_insert_id();
<span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span>
insert into user(username,birthday,sex,address)
values(#{username},#{birthday},#{sex},#{address})
<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 查询所有账户，采用延迟加载的方式查询账户的所属用户</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Select("select * from account")</span>
<span class="hljs-meta">@Results(id="accountMap",</span>
<span class="hljs-meta">value= {</span>
<span class="hljs-meta">@Result(id=true,column="id",property="id"),</span>
<span class="hljs-meta">@Result(column="uid",property="uid"),</span>
<span class="hljs-meta">@Result(column="money",property="money"),</span>
<span class="hljs-meta">@Result(column="uid",</span>
<span class="hljs-meta">property="user",</span>
<span class="hljs-meta">one=@One(select="com.itheima.dao.IUserDao.findById",</span>
<span class="hljs-meta">fetchType=FetchType.LAZY)</span>
<span class="hljs-meta">)</span>
<span class="hljs-meta">})</span>
<span class="hljs-function">List&lt;Account&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;</code></pre>
]]></content>
      <tags>
        <tag>Mybatis框架</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker概述和安装</title>
    <url>/2021/05/04/docker/Docker01%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Docker概述">Docker概述</h2>
<h3 id="Docker出现的原因">Docker出现的原因</h3>
<p>一款产品有两个环境：开发（开发环境）和上线（运维环境）。</p>
<p>环境配置和切换过于麻烦，每一台机器都要部署环境（集群Redis,ES,Hadoop），费时费力。</p>
<p>解决思路：发布一个项目<code>（jar+(redis+mysql+jdk+es)）</code>的同时能不能都带上环境安装打包？</p>
<p>传统思路：开发项目，运维部署项目和环境配置。</p>
<p>现在：开发打包部署上线，一套流程做完。</p>
<p><code>Docker为以上问题，提出了解决方案！</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210422110559011.png" alt="image-20210422110559011"></p>
<p>Docker的思想来自于集装箱：通过特殊的隔离机制，将服务器利用到机制。</p>
<h3 id="Docker历史">Docker历史</h3>
<blockquote>
<p>1.Docker诞生于2013年</p>
</blockquote>
<blockquote>
<p>2.Docker &amp; LXC：Docker的第一个执行环境：LXC；但从0.9版本开始被Libcontainer取代</p>
</blockquote>
<blockquote>
<p>3.Docker &amp; Libcontainer：Libcontainer为Docker封装了Linux提供的基础功能，如cgroups，namespaces，netlink和netfilter等</p>
</blockquote>
<blockquote>
<p>4.Docker &amp; RunC： 2015年，Docker发布了RunC，一个轻量级的跨平台的容器运行；可以直接利用Libcontainer运行容器</p>
</blockquote>
<blockquote>
<p>5.Docker &amp; OCI（The Open Containers Initiative）: OCI是一个轻量级的开放式管理架构，由Docker，CoreOS和容器行业的其他领导厂商2015年建立，维护一些项目，制定容器运行的规范等</p>
</blockquote>
<blockquote>
<p>6.Docker &amp; Containerd： 2016年，Docker分拆了Containerd，并将其捐献给了社区；使得Docker将容器的管理功能移出Docker的核心引擎并移入了一个单独的守护进程（containerd）</p>
</blockquote>
<p>在容器技术出来以前，都是使用虚拟机技术，相比于虚拟机几个G,几分钟的启动时间，Docker做到了几个M甚至几KB的容量和秒级开启时间，这主要得益于它并不像虚拟机虚拟出操作系统或者内核，而是只保留了最核心的环境，十分的小巧。<code>所有的程序员都必须要会docker!</code></p>
<h3 id="Docker介绍">Docker介绍</h3>
<p><code>Docker是基于GO语言开发的开源项目！！</code></p>
<p>官网：<a class="link" href="https://www.docker.com/">https://www.docker.com/<i class="fas fa-external-link-alt"></i></a></p>
<p>文档地址：<a class="link" href="https://docs.docker.com/">https://docs.docker.com/<i class="fas fa-external-link-alt"></i></a></p>
<p>仓库地址：<a class="link" href="https://hub.docker.com/">https://hub.docker.com/<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210422111746659.png" alt="image-20210422111746659"></p>
<h3 id="Docker与虚拟机的比较">Docker与虚拟机的比较</h3>
<p>虚拟机技术缺点：启动慢，占用资源多，冗余步骤多</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210422115546688.png" alt="image-20210422115546688" style="zoom:50%;">
<p>Docker容器化技术：不是模拟出一个完整的操作系统。</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210422115733382.png" alt="image-20210422115733382" style="zoom:50%;">
<p>总结：</p>
<ol>
<li>传统虚拟机：虚拟出一系列硬件，运行一个完整的操作系统，然后在这个系统安装和运行软件</li>
<li>容器内的应用直接运行在宿主机上，容器没有自己的内核，也没有虚拟出硬件，所以十分轻便</li>
<li>每个容器是相互隔离的，每个容器都有一个属于自己的文件系统，互不影响。</li>
</ol>
<h3 id="Docker作用">Docker作用</h3>
<p>可以实现了 <code>DevOps(开发，运维)</code></p>
<ol>
<li>应用更快速的交付和部署：打包镜像发布测试，一键运行</li>
<li>更便捷的升级和扩缩容：使用了Docker，部署应用就像搭积木一个，项目打包为一个镜像，方便扩展</li>
<li>更简单的系统运维：在容器化之后，开发和测试环境都是高度一致的。</li>
<li>更高效的计算资源利用：Docker是内核级别的虚拟化，可以在一个物理机上运行多个容器实例，容器的性能可以被压榨到极致。</li>
</ol>
<h2 id="Docker基本组成">Docker基本组成</h2>
<h3 id="架构图">架构图</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210221182251636.png" alt="image-20210221182251636"></p>
<h3 id="基本概念">基本概念</h3>
<ol>
<li>
<p>镜像<code>（image）</code>：docker镜像好比是一个模板，可以通过这个模板创建容器服务，tomcat镜像===》run==》tomcat01容器，通过镜像可以创建多个容器（最终服务运行或项目运行就是在容器中的）</p>
</li>
<li>
<p>容器<code>（container）</code>：docker利用容器技术，独立地运行一个或一组应用，通过<code>image</code>来创建。</p>
<p>启动，停止，删除，基本命令</p>
<p>目前就可以将容器理解为一个简单的Linux系统</p>
</li>
<li>
<p>仓库<code>（repository）</code>：仓库是存放镜像的地方。有公有和私有仓库之分。</p>
<p>Docker Hub(默认是国外的)，阿里云。。。都有容器服务器（配置镜像加速）</p>
</li>
</ol>
<h2 id="Docker安装">Docker安装</h2>
<h3 id="环境准备：">环境准备：</h3>
<ol>
<li>Linux基础</li>
<li>Linux操作系统</li>
<li>使用 Xshell 连接远程服务器</li>
</ol>
<h3 id="查看环境：">查看环境：</h3>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">系统内核是3.10以上的</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# uname -r
3.10.0-514.26.2.el7.x86_64

<span class="hljs-meta">#</span><span class="bash">查看系统信息</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# cat /etc/os-release
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"
</code></pre>
<h3 id="安装教程：">安装教程：</h3>
<p>可以查看官网文档：<a class="link" href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210423220917139.png" alt="image-20210423220917139"></p>
<p>对于 <code>CentOS</code> 系统：</p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">先卸载旧版本Docker系统（如果有的话）</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# sudo yum remove docker \
                   docker-client \
                   docker-client-latest \
                   docker-common \
                   docker-latest \
                   docker-latest-logrotate \
                   docker-logrotate \
                   docker-engine
                   
Loaded plugins: fastestmirror
No Match for argument: docker
No Match for argument: docker-client
No Match for argument: docker-client-latest
No Match for argument: docker-common
No Match for argument: docker-latest
No Match for argument: docker-latest-logrotate
No Match for argument: docker-logrotate
No Match for argument: docker-engine
No Packages marked for removal


<span class="hljs-meta">#</span><span class="bash">安装需要的安装包</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# yum install -y yum-utils

Installed:
  yum-utils.noarch 0:1.1.31-54.el7_8                                                                                                           

Dependency Installed:
  libxml2-python.x86_64 0:2.9.1-6.el7.5           python-chardet.noarch 0:2.2.1-3.el7           python-kitchen.noarch 0:1.1.1-5.el7          

Dependency Updated:
  libxml2.x86_64 0:2.9.1-6.el7.5                                                                                                               

Complete!

<span class="hljs-meta">#</span><span class="bash">配置下载Docker镜像</span>
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

Loaded plugins: fastestmirror
adding repo from: https://download.docker.com/linux/centos/docker-ce.repo
grabbing file https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo
repo saved to /etc/yum.repos.d/docker-ce.repo

<span class="hljs-meta">#</span><span class="bash">安装docker，一路输入确定安装即可</span>
sudo yum install docker-ce docker-ce-cli containerd.io


Dependency Installed:
  audit-libs-python.x86_64 0:2.8.5-4.el7                                  checkpolicy.x86_64 0:2.5-8.el7                                       
  container-selinux.noarch 2:2.119.2-1.911c772.el7_8                      docker-ce-rootless-extras.x86_64 0:20.10.6-3.el7                     
  docker-scan-plugin.x86_64 0:0.7.0-3.el7                                 fuse-overlayfs.x86_64 0:0.7.2-6.el7_8                                
  fuse3-libs.x86_64 0:3.6.1-4.el7                                         libcgroup.x86_64 0:0.41-21.el7                                       
  libseccomp.x86_64 0:2.3.1-4.el7                                         libsemanage-python.x86_64 0:2.5-14.el7                               
  policycoreutils-python.x86_64 0:2.5-34.el7                              python-IPy.noarch 0:0.75-6.el7                                       
  setools-libs.x86_64 0:3.3.8-4.el7                                       slirp4netns.x86_64 0:0.4.3-4.el7_8                                   

Dependency Updated:
  audit.x86_64 0:2.8.5-4.el7                             audit-libs.x86_64 0:2.8.5-4.el7         libselinux.x86_64 0:2.5-15.el7               
  libselinux-python.x86_64 0:2.5-15.el7                  libselinux-utils.x86_64 0:2.5-15.el7    libsemanage.x86_64 0:2.5-14.el7              
  libsepol.x86_64 0:2.5-10.el7                           policycoreutils.x86_64 0:2.5-34.el7     selinux-policy.noarch 0:3.13.1-268.el7_9.2   
  selinux-policy-targeted.noarch 0:3.13.1-268.el7_9.2   

Complete!

</code></pre>
<h3 id="启动测试：">启动测试：</h3>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看 docker 是否安装成功，和版本</span>

[root@izwz91mv6i3x6k12jjqh60z ~]# docker -v

Docker version 20.10.6, build 370c289

<span class="hljs-meta">#</span><span class="bash">启动 docker</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# systemctl start docker

<span class="hljs-meta">#</span><span class="bash">运行测试</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker run hello-world

Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
b8dfde127a29: Pull complete 
Digest: sha256:f2266cbfc127c960fd30e76b7c792dc23b588c0db76233517e1891a4e357d519
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
<span class="hljs-meta"> $</span><span class="bash"> docker run -it ubuntu bash</span>

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/

<span class="hljs-meta">#</span><span class="bash">查看下载的 hello-world 镜像</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
hello-world   latest    d1165f221234   7 weeks ago   13.3kB

</code></pre>
<h3 id="卸载Docker：">卸载Docker：</h3>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">卸载</span>
yum remove docker-ce docker-ce-cli containerd.io

<span class="hljs-meta">#</span><span class="bash">删除文件</span>  
rm -rf /var/lib/docker

<span class="hljs-meta">#</span><span class="bash">/var/lib/docker  是docker的默认工作路径</span></code></pre>
<h2 id="Docker配置阿里云镜像仓库地址">Docker配置阿里云镜像仓库地址</h2>
<p>参考教程：<a class="link" href="https://www.cnblogs.com/allenjing/p/12575972.html">https://www.cnblogs.com/allenjing/p/12575972.html<i class="fas fa-external-link-alt"></i></a></p>
<p>登陆阿里云，找到如下选项：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210428092132408.png" alt="image-20210428092132408"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210428092924853.png" alt="image-20210428092924853"></p>
<pre><code class="hljs shell">sudo mkdir -p /etc/docker

sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
  "registry-mirrors": ["https://bjyjzfeq.mirror.aliyuncs.com"]
}
EOF

sudo systemctl daemon-reload

sudo systemctl restart docker</code></pre>
<h2 id="Docker原理">Docker原理</h2>
<h3 id="helloworld的运行流程：">helloworld的运行流程：</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210428121216893.png" alt="image-20210428121216893"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210428121520142.png" alt="image-20210428121520142"></p>
<h3 id="底层原理：">底层原理：</h3>
<p>Docker工作原理：Docker是一个 <code>CS结构</code> 的系统，Docker 的守护进程运行在主机上，通过 Socket从客户端访问。</p>
<p>DockerServer 接收到 DokcerClient 的指令，就会执行这个命令。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210428122527218.png" alt="image-20210428122527218"></p>
<h3 id="Docker为什么比VM快？">Docker为什么比VM快？</h3>
<ol>
<li>Docker 有着比虚拟机更少的抽象层</li>
<li>Docker 利用的是宿主机的内核，而 VM 需要的是 <code>Guest OS</code>。</li>
<li>新建一个容器时，Docker 不需要像虚拟机一样重新加载一个操作系统的内核。</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210428122751694.png" alt="image-20210428122751694"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210428123110597.png" alt="image-20210428123110597"></p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署练习</title>
    <url>/2021/05/04/docker/Docker03%E9%83%A8%E7%BD%B2%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="部署Nginx">部署Nginx</h2>
<ol>
<li>搜索镜像，建议去 docker hub 搜索，可以看到帮助文档</li>
<li>下载镜像</li>
<li>运行测试</li>
<li>配置容器内的ngnix的配置文件</li>
</ol>
<p><a class="link" href="https://hub.docker.com/">https://hub.docker.com/<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210504094603067.png" alt="image-20210504094603067"></p>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z ~]# docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
f7ec5a41d630: Pull complete 
aa1efa14b3bf: Pull complete 
b78b95af9b17: Pull complete 
c7d6bca2b8dc: Pull complete 
cf16cd8e71e0: Pull complete 
0241c68333ef: Pull complete 
Digest: sha256:75a55d33ecc73c2a242450a9f1cc858499d468f077ea942867e662c247b5e412
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest
[root@izwz91mv6i3x6k12jjqh60z ~]# docker images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    62d49f9bab67   2 weeks ago    133MB
centos       latest    300e315adb2f   4 months ago   209MB
<span class="hljs-meta">#</span><span class="bash">参考运行容器的命令</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker run -d --name nginx01 -p 3304:80 nginx
dccb2ad300dbbb4598dbb2017805fba5364379326d4a6296dac9b88bc61d8970
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                                   NAMES
dccb2ad300db   nginx     "/docker-entrypoint.…"   21 seconds ago   Up 20 seconds   0.0.0.0:3304-&gt;80/tcp, :::3304-&gt;80/tcp   nginx01

<span class="hljs-meta">#</span><span class="bash">测试是否运行成功，发送一个请求</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# curl localhost:3304
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>开放对应端口后，公网访问看到效果如下图：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210504102706906.png" alt="image-20210504102706906"></p>
<p>查看容器内的ngnix的配置文件：</p>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z ~]# docker exec -it nginx01 /bin/bash
root@dccb2ad300db:/# whereis nginx 
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
root@dccb2ad300db:/# cd /etc/nginx
root@dccb2ad300db:/etc/nginx# ls
conf.d	fastcgi_params	koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params	uwsgi_params  win-utf</code></pre>
<p>端口暴露原理示意图：</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210504100014282.png" alt="image-20210504100014282" style="zoom: 67%;">
<p>问题：每次改动 <code>nginx</code> 配置文件，都需要进入容器内部？十分的麻烦，要是可以在容器外部提供一个映射路径，达到在外部文件修改的同时，同步修改内部就好了！</p>
<p>解决技术：<code>数据卷技术！！</code></p>
<h2 id="部署Tomcat">部署Tomcat</h2>
<ol>
<li>搜索和下载 tomcat</li>
<li>启动运行</li>
<li>测试效果</li>
</ol>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">运行时提示错误</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker run -d -p 8080:8080 --name tomcat02 tomcat
9cdceb4daa857dbd5c4e03dfd7eeded50ae027d8484137889d605871520dee97
docker: Error response from daemon: driver failed programming external connectivity on endpoint tomcat02 (56f474809e2ca18c3e9ce63318aa6918600e004621743625e4be5754f74b6493):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 8080 -j DNAT --to-destination 172.18.0.2:8080 ! -i docker0: iptables: No chain/target/match by that name.
 (exit status 1)).

<span class="hljs-meta">#</span><span class="bash">重启后再次运行</span>
[root@izwz91mv6i3x6k12jjqh60z ~]#  systemctl restart docker

<span class="hljs-meta">#</span><span class="bash">提示容器名已经有的</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker run -d -p 8080:8080 --name tomcat02 tomcat
docker: Error response from daemon: Conflict. The container name "/tomcat02" is already in use by container "9cdceb4daa857dbd5c4e03dfd7eeded50ae027d8484137889d605871520dee97". You have to remove (or rename) that container to be able to reuse that name.
See 'docker run --help'.

<span class="hljs-meta">#</span><span class="bash">没有正在运行的容器</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

<span class="hljs-meta">#</span><span class="bash">查看历史记录</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps -a
CONTAINER ID   IMAGE          COMMAND                  CREATED             STATUS                        PORTS     NAMES
9cdceb4daa85   tomcat         "catalina.sh run"        5 minutes ago       Created                                 tomcat02

<span class="hljs-meta">#</span><span class="bash">开启容器</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker start 9cdceb4daa85
9cdceb4daa85

<span class="hljs-meta">#</span><span class="bash">运行成功</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND             CREATED         STATUS         PORTS                                       NAMES
9cdceb4daa85   tomcat    "catalina.sh run"   5 minutes ago   Up 4 seconds   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat02
</code></pre>
<p>查看效果：测试访问没有问题</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210504105656898.png" alt="image-20210504105656898"></p>
<p>发现问题：</p>
<ol>
<li>容器内部的 <code>Linux</code> 命令变少了（镜像只保证了最小的可运行环境）</li>
<li>webapps中没有内容（需要把 <code>webapps.dist</code> 文件夹的内容复制到 <code>webapps</code>）</li>
</ol>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看镜像</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker images
REPOSITORY            TAG       IMAGE ID       CREATED        SIZE
tomcat                latest    c0e850d7b9bb   3 weeks ago    667MB
nginx                 latest    62d49f9bab67   4 weeks ago    133MB
portainer/portainer   latest    580c0e4e98b0   8 weeks ago    79.1MB
centos                latest    300e315adb2f   5 months ago   209MB

<span class="hljs-meta">#</span><span class="bash">运行 tomcat</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker run -d -p 8080:8080 --name tomcat02 tomcat
39f11d68d64d3c585dd3a7f0a4e2123e03703cead8361c1cf0b6a61c1a7fb474
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND             CREATED          STATUS          PORTS                                       NAMES
39f11d68d64d   tomcat    "catalina.sh run"   16 seconds ago   Up 15 seconds   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat02

<span class="hljs-meta">#</span><span class="bash">进入容器内部</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker exec -it tomcat02 /bin/bash

<span class="hljs-meta">#</span><span class="bash">发现一些命令不存在</span>
root@39f11d68d64d:/usr/local/tomcat# ll
bash: ll: command not found

root@39f11d68d64d:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work

<span class="hljs-meta">#</span><span class="bash">webapps文件夹没有内容</span>
root@39f11d68d64d:/usr/local/tomcat# cd webapps
root@39f11d68d64d:/usr/local/tomcat/webapps# ls
root@39f11d68d64d:/usr/local/tomcat/webapps# cd ../

<span class="hljs-meta">#</span><span class="bash">webapps.dist文件夹有内容</span>
root@39f11d68d64d:/usr/local/tomcat# cd webapps.dist
root@39f11d68d64d:/usr/local/tomcat/webapps.dist# ls
ROOT  docs  examples  host-manager  manager
root@39f11d68d64d:/usr/local/tomcat/webapps.dist# cd ../

<span class="hljs-meta">#</span><span class="bash">把webapps.dist文件夹的内容复制到 webapps</span>
root@39f11d68d64d:/usr/local/tomcat# cp -r webapps.dist/* webapps

<span class="hljs-meta">#</span><span class="bash">快捷键 ctrl+P+Q 退出容器但不停止容器运行</span>
root@39f11d68d64d:/usr/local/tomcat# read escape sequence

<span class="hljs-meta">#</span><span class="bash">确认容器状态</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND             CREATED         STATUS         PORTS                                       NAMES
39f11d68d64d   tomcat    "catalina.sh run"   4 minutes ago   Up 4 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat02
</code></pre>
<p>查看效果：（注意一定要在服务器的安全组中开放对应的端口！！！）</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210504112530764.png" alt="image-20210504112530764"></p>
<h2 id="部署Mysql">部署Mysql</h2>
<p>注意：<a class="link" href="https://hub.docker.com/_/mysql">官网 <i class="fas fa-external-link-alt"></i></a> 中解释 Mysql 是要配置数据库密码的！！</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/6487268471927.jpg" alt="6487268471927"></p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">下载镜像 Mysql5.7</span>
[root@izwz91mv6i3x6k12jjqh60z ceshi]# docker pull mysql:5.7
5.7: Pulling from library/mysql
69692152171a: Pull complete 
1651b0be3df3: Pull complete 
951da7386bc8: Pull complete 
0f86c95aa242: Pull complete 
37ba2d8bd4fe: Pull complete 
6d278bb05e94: Pull complete 
497efbd93a3e: Pull complete 
a023ae82eef5: Pull complete 
e76c35f20ee7: Pull complete 
e887524d2ef9: Pull complete 
ccb65627e1c3: Pull complete 
Digest: sha256:a682e3c78fc5bd941e9db080b4796c75f69a28a8cad65677c23f7a9f18ba21fa
Status: Downloaded newer image for mysql:5.7
docker.io/library/mysql:5.7

<span class="hljs-meta">#</span><span class="bash">启动镜像并挂载目录配置数据库的初始密码</span>
[root@izwz91mv6i3x6k12jjqh60z ceshi]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql01 mysql:5.7
d869c76c987c305b9dd91321f523db7708a2a1c220712b4beaf2ac7f0e68fa1e</code></pre>
<p>使用数据库连接工具连接，查看连接是否成功：</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/Snipaste_2021-05-14_12-49-42.jpg" alt="Snipaste_2021-05-14_12-49-42" style="zoom: 50%;">
<p>发现连接成功：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/Snipaste_2021-05-14_12-49-58.jpg" alt="Snipaste_2021-05-14_12-49-58"></p>
<p>新建数据库并查看主机的文件是否对应改变：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/Snipaste_2021-05-14_12-56-29.jpg" alt="Snipaste_2021-05-14_12-56-29"></p>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z home]# ls
admin  ceshi  mysql  test.java
[root@izwz91mv6i3x6k12jjqh60z home]# cd mysql/data
[root@izwz91mv6i3x6k12jjqh60z data]# ls
auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys
ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem   test</code></pre>
<p>测试删除 mysql 容器后，主机上的文件是否依然存在：</p>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z data]# docker ps
CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                                                  NAMES
d869c76c987c   mysql:5.7   "docker-entrypoint.s…"   26 minutes ago   Up 26 minutes   33060/tcp, 0.0.0.0:3310-&gt;3306/tcp, :::3310-&gt;3306/tcp   mysql01
1309cabd368d   centos      "/bin/bash"              38 minutes ago   Up 38 minutes                                                          epic_neumann
39f11d68d64d   tomcat      "catalina.sh run"        2 hours ago      Up 2 hours      0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp              tomcat02

[root@izwz91mv6i3x6k12jjqh60z data]# docker rm -f d869c76c987c
d869c76c987c

[root@izwz91mv6i3x6k12jjqh60z data]# ls
auto.cnf    ca.pem           client-key.pem  ibdata1      ib_logfile1  mysql               private_key.pem  server-cert.pem  sys
ca-key.pem  client-cert.pem  ib_buffer_pool  ib_logfile0  ibtmp1       performance_schema  public_key.pem   server-key.pem   test
</code></pre>
<p>发现我们挂载到本地的数据卷依旧没有丢失，这就实现了 容器数据持久化的功能！！</p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker可视化工具</title>
    <url>/2021/05/14/docker/Docker04%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1>可视化工具</h1>
<h2 id="Portainer">Portainer</h2>
<p>Docker 图形化界面管理工具，提供一个后台面板供我们操作！</p>
<pre><code class="hljs powershell">docker run <span class="hljs-literal">-d</span> <span class="hljs-literal">-p</span> <span class="hljs-number">8080</span>:<span class="hljs-number">9000</span> \
-<span class="hljs-literal">-restart</span>=always <span class="hljs-literal">-v</span> /var/run/docker.sock:/var/run/docker.sock -<span class="hljs-literal">-privileged</span>=true portainer/portainer</code></pre>
<p>访问测试：<a class="link" href="http://ip:8080/">http://ip:8080/<i class="fas fa-external-link-alt"></i></a> (可视化面板一般不使用，测试时使用)（注意一定要先在阿里云安全组防火墙配置中开放端口）：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210512111853677.png" alt="image-20210512111853677"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210512111931325.png" alt="image-20210512111931325"></p>
<p>创建用户后可以看到：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210512112815070.png" alt="image-20210512112815070"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210512112854757.png" alt="image-20210512112854757"></p>
<h2 id="Rancher（CI-CD再用）">Rancher（CI/CD再用）</h2>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker镜像</title>
    <url>/2021/05/14/docker/Docker05%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1>Docker 镜像</h1>
<h2 id="镜像是什么？">镜像是什么？</h2>
<p>镜像是一种轻量级，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码，运行时库，环境变量和配置文件。</p>
<h3 id="如何获得镜像">如何获得镜像</h3>
<ul>
<li>从远程仓库下载</li>
<li>朋友拷贝给你</li>
<li>自己制作一个镜像 <code>Dockerfile</code></li>
</ul>
<h3 id="UnionFS（联合文件系统）">UnionFS（联合文件系统）</h3>
<p><code>Docker</code>的镜像实际上由一层一层的文件系统组成，这种层级的文件系统<code>UnionFS</code>。</p>
<p>这是一种分层，轻量级且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ <code>Unite several directories into a single virtual filesystem</code> ）。<code>Union文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。</code></p>
<h3 id="Docker镜像加载原理">Docker镜像加载原理</h3>
<p><code>bootfs(boot file system)</code>主要包含<code>bootloader</code>和<code>kernel</code>，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的, 包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210514101219281.png" alt="image-20210514101219281" style="zoom: 50%;">
<p><code>rootfs(root file system)</code> 在bootfs之上。包含的就是典型Linux系统中的<code>/dev, /proc, /bin, /etc等标准目录和文件</code>。<code>rootfs</code>就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210514100545302.png" alt="image-20210514100545302"></p>
<h3 id="镜像分层下载优点">镜像分层下载优点</h3>
<ul>
<li>可以精简镜像文件的大小，对于一个OS，rootfs可以很小，需要包含最基本的命令，工具库和程序库即可，因为底层直接使用 Host 和 kernel，自己只需要提供 rootfs即可，由此对于不同的 Linux 发行版本，bootfs基本是一致的。</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210514101442249.png" alt="image-20210514101442249"></p>
<ul>
<li>资源共享，比如又多个镜像从相同的 base 镜像构建而来，主机只要在磁盘上保存一份 base 镜像，同时内存也只需加载一份 base 镜像即可为所有的容器服务了，而且镜像的每一层都能被共享。</li>
</ul>
<h3 id="Docker-镜像理解">Docker 镜像理解</h3>
<ol>
<li>
<p>所有的镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，都会在当前镜像层上创建新的镜像层。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210514103234209.png" alt=""></p>
</li>
<li>
<p>创建新的镜像层时，镜像始终是当前所有镜像的组合</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210514103159914.png" alt="image-20210514103159914"></p>
</li>
<li>
<p>上层镜像层的文件要覆盖底层镜像层的文件时，会使得文件的更新版本作为一个新的镜像层添加到镜像中。</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210514103823330.png" alt="image-20210514103823330" style="zoom:80%;">
</li>
<li>
<p>所有镜像层堆叠并合并，对外提供统一的视图</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210514104009648.png" alt="image-20210514104009648"></p>
</li>
<li>
<p>Docker 镜像都是只读的，当容器启动时，一个新的可写层会被加载到镜像的顶部。（这一层称为 <code>容器层</code>，容器之下的都叫 <code>镜像层</code>）。</p>
</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210514102529830.png" alt="image-20210514102529830"></p>
<h3 id="commit镜像">commit镜像</h3>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">docker commit -m=<span class="hljs-string">"提交的描述信息"</span> -a=<span class="hljs-string">"作者"</span> 容器ID 目标镜像名:[tag]</span></code></pre>
<p>参考教程：<a href="https://blog.sky123.top/2021/05/04/docker/Docker03%E9%83%A8%E7%BD%B2%E7%BB%83%E4%B9%A0/">Tomcat 部署练习</a></p>
<p>发现：官方的默认 tomcat 的 <code>webapp文件夹</code> 并没有一些文件，需要自己手动拷贝。</p>
<p>解决：将我们操作国的容器 <code>commit</code> 提交成一个新的镜像，我们以后就直接使用我们修改过的镜像即可。</p>
<pre><code class="hljs sh">[root@izwz91mv6i3x6k12jjqh60z ~]<span class="hljs-comment"># docker ps</span>
CONTAINER ID   IMAGE     COMMAND             CREATED          STATUS          PORTS                                       NAMES
39f11d68d64d   tomcat    <span class="hljs-string">"catalina.sh run"</span>   18 minutes ago   Up 18 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat02

[root@izwz91mv6i3x6k12jjqh60z ~]<span class="hljs-comment"># docker commit -m="这个修改了的tomcat" -a="zhang" 39f11d68d64d modified_tomcat:1.1</span>
sha256:57cab5f1479d5c0c6f85ba59415b8c7e9563d9907d32fc5d61a54a74945e57e7

[root@izwz91mv6i3x6k12jjqh60z ~]<span class="hljs-comment"># docker images</span>
REPOSITORY            TAG       IMAGE ID       CREATED         SIZE
modified_tomcat       1.1       57cab5f1479d   7 seconds ago   672MB
tomcat                latest    c0e850d7b9bb   3 weeks ago     667MB
nginx                 latest    62d49f9bab67   4 weeks ago     133MB
portainer/portainer   latest    580c0e4e98b0   8 weeks ago     79.1MB
centos                latest    300e315adb2f   5 months ago    209MB</code></pre>
<blockquote>
<p>总结：如果想保存当前容器的状态，可以通过 commit 来提交，获得一个镜像。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客中插入b站视频</title>
    <url>/2020/05/01/hexo%E5%8D%9A%E5%AE%A2/Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5b%E7%AB%99%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2016/08/09/21/54/lake-1581879_1280.jpg" alt=""></p>
<hr>
<h1>Hexo博客中插入b站视频</h1>
<ol>
<li>在B站网页上获取视频嵌入代码</li>
</ol>
<p>进入网页版的b站视频，点击分享按钮，即可得到用于分享的html代码</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/20210225202303.png" alt=""></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/20210225202425.png" alt=""></p>
<hr>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//player.bilibili.com/player.html?aid=801652859&amp;bvid=BV18y4y1E7jG&amp;cid=296179537&amp;page=1"</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">"no"</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"no"</span> <span class="hljs-attr">framespacing</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">"true"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></code></pre>
<p>关键还是提取里面的<code>src</code>的属性值：<code>//player.bilibili.com/player.html?aid=801652859&amp;bvid=BV18y4y1E7jG&amp;cid=296179537&amp;page=1</code> ，默认的分享代码不太适配我们的博客界面，因此需要将该属性值复制到下面对应的src位置中。</p>
<ol start="2">
<li>在文章中添加视频外链</li>
</ol>
<p>我们知道在 Markdown 中可以直接插入 html 代码，但是为了防止一些其他因素的干扰，Hexo 给我们特意准备了一个 raw 标签来插入 html 代码。这里我们就使用 raw 来插入视频外链。（实际测试中发现raw标签可加可不加，根据自己博客的具体情况判断是否加上）</p>
<p>视频外链代码如下，在需要显示视频的地方粘贴即可</p>
<pre><code class="hljs html">{% raw %}
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"position: relative; width: 100%; height: 0; padding-bottom: 75%;"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"//player.bilibili.com/player.html?aid=801652859&amp;bvid=BV18y4y1E7jG&amp;cid=296179537&amp;page=1"</span> <span class="hljs-attr">scrolling</span>=<span class="hljs-string">"no"</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">"no"</span> <span class="hljs-attr">framespacing</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"position: absolute; width: 100%; height: 100%; left: 0; top: 0;"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
{% endraw %}</code></pre>
<p>实现效果如下:</p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=801652859&amp;bvid=BV18y4y1E7jG&amp;cid=296179537&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;">
    </iframe>
</div>
]]></content>
      <tags>
        <tag>Hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript常用字符串功能方法</title>
    <url>/2020/07/02/javascript/Javascript%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/sunrise-5863751_1280.png" alt=""></p>
<hr>
<h2 id="Javascript常用字符串功能方法">Javascript常用字符串功能方法</h2>
<h3 id="字符串转换">字符串转换</h3>
<p>字符串转换是最基础的要求和工作，你可以将任何类型的数据都转换为字符串，你可以用下面三种方法的任何一种：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> num=<span class="hljs-number">24</span>;
<span class="hljs-keyword">var</span> mystr=num.toString();    <span class="hljs-comment">//"24"</span></code></pre>
<p>你同样可以这么做：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> num=<span class="hljs-number">24</span>;
<span class="hljs-keyword">var</span> mystr=<span class="hljs-built_in">String</span>(num);    <span class="hljs-comment">//"24"</span></code></pre>
<p>或者，在简单点儿：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> num=<span class="hljs-number">24</span>;
<span class="hljs-keyword">var</span> mystr=<span class="hljs-string">""</span> + num;    <span class="hljs-comment">//"24"</span></code></pre>
<h3 id="字符串分割">字符串分割</h3>
<p>将字符串进行拆分返回一个新的数组，JavaScript就给我们提供了一个非常方便的函数：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"qingchenghuwoguoxiansheng,woaishenghuo,woaiziji"</span>;
<span class="hljs-keyword">var</span> arr1=mystr.split(<span class="hljs-string">","</span>);    <span class="hljs-comment">//["qingchenghuwoguoxiansheng","woaishenghuo","woaiziji"];</span>
<span class="hljs-keyword">var</span> arr2=mystr.split(<span class="hljs-string">""</span>);        <span class="hljs-comment">//["q","i","n","g","c","h","e","n","g","h","u","w","o","g","u","o","x","i","a","n","s","h","e","n","g",",","w","o","a","i","s","h","e","n","g","h","u","o",",","w","o","a","i","z","i","j","i"];</span></code></pre>
<p><code>split()</code>的第二个参数，表示返回的字符串数组的最大长度</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"qingchenghuwoguoxiansheng,woaishenghuo,woaiziji"</span>;
<span class="hljs-keyword">var</span> arr1=mystr.split(<span class="hljs-string">","</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//["qingchenghuwoguoxiansheng","woaishenghuo"];</span>
<span class="hljs-keyword">var</span> arr2=mystr.split(<span class="hljs-string">""</span>,<span class="hljs-number">8</span>); <span class="hljs-comment">//["q","i","n","g","c","h","e","n"];</span></code></pre>
<h3 id="字符串替换">字符串替换</h3>
<p>仅仅查找到字符串并不会是题目的停止，一般题目还经常会要求你去进行替换操作，那就继续看以下代码:</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"wozaijinxingzifuchuantihuancaozuo,zifuchuantihuano"</span>;
<span class="hljs-keyword">var</span> replaceStr=mystr.replace(<span class="hljs-string">"zifuchuan"</span>,<span class="hljs-string">" "</span>);    <span class="hljs-comment">//wozaijinxing tihuancaozuo,zifuchuantihuano</span>
<span class="hljs-keyword">var</span> replaceStr=mystr.replace(<span class="hljs-regexp">/zifuchuan/</span>,<span class="hljs-string">" "</span>);    <span class="hljs-comment">//wozaijinxing tihuancaozuo,zifuchuantihuano</span>
<span class="hljs-keyword">var</span> replaceStr=mystr.replace(<span class="hljs-regexp">/zifuchuan/g</span>,<span class="hljs-string">" "</span>);    <span class="hljs-comment">//wozaijinxing tihuancaozuo, tihuano</span></code></pre>
<p>默认只进行第一次匹配操作的替换，想要全局替换，需要置上正则全局标识g</p>
<h3 id="获取字符串长度">获取字符串长度</h3>
<p>获取字符串的长度经常会用到，方法很简单：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"qingchenghuwoguoxiansheng,woaishenghuo,woaiziji"</span>;
<span class="hljs-keyword">var</span> arrLength=mystr.length;    <span class="hljs-comment">//47</span></code></pre>
<h3 id="查询子字符串">查询子字符串</h3>
<p>判断字符串内是否包含子串，不少开发者会使用for循环来判断，而忘记了JavaScript提供子串函数：</p>
<ul>
<li><code>indexOf()</code>，该Of() 方法对大小写敏感。返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"Hello world!"</span>;
<span class="hljs-keyword">var</span> index=mystr.indexOf(<span class="hljs-string">"llo"</span>);    <span class="hljs-comment">//2</span>
<span class="hljs-keyword">var</span> index1=mystr.indexOf(<span class="hljs-string">"l"</span>);    <span class="hljs-comment">//2</span>
<span class="hljs-keyword">var</span> index2=mystr.indexOf(<span class="hljs-string">"l"</span>,<span class="hljs-number">3</span>);    <span class="hljs-comment">//3</span></code></pre>
<ul>
<li><code>lastIndexOf()</code>，该方法对大小写敏感。返回字符串中一个子串最后一处出现的索引（从右到左搜索），如果没有匹配项，返回 -1 。</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"Hello world!"</span>;
<span class="hljs-keyword">var</span> index=mystr.lastIndexOf(<span class="hljs-string">"llo"</span>);    <span class="hljs-comment">//2</span>
<span class="hljs-keyword">var</span> index1=mystr.lastIndexOf(<span class="hljs-string">"l"</span>);    <span class="hljs-comment">//9</span>
<span class="hljs-keyword">var</span> index2=mystr.lastIndexOf(<span class="hljs-string">"l"</span>,<span class="hljs-number">4</span>);    <span class="hljs-comment">//3</span></code></pre>
<h3 id="返回指定位置的字符或其字符编码值">返回指定位置的字符或其字符编码值</h3>
<p>查找给定位置的字符，可以使用如下函数：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"Hello World!"</span>;
<span class="hljs-keyword">var</span> index=mystr.charAt(<span class="hljs-number">7</span>);    <span class="hljs-comment">//o</span></code></pre>
<p>同样，它的一个兄弟函数就是查找对应位置的字符编码值，如：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"Hello World!"</span>;
<span class="hljs-keyword">var</span> charCode=mystr. charCodeAt(<span class="hljs-number">7</span>);    <span class="hljs-comment">//111</span></code></pre>
<h3 id="字符串匹配">字符串匹配</h3>
<p>可以直接通过字符串进行匹配，也可以通过正则进行匹配，可能需要你对正则表达式有一定的了解，先来看看match()函数：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"hi,mynameisguoxiansheng6,33iswho?"</span>;
<span class="hljs-keyword">var</span> matchStr=mystr.match(<span class="hljs-string">"guo"</span>);    <span class="hljs-comment">//guo</span>
<span class="hljs-keyword">var</span> matchStr1=mystr.match(<span class="hljs-string">"Guo"</span>);    <span class="hljs-comment">//nullvar regexp1=/\d+/g;</span>
<span class="hljs-keyword">var</span> regexp2=<span class="hljs-regexp">/guo/g</span>;
<span class="hljs-keyword">var</span> regexp3=<span class="hljs-regexp">/guo/</span>;
<span class="hljs-keyword">var</span> matchStr2=mystr.match(regexp1);    <span class="hljs-comment">//["6","33"]</span>
<span class="hljs-keyword">var</span> matchStr3=mystr.match(regexp2);    <span class="hljs-comment">//["guo"]</span>
<span class="hljs-keyword">var</span> matchStr3=mystr.match(regexp3);    <span class="hljs-comment">//["guo",index:11,input:"hi,mynameisguoxiansheng6,33iswho?"]</span>
matchStr3.index    <span class="hljs-comment">//11</span>
matchStr3.input    <span class="hljs-comment">//hi,mynameisguoxiansheng6,33iswho?</span></code></pre>
<p>注意：1.此处使用字符串直接进行匹配，被匹配的字符串内包含要匹配的字符串时，返回所要匹配的字符串。</p>
<p>2.如果使用正则匹配字符串时，如果正则表达式没有 g (全局标识)标志，返回与正则匹配相同的结果。而且返回的数组拥有一个额外的  input 属性，该属性包含原始字符串。另外，还拥有一个 <code>index</code> 属性，该属性表示匹配结果在被字符串中的索引（以0开始）。如果正则表达式包含 g 标志，则该方法返回匹配字符串的数组。</p>
<p>再来看看使用<code>exec()</code>函数：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"hi,mynameisguoxiansheng6,33iswho?"</span>;
<span class="hljs-keyword">var</span> regexp1=<span class="hljs-regexp">/guo/g</span>;
<span class="hljs-keyword">var</span> matchStr=regexp1.exec(mystr);  <span class="hljs-comment">//["guo"]var regexp2=/guo/;</span>
<span class="hljs-keyword">var</span> matchStr1=regexp2.exec(mystr);    <span class="hljs-comment">//["guo",index:11,input:"hi,mynameisguoxiansheng6,33iswho?"]</span>
matchStr1.index    <span class="hljs-comment">//11</span>
matchStr1.input    <span class="hljs-comment">//hi,mynameisguoxiansheng6,33iswho?</span></code></pre>
<p>简单吧，仅仅是把正则和字符串换了个位置，即<code>exec()</code>函数是在正则上调用，传递字符串的参数。对于上面两个方法，匹配的结果都是返回第一个匹配成功的字符串，如果匹配失败则返回<code>null</code>。</p>
<p>再来看一个类似的函数<code>search()</code>：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr = <span class="hljs-string">"hi,mynameisguoxiansheng6,33iswho?"</span>;
<span class="hljs-keyword">var</span> regexp1 = <span class="hljs-regexp">/guo/</span>;
<span class="hljs-keyword">var</span> matchStr = mystr.search(regexp1);    <span class="hljs-comment">//11</span></code></pre>
<p>进行正则匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1</p>
<h3 id="字符串连接">字符串连接</h3>
<p>可以将两个或多个字符串进行加法操作，同时可以使用<code>JavaScript</code>提供的<code>concat函数</code>：</p>
<p>先看加法操作进行字符串连接：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr1=<span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">var</span> mystr2=<span class="hljs-string">"world!"</span>;
<span class="hljs-keyword">var</span> newStr=mystr1+<span class="hljs-string">" "</span>+mystr2;    <span class="hljs-comment">//Hello world!</span></code></pre>
<p>是不是很简单呀，那继续看看<code>concat函数</code>吧：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr1=<span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">var</span> mystr2=<span class="hljs-string">" world,"</span>;
<span class="hljs-keyword">var</span> mystr3=<span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">var</span> mystr4=<span class="hljs-string">"guoxiansheng"</span>;
<span class="hljs-keyword">var</span> newStr=mystr1.concat(mystr2+mystr3+<span class="hljs-string">" "</span>+mystr4);    <span class="hljs-comment">//Hello world,Hello guoxiansheng</span></code></pre>
<p><code>concat()函数</code>可以有多个参数，传递多个字符串，拼接多个字符串。</p>
<h3 id="字符串切割和提取">字符串切割和提取</h3>
<p>有三种可以从字符串中抽取和切割的方法：</p>
<p>第一种，<code>slice()函数</code>：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"hello world!"</span>;
<span class="hljs-keyword">var</span> sliceStr1=mystr.slice(-<span class="hljs-number">3</span>);    <span class="hljs-comment">//ld!</span>
<span class="hljs-keyword">var</span> sliceStr2=mystr.slice(-<span class="hljs-number">3</span>,-<span class="hljs-number">1</span>);    <span class="hljs-comment">//ld</span>
<span class="hljs-keyword">var</span> sliceStr3=mystr.slice(<span class="hljs-number">3</span>);    <span class="hljs-comment">//lo world!</span>
<span class="hljs-keyword">var</span> sliceStr4=mystr.slice(<span class="hljs-number">3</span>,<span class="hljs-number">7</span>);    <span class="hljs-comment">//lo w</span></code></pre>
<p>第二种：<code>substring()函数</code>：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"hello world!"</span>;
<span class="hljs-keyword">var</span> sliceStr1=mystr.substring(<span class="hljs-number">3</span>);    <span class="hljs-comment">//lo world!</span>
<span class="hljs-keyword">var</span> sliceStr2=mystr.substring(<span class="hljs-number">3</span>,<span class="hljs-number">7</span>);    <span class="hljs-comment">//lo w</span></code></pre>
<p>第三种：<code>substr()函数</code>：</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"hello world!"</span>;
<span class="hljs-keyword">var</span> sliceStr1=mystr.substr(<span class="hljs-number">3</span>);    <span class="hljs-comment">//lo world!</span>
<span class="hljs-keyword">var</span> sliceStr2=mystr.substr(<span class="hljs-number">3</span>,<span class="hljs-number">7</span>);    <span class="hljs-comment">//lo wo</span></code></pre>
<p>注：1.<code>slice()</code> 可以为负数，如果起始位置为负数，则从字符串最后一位向前找对应位数并且向后取结束位置，如果为正整数则从前往后取起始位置到结束位置。<br>
　　2.<code>substring()</code>只能非负整数，截取起始结束位置同slice()函数一致。</p>
<p>3.<code>substr()</code>与第一、第二种函数不同，从起始位置开始截取，结束位置为第二个参数截取的字符串最大长度。</p>
<p>以上三种函数未填第二参数时，自动截取起始位置到字符串末尾。</p>
<h3 id="字符串大小写转换">字符串大小写转换</h3>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"Hello World!"</span>;
<span class="hljs-keyword">var</span> lowCaseStr=mystr.toLowerCase();    <span class="hljs-comment">//hello world!</span>
<span class="hljs-keyword">var</span> upCaseStr=mystr. toUpperCase();    <span class="hljs-comment">//HELLO WORLD!</span></code></pre>
<h3 id="字符串去空格">字符串去空格</h3>
<p><code>trim方法</code>用来删除字符串前后的空格</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> mystr=<span class="hljs-string">"     hello world      "</span>;  
<span class="hljs-keyword">var</span> trimStr=mystr.trim();    <span class="hljs-comment">//hello world</span></code></pre>
<h3 id="字符串去重">字符串去重</h3>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str=<span class="hljs-string">"aahhgggsssjjj"</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeRepeat</span>(<span class="hljs-params">msg</span>)</span>{  
    <span class="hljs-keyword">var</span> res=[];  
    <span class="hljs-keyword">var</span> arr=msg.split(<span class="hljs-string">""</span>);  
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++){  
        <span class="hljs-keyword">if</span>(res.indexOf(arr[i])==-<span class="hljs-number">1</span>){  
            res.push(arr[i]);  
        }  
    }  
    <span class="hljs-keyword">return</span> res.join(<span class="hljs-string">""</span>);  
}  
removeRepeat(str);    <span class="hljs-comment">//ahgsj </span></code></pre>
<h3 id="判断字符串中字符出现的次数">判断字符串中字符出现的次数</h3>
<pre><code class="hljs js"><span class="hljs-comment">/*  </span>
<span class="hljs-comment">    1.先实现字符串去重  </span>
<span class="hljs-comment">    2.然后对去重后的数组用for循环操作，分别与原始数组中各个值进行比较，如果相等则count++,循环结束将count保存在sum数组中，然后将count重置为0  </span>
<span class="hljs-comment">    3.这样一来去重后的数组中的元素在原数组中出现的次数与sum数组中的元素是一一对应的  </span>
<span class="hljs-comment">*/</span>  
<span class="hljs-keyword">var</span> str=<span class="hljs-string">"aacccbbeeeddd"</span>;  
<span class="hljs-keyword">var</span> sum=[];  
<span class="hljs-keyword">var</span> res=[];  
<span class="hljs-keyword">var</span> count=<span class="hljs-number">0</span>;  
<span class="hljs-keyword">var</span> arr=str.split(<span class="hljs-string">""</span>);  
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++){  
    <span class="hljs-keyword">if</span>(res.indexOf(arr[i])==-<span class="hljs-number">1</span>){  
        res.push(arr[i]);  
    }  
}  
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;res.length;i++){  
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;arr.length;j++){  
        <span class="hljs-keyword">if</span>(arr[j]==res[i]){  
            count++;  
        }  
    }  
    sum.push(count);  
    count=<span class="hljs-number">0</span>;  
}  
<span class="hljs-built_in">console</span>.log(res);    <span class="hljs-comment">//["a", "c", "b", "e", "d"]  </span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;res.length;i++){  
    <span class="hljs-keyword">var</span> str=(sum[i]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)?<span class="hljs-string">"偶数"</span>:<span class="hljs-string">"奇数"</span>;  
    <span class="hljs-built_in">console</span>.log(res[i]+<span class="hljs-string">"出现了"</span>+sum[i]+<span class="hljs-string">"次"</span>);  
    <span class="hljs-built_in">console</span>.log(res[i]+<span class="hljs-string">"出现了"</span>+str+<span class="hljs-string">"次"</span>);  
}</code></pre>]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Mock和Mock.js</title>
    <url>/2021/04/22/javascript/mock/</url>
    <content><![CDATA[<h2 id="关于mock">关于mock</h2>
<p><code>mock可以简单理解为假数据</code>。在软件开发中，我们不可避免的要调用一些外部或者系统级别的接口，然而，我们在测试时，也许这些接口或环境并不存在。比如在对我们自己的模块做单元测试时，发现自己的模块依赖的别的模块或接口还没有建立好，如何测试？<code>（后端的接口还没写好，前端该怎么测试接口？前端写假数据接口，暂时替代后端）</code></p>
<p>Mock概念应运而生，最开始在Java领域，后来各种语言或开发领域均引入该概念。</p>
<p>Mock实际上就是一种模拟和控制外部或者系统级别对象或接口的方法。因此，我们在做测试时，尤其是单元测试或覆盖测试时，不必与真实环境交互即可完成对自己的模块业务逻辑的测试，或许自己的模块需要依赖外部环境。</p>
<p><code>(这里看看即可，主要理解一下这种 mock 思想的出现解决了什么问题？)</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330144250709.png" alt="image-20210330144250709"></p>
<h2 id="Mock-js">Mock.js</h2>
<p>上面所说的 mock 是一种思想，而现在说的<code>Mock.js</code>是一门技术，是这种思想的具体实现。我们主要学的是<code>Mock.js</code>。其实此外还有许多技术可以替代它。比如 <code>easyMock，apifox..</code></p>
<p>官网：<a class="link" href="http://mockjs.com/">http://mockjs.com/<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330145423844.png" alt="image-20210330145423844"></p>
<p>优点：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330145453711.png" alt="image-20210330145453711"></p>
<h2 id="这个东西怎么用到项目中去？">这个东西怎么用到项目中去？</h2>
<h3 id="安装">安装</h3>
<p>进入项目根目录</p>
<pre><code class="hljs markdown"><span class="hljs-section"># 安装</span>
npm install mockjs</code></pre>
<p>出现如下，说明安装成功</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330151134751.png" alt="image-20210330151134751"></p>
<h3 id="配置使用">配置使用</h3>
<p>新建如下目录结构：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330155310609.png" alt="image-20210330155310609"></p>
<p>解释：<code>decision目录</code>中的文件命名尽量和<code>api文件夹</code>里的文件对应</p>
<p>在  <code>mock/index.js</code> 中写入：</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> Mock <span class="hljs-keyword">from</span> <span class="hljs-string">"mockjs"</span>;
<span class="hljs-keyword">import</span> file <span class="hljs-keyword">from</span> <span class="hljs-string">"./decision/file"</span>;

<span class="hljs-comment">//拦截 `/api/testGet` 接口的`get方式`的请求，如果拦截到就调用 `file.testGet` 中的函数。</span>
Mock.mock(<span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"/api/testGet"</span> + <span class="hljs-string">".*"</span>), <span class="hljs-string">"get"</span>, file.testGet);

<span class="hljs-comment">//拦截 `/api/testGet` 接口的`post方式`的请求，如果拦截到就返回 `file.testPost` 中的对象。</span>
Mock.mock(<span class="hljs-string">"/api/testPost"</span>, <span class="hljs-string">"post"</span>, file.testPost);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Mock;
</code></pre>
<p>在 <code>mock/decision/file.js</code> 中写入：</p>
<pre><code class="hljs js"><span class="hljs-comment">// 管理mock数据</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-function"><span class="hljs-title">testGet</span>(<span class="hljs-params">options</span>)</span> {
    <span class="hljs-built_in">console</span>.log(options);
    <span class="hljs-keyword">return</span> {
      code: <span class="hljs-number">1</span>,
      msg: <span class="hljs-string">"GET成功"</span>,
      data: {
        token: <span class="hljs-string">"123456"</span>,
        collegeId: <span class="hljs-string">"123"</span>
      }
    };
    <span class="hljs-comment">// 登录接口返回的数据</span>
  },
  testPost: {
    code: <span class="hljs-number">1</span>,
    msg: <span class="hljs-string">"POST成功"</span>,
    data: {
      token: <span class="hljs-string">"123456"</span>,
      collegeId: <span class="hljs-string">"123"</span>
    }
  }
};</code></pre>
<p>在项目的 <code>main.js</code> 中引入<code>mockjs</code></p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">"./mock/index.js"</span>; <span class="hljs-comment">// 使用mockjs模拟</span></code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330155820989.png" alt="image-20210330155820989"></p>
<h3 id="测试效果">测试效果</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="upload%5Cimage-20210330155908404.png" alt="image-20210330155908404"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="upload%5Cimage-20210330155919853.png" alt="image-20210330155919853"></p>
<h2 id="Mock-js-配置的一些注意点">Mock.js 配置的一些注意点</h2>
<ol>
<li>
<p>模拟 <code>get</code> 请求的 <code>url</code> 注意一定要正则表达式的风格：例如</p>
<pre><code class="hljs js">Mock.mock(<span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"/api/testGet"</span> + <span class="hljs-string">".*"</span>), <span class="hljs-string">"get"</span>, file.testGet);</code></pre>
<p>这段代码的含义是，拦截 <code>/api/testGet</code> 接口的<code>get方式</code>的请求，如果拦截到就调用 <code>file.testGet</code> 函数。</p>
<p>为什么不直接像拦截post请求那样 <code>url</code>  直接是个字符串形式的？因为 <code>get请求的url后面是带参数的！！！</code></p>
<p>直接使用字符串mock只会拦截 <code>/api/testGet</code>，不会拦截  <code>/api/testGet?XXX=XXX&amp;XXX=XXX</code>这种形式的。</p>
</li>
<li>
<p>从上面的使用可以看出：一个接口就要写一个 <code>Mock.mock(XXXXXXX)</code>。而我们写完这个之后最主要的就是写它返回的假数据。（<code>Mock.mock</code>函数的使用可以看一下官网的解释：<a class="link" href="https://github.com/nuysoft/Mock/wiki/Mock.mock()%EF%BC%89">https://github.com/nuysoft/Mock/wiki/Mock.mock()）<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330161517775.png" alt="image-20210330161517775"></p>
<p>看到官网的解释可以发现，第三个参数（模拟数据）其实有两种方式：<code>function 和 template</code> 。分别对应之前写的<code>testGet和testPost</code> ：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330161829735.png" alt="image-20210330161829735"></p>
<p>这两种方式都很常用。都要会使用！</p>
</li>
</ol>
<h4 id="template类型">template类型</h4>
<p>看官网的解释：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330162015199.png" alt="image-20210330162015199"></p>
<p>这里说明：<code>template</code> 它可以直接就是一个对象或字符串，也就是说你在写它的假数据时可以直接定义一个对象或字符串就行。比如前面写的 <code>testPost</code></p>
<pre><code class="hljs js">testPost: {
    code: <span class="hljs-number">1</span>,
    msg: <span class="hljs-string">"POST成功"</span>,
    data: {
      token: <span class="hljs-string">"123456"</span>,
      collegeId: <span class="hljs-string">"123"</span>
    }
  }</code></pre>
<p>拦截成功后直接就是返回你所写的假数据。而这种方式最好的一点是<code>它可以生成随机数据</code></p>
<p>看到官网的：<a class="link" href="http://mockjs.com/examples.html#String%E3%80%82%E5%8F%91%E7%8E%B0%E8%BF%99%E9%87%8C%E8%AE%B2%E4%BA%86%E5%BE%88%E5%A4%9A%E7%9A%84%E8%AF%AD%E6%B3%95%E3%80%82%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%E5%81%87%E5%A6%82%E6%88%91%E6%83%B3%E6%AF%8F%E6%AC%A1%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%8B%A6%E6%88%AA%E4%B9%8B%E5%90%8E%E8%BF%94%E5%9B%9E%E7%9A%84">http://mockjs.com/examples.html#String。发现这里讲了很多的语法。怎么用？假如我想每次调用接口拦截之后返回的<i class="fas fa-external-link-alt"></i></a> <code>token 和 collegeId</code> 都是不一样的。那么可以这么写：</p>
<p>在官网找到数据类型：这里由于两个都是字符串类型的，我选择使用 正则表达式的类型</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330163542540.png" alt="image-20210330163542540"></p>
<p>修改为：</p>
<pre><code class="hljs js">testPost: {
    code: <span class="hljs-number">1</span>,
    msg: <span class="hljs-string">"POST成功"</span>,
    data: {
      token: <span class="hljs-regexp">/[a-z][A-Z][0-9][0-9][0-9]/</span>,
      collegeId: <span class="hljs-regexp">/[0-9][0-9][0-9][0-9]/</span>
    }
  }</code></pre>
<p>查看效果：发现多次调用返回的都是不同的结果：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330163811844.png" alt="image-20210330163811844"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330163820152.png" alt="image-20210330163820152"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330163834223.png" alt="image-20210330163834223"></p>
<p>总结：使用 template 类型可以生成随机数据，使得每次调用接口时的数据都不同，但是你如果不想用随机数据的话也可以直接写死，每次返回同样的数据，这样甚至都不用去关注官网提到的那些随机数据的生成语法。不过多了解点总是好的。</p>
<h4 id="function类型">function类型</h4>
<p>看官网：<a class="link" href="https://github.com/nuysoft/Mock/wiki/Mock.mock()">https://github.com/nuysoft/Mock/wiki/Mock.mock()<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330164423839.png" alt="image-20210330164423839"></p>
<p>这种方式就最大的好处就是可以<code>前端简单的实现增删改数据的效果</code>。就是说当你调用涉及到增删改数据的接口时，仅仅使用上面的 <code>template</code> 类型是看不到增删改的效果的。此时只能使用 <code>function</code> 类型的。返回这种类型时实际上就是调用了你所定义的函数，然后<code>将函数的返回值作为假数据</code>。比如之前写的 <code>testGet</code>:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">testGet</span>(<span class="hljs-params">options</span>)</span> {
    <span class="hljs-built_in">console</span>.log(options);
    <span class="hljs-keyword">return</span> {
      code: <span class="hljs-number">1</span>,
      msg: <span class="hljs-string">"GET成功"</span>,
      data: {
        token: <span class="hljs-string">"123456"</span>,
        collegeId: <span class="hljs-string">"123"</span>
      }
    };
  },</code></pre>
<p>可以发现这个函数有一个参数，打印之后发现：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330165256662.png" alt="image-20210330165256662"></p>
<p>实际上就是你调用的接口的信息！！拿到这个你其实可以做很多事情，比如下面这个，找到之前发的出卷系统的项目的<code>mock/decision/auditJoin.js/auditJoinGet  这个函数</code>：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210330165702842.png" alt="image-20210330165702842"></p>
<p>在 <code>auditJoin.js</code> 中可以看到首先定义一连串的数据，然后不同的函数根据自己的<code>options</code>找到参数后进行对应的操作返回不同的数据。</p>
<p>总结：function 类型的使用可以实现一些增删改接口数据的效果。但是使用这种方法后要想生成随机数据的话就不能使用之前 <a class="link" href="http://mockjs.com/examples.html#String">http://mockjs.com/examples.html#String<i class="fas fa-external-link-alt"></i></a> 提到的这些语法。而要使用别的方法实现（MockRandom：<a class="link" href="https://github.com/nuysoft/Mock/wiki/Mock.Random%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%96%B9%E6%B3%95%E4%B8%8D%E5%81%9A%E8%A6%81%E6%B1%82%EF%BC%8C%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E4%BA%BA%E5%B0%B1%E7%94%A8%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E4%BA%BA%E5%B0%B1%E5%BD%93%E4%BD%9C%E6%B2%A1%E7%9C%8B%E8%BF%87%EF%BC%89%E3%80%82%E6%80%BB%E4%B9%8B%EF%BC%8C%E7%94%A8">https://github.com/nuysoft/Mock/wiki/Mock.Random，这种方法不做要求，能看懂的人就用一下，看不懂的人就当作没看过）。总之，用<i class="fas fa-external-link-alt"></i></a> <code>function</code> 类型时可以参照：<code>之前发的出卷系统的项目的mock/decision/auditJoin.js</code> 里面的写法。</p>
<h3 id="总结">总结</h3>
<p><code>Mock.js</code> 实际上只是在前端开发时写的一些假接口数据，之后等后端代码写好，前后端整合的时候，就需要把它注释掉了。</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器防火墙端口配置</title>
    <url>/2021/05/04/linux/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%98%B2%E7%81%AB%E5%A2%99%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="查看防火墙状态">查看防火墙状态</h3>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z ~]# systemctl status firewalld
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(1)</code></pre>
<h3 id="开启、关闭防火墙">开启、关闭防火墙</h3>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 开启</span>
systemctl start firewalld

<span class="hljs-meta">#</span><span class="bash"> 关闭</span>
systemctl start firewalld</code></pre>
<h3 id="开放指定端口">开放指定端口</h3>
<pre><code class="hljs shell">firewall-cmd --zone=public --add-port=1935/tcp --permanent
命令含义：
--zone #作用域
--add-port=1935/tcp #添加端口，格式为：端口/通讯协议
--permanent #永久生效，没有此参数重启后失效

[root@izwz91mv6i3x6k12jjqh60z ~]# firewall-cmd --zone=public --add-port=3304/tcp --permanent
success</code></pre>
<h3 id="重启防火墙">重启防火墙</h3>
<pre><code class="hljs shell">firewall-cmd --reload

[root@izwz91mv6i3x6k12jjqh60z ~]# firewall-cmd --reload
success</code></pre>
<h3 id="查看端口号">查看端口号</h3>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">netstat -ntlp //查看当前所有tcp端口·</span>

[root@izwz91mv6i3x6k12jjqh60z ~]# netstat -ntlp 
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:3304            0.0.0.0:*               LISTEN      29109/docker-proxy  
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2185/sshd           
tcp6       0      0 :::3304                 :::*                    LISTEN      29113/docker-proxy  

<span class="hljs-meta">#</span><span class="bash">netstat -ntulp |grep 3304 //查看所有3304端口使用情况</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# netstat -ntulp |grep 3304
tcp        0      0 0.0.0.0:3304            0.0.0.0:*               LISTEN      29109/docker-proxy  
tcp6       0      0 :::3304                 :::*                    LISTEN      29113/docker-proxy  
</code></pre>
<h3 id="开放阿里云安全组">开放阿里云安全组</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210504102358335.png" alt="image-20210504102358335"></p>
<p>设置要开放的对应的端口</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210504102424090.png" alt="image-20210504102424090"></p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门01IOC和AOP概述</title>
    <url>/2020/03/01/spring/Spring%E5%85%A5%E9%97%A801IOC%E5%92%8CAOP%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2014/07/01/12/34/road-381227_1280.jpg" alt=""></p>
<hr>
<h1>Spring入门01IOC和AOP概述</h1>
<h2 id="1-Spring-概述">1. Spring 概述</h2>
<p>Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架。主要有两个模块的内容：</p>
<ol>
<li>IoC（Inverse of Control：反转控制）</li>
<li>AOP（Aspect Oriented Programming：面向切面编程）</li>
</ol>
<h2 id="2-Spring-体系">2. Spring 体系</h2>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/spring/image-20200530123158917.png" alt="image-20200530123158917" style="zoom:50%;">
<hr>
<h2 id="3-IoC-的概念和作用">3. IoC 的概念和作用</h2>
<h3 id="3-1-耦合性-Coupling-，也叫耦合度，是对模块间关联程度的度量。">3.1 耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。</h3>
<ol>
<li>
<p>耦合的强弱取决于模块间<code>接口的复杂性、调用模块的方式以及通过界面传送数据的多少</code>。</p>
</li>
<li>
<p>模块间的耦合度是指模块之间的依赖关系，包括<code>控制关系、调用关系、数据传递关系</code>。模块间联系越多，其耦合性越强，<code>同时表明其独立性越差( 降低耦合性，可以提高其独立性)</code>。 耦合性存在于各个领域，而非软件设计中独有的，但是我们只讨论软件工程中的耦合。</p>
</li>
<li>
<p>在软件工程中， 耦合指的就是就是对象之间的依赖性。<code>对象之间的耦合越高，维护成本越高</code>。因此对象的设计<br>
应使类和构件之间的耦合最小。 软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。 划分模块的一个<br>
准则就是高内聚低耦合。它有如下分类：</p>
<ol>
<li>
<p><code>内容耦合。</code>当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另<br>
一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。</p>
</li>
<li>
<p><code>公共耦合。</code>两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大<br>
量公共耦合的结构中，<code>确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的</code>。</p>
</li>
<li>
<p><code>外部耦合 。</code>一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传<br>
递该全局变量的信息，则称之为外部耦合。</p>
</li>
<li>
<p><code>控制耦合 。</code>一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进<br>
行适当的动作，这种耦合被称为控制耦合。</p>
</li>
<li>
<p><code>标记耦合。</code>若一个模块 A 通过接口向两个模块 B 和 C 传递一个公共参数，那么称模块 B 和 C 之间<br>
存在一个标记耦合。</p>
</li>
<li>
<p><code>数据耦合。</code>模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形<br>
式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。</p>
</li>
<li>
<p><code>非直接耦合 。</code>两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</p>
</li>
</ol>
</li>
</ol>
<p>总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。</p>
<blockquote>
<p>内聚与耦合</p>
</blockquote>
<blockquote>
<ol>
<li>内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>在进行软件设计时，应力争做到高内聚，低耦合。</li>
</ol>
</blockquote>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 账户的业务层实现类</span>
<span class="hljs-comment">* <span class="hljs-doctag">@author</span> </span>
<span class="hljs-comment">* <span class="hljs-doctag">@Company</span></span>
<span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>{
<span class="hljs-keyword">private</span> IAccountDao accountDao = <span class="hljs-keyword">new</span> AccountDaoImpl();
}

<span class="hljs-comment">//业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。 这种编译期依赖关系，应该在我们开发中杜绝。 我们需要优化代码解决  </span></code></pre>
<pre><code class="hljs java"><span class="hljs-comment">//当是我们讲解 jdbc 时，是通过反射来注册驱动的，代码如下：</span>
    
Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);<span class="hljs-comment">//此处只是一个字符串</span>

<span class="hljs-comment">//此时的好处是，我们的类中不再依赖具体的驱动类，此时就算删除 mysql 的驱动 jar 包，依然可以编译（运行就不要想了，没有驱动不可能运行成功的） 。</span>
<span class="hljs-comment">//同时，也产生了一个新的问题， mysql 驱动的全限定类名字符串是在 java 类中写死的，一旦要改还是要修改源码。</span>
<span class="hljs-comment">//解决这个问题也很简单，使用配置文件配置。</span></code></pre>
<h3 id="3-2-工厂模式解耦">3.2 工厂模式解耦</h3>
<p>在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候， 让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。在接下来的使用的时候，直接拿过来用就好了。<br>
<code>那么，这个读取配置文件， 创建存储和获取三层对象的类就是工厂。</code></p>
<ol>
<li>
<p>存哪去？<br>
分析：由于我们是很多对象，肯定要找个集合来存。这时候有 Map 和 List 供选择。到底选 Map 还是 List 就看我们有没有查找需求。有查找需求，选 Map。<br>
答案：在应用加载时，创建一个 Map，用于存放三层对象。我们把这个 map 称之为容器。</p>
</li>
<li>
<p>工厂？<br>
工厂就是负责给我们从容器中获取指定对象的类。这时候我们获取对象的方式发生了改变。<br>
原来：我们在获取对象时，都是采用 new 的方式。 是主动的  。</p>
<p>现在：我们获取对象时，同时跟工厂要，由工厂为我们查找或者创建对象。 是被动的。</p>
<p><code>这种被动接收的方式获取对象的思想就是控制反转，它是 spring 框架的核心之一。</code></p>
</li>
</ol>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/spring/image-20200530125138969.png" alt="image-20200530125138969" style="zoom:50%;">
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/spring/image-20200530125330575.png" alt="image-20200530125330575"></p>
<hr>
<h3 id="3-3-使用-Spring-的-IoC-解决程序耦合">3.3 使用 Spring 的 IoC 解决程序耦合</h3>
<h4 id="3-3-1-导入依赖">3.3.1 导入依赖</h4>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--        spring核心包--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--        spring整合junit的jar包--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--        用于spring框架检测切入点的Jar包--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--        spring的jdbcTemplate的依赖--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--        spring事务控制依赖包--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<h4 id="3-3-2-在resources创建-bean-xml导入约束">3.3.2 在resources创建 bean.xml导入约束</h4>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
<h4 id="3-3-3-在bean-xml中注入对象">3.3.3 在bean.xml中注入对象</h4>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中</span>
<span class="hljs-comment">id 属性：对象的唯一标识。</span>
<span class="hljs-comment">class 属性：指定要创建对象的全限定类名</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-comment">&lt;!-- 配置 service --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置 dao --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountDao"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.dao.impl.AccountDaoImpl"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
<h4 id="3-3-4-测试获取容器中的对象">3.3.4 测试获取容器中的对象</h4>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    <span class="hljs-comment">//1.使用 ApplicationContext 接口，就是在获取 spring 容器</span>
        ApplicationContext ac = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"bean.xml"</span>);
        
    <span class="hljs-comment">//2.根据 bean 的 id 获取对象</span>
        IAccountService aService = (IAccountService) ac.getBean(<span class="hljs-string">"accountService"</span>);
        System.out.println(aService);
        
        IAccountDao aDao = (IAccountDao) ac.getBean(<span class="hljs-string">"accountDao"</span>);
        System.out.println(aDao);
    }
}</code></pre>
<h2 id="4-AOP的概述和动态代理">4 AOP的概述和动态代理</h2>
<h3 id="4-1-AOP-概述">4.1 AOP 概述</h3>
<p>AOP： 全称是 Aspect Oriented Programming 即： 面向切面编程。  简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。</p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/spring/image-20200530164938131.png" alt="image-20200530164938131"></p>
<hr>
<p>AOP 的作用及优势</p>
<p>作用：在程序运行期间，不修改源码对已有方法进行增强。<br>
优势：减少重复代码，提高开发效率，维护方便</p>
<p>AOP实现方式：动态代理</p>
<h3 id="4-2-动态代理">4.2 动态代理</h3>
<p>字节码随用随创建，随用随加载。它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。<br>
装饰者模式就是静态代理的一种体现。</p>
<p>动态代理常用的有两种方式   ：</p>
<p>基于接口的动态代理  ：</p>
<ul>
<li>提供者： JDK 官方的 Proxy 类。</li>
<li>要求：被代理类最少实现一个接口</li>
</ul>
<p>基于子类的动态代理  ：</p>
<ul>
<li>提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 asm.jar。</li>
<li>要求：被代理类不能用 final 修饰的类（最终类）。</li>
</ul>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门02基于XML方式的IOC</title>
    <url>/2020/03/02/spring/Spring%E5%85%A5%E9%97%A802%E5%9F%BA%E4%BA%8EXML%E6%96%B9%E5%BC%8F%E7%9A%84IOC/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2015/12/01/20/28/road-1072823_1280.jpg" alt=""></p>
<hr>
<h1>Spring入门02基于XML方式的IOC</h1>
<h2 id="1-spring-中工厂的类结构">1. spring 中工厂的类结构</h2>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/spring/image-20200530131900598.png" alt="image-20200530131900598" style="zoom: 67%;">
<h3 id="BeanFactory-和-ApplicationContext-的区别">BeanFactory 和 ApplicationContext 的区别</h3>
<p>BeanFactory 才是 Spring 容器中的顶层接口。ApplicationContext 是它的子接口。<br>
BeanFactory 和 ApplicationContext 的区别：</p>
<p>创建对象的时间点不一样。</p>
<ol>
<li>ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。</li>
<li>BeanFactory：什么使用什么时候创建对象</li>
</ol>
<h3 id="ApplicationContext-接口的实现类">ApplicationContext 接口的实现类</h3>
<ol>
<li>ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件，主要使用这种方式</li>
<li>FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。</li>
<li>AnnotationConfigApplicationContext：当我们使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</li>
</ol>
<h2 id="2-IoC-中-bean-标签和注入对象细节">2 IoC 中 bean 标签和注入对象细节</h2>
<h3 id="2-1-bean的作用">2.1 bean的作用</h3>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">作用：用于配置对象让 spring 来创建的。</span>
<span class="hljs-comment">默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。</span>
<span class="hljs-comment">属性：</span>
<span class="hljs-comment">id： 给对象在容器中提供一个唯一标识。用于获取对象。</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">class： 指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">scope： 指定对象的作用范围。</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">* singleton :默认值，单例的.</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">* prototype :多例的.</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">* request :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 request 域中.</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">* session :WEB 项目中,Spring 创建一个 Bean 的对象,将对象存入到 session 域中.</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">* global session :WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session.</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">init-method： 指定类中的初始化方法名称。</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">destroy-method： 指定类中销毁方法名称。</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">--&gt;</span></code></pre>
<h3 id="2-2-bean-的作用范围和生命周期">2.2 bean 的作用范围和生命周期</h3>
<p><code>单例对象： scope="singleton"</code><br>
一个应用只有一个对象的实例。它的作用范围就是整个引用。</p>
<ul>
<li>对象出生：当应用加载，创建容器时，对象就被创建了。</li>
<li>对象活着：只要容器在，对象一直活着。</li>
<li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</li>
</ul>
<p><code>多例对象： scope="prototype"</code><br>
每次访问对象时，都会重新创建对象实例。</p>
<ul>
<li>对象出生：当使用对象时，创建新的对象实例。</li>
<li>对象活着：只要对象在使用中，就一直活着。</li>
<li>对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了</li>
</ul>
<h3 id="2-3-实例化-Bean-的三种方式">2.3 实例化 Bean 的三种方式</h3>
<p>第一种方式：使用默认无参构造函数</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在默认情况下：</span>
<span class="hljs-comment">它会根据默认无参构造函数来创建类对象。如果 bean 中没有默认无参构造函数，将会创建失败。  --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>/&gt;</span></code></pre>
<p>第二种方式： spring 管理静态工厂-使用静态工厂的方法创建对象</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 模拟一个静态工厂，创建业务层实现类</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticFactory</span> </span>{
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IAccountService <span class="hljs-title">createAccountService</span><span class="hljs-params">()</span></span>{
<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccountServiceImpl();
}
}</code></pre>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 此种方式是:</span>
<span class="hljs-comment">使用 StaticFactory 类中的静态方法 createAccountService 创建对象，并存入 spring 容器</span>
<span class="hljs-comment">id 属性：指定 bean 的 id，用于从容器中获取</span>
<span class="hljs-comment">class 属性：指定静态工厂的全限定类名</span>
<span class="hljs-comment">factory-method 属性：指定生产对象的静态方法</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span></span>
<span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.factory.StaticFactory"</span></span>
<span class="hljs-tag"><span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createAccountService"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
<p>第三种方式： spring 管理实例工厂-使用实例工厂的方法创建对象</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 模拟一个实例工厂，创建业务层实现类</span>
<span class="hljs-comment">* 此工厂创建对象，必须现有工厂实例对象，再调用方法</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceFactory</span> </span>{
<span class="hljs-function"><span class="hljs-keyword">public</span> IAccountService <span class="hljs-title">createAccountService</span><span class="hljs-params">()</span></span>{
<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccountServiceImpl();
}
}</code></pre>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 此种方式是：</span>
<span class="hljs-comment">先把工厂的创建交给 spring 来管理。</span>
<span class="hljs-comment">然后在使用工厂的 bean 来调用里面的方法</span>
<span class="hljs-comment">factory-bean 属性：用于指定实例工厂 bean 的 id。</span>
<span class="hljs-comment">factory-method 属性：用于指定实例工厂中创建对象的方法。</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"instancFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.factory.InstanceFactory"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span></span>
<span class="hljs-tag"><span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"instancFactory"</span></span>
<span class="hljs-tag"><span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createAccountService"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
<h3 id="2-4-Spring-的依赖注入-注入对象中成员量的值">2.4 Spring 的依赖注入  (注入对象中成员量的值)</h3>
<h4 id="2-4-1-依赖注入的概念">2.4.1 依赖注入的概念</h4>
<blockquote>
<p>依赖注入： Dependency Injection。 它是 spring 框架核心 ioc 的具体实现。<br>
我们的程序在编写时， 通过控制反转， 把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。<br>
ioc 解耦只是降低他们的依赖关系，但不会消除。 例如：我们的业务层仍会调用持久层的方法。<br>
那这种业务层和持久层的依赖关系， 在使用 spring 之后， 就让 spring 来维护了。<br>
简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p>
</blockquote>
<h4 id="2-4-2-依赖注入的三种方式">2.4.2 依赖注入的三种方式</h4>
<p>第一种：构造函数注入  ：顾名思义，就是使用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置的方式，让 spring 框架来为我们注入。具体代码如下：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-keyword">private</span> Date birthday;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountServiceImpl</span><span class="hljs-params">(String name, Integer age, Date birthday)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
        <span class="hljs-keyword">this</span>.birthday = birthday;
    }

}</code></pre>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用构造函数的方式，给 service 中的属性传值</span>
<span class="hljs-comment">要求：</span>
<span class="hljs-comment">类中需要提供一个对应参数列表的构造函数。</span>
<span class="hljs-comment">涉及的标签：</span>
<span class="hljs-comment">constructor-arg</span>
<span class="hljs-comment">属性：</span>
<span class="hljs-comment">index:指定参数在构造函数参数列表的索引位置</span>
<span class="hljs-comment">type:指定参数在构造函数中的数据类型</span>
<span class="hljs-comment">name:指定参数在构造函数中的名称 用这个找给谁赋值</span>
<span class="hljs-comment">=======上面三个都是找给谁赋值，下面两个指的是赋什么值的==============</span>
<span class="hljs-comment">value:它能赋的值是基本数据类型和 String 类型</span>
<span class="hljs-comment">ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"张三"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"18"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"now"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"now"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"java.util.Date"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
<p>第二种：set 方法注入  ：就是在类中提供需要注入成员的 set 方法。具体代码如下：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-keyword">private</span> Date birthday;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>{
        <span class="hljs-keyword">this</span>.age = age;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBirthday</span><span class="hljs-params">(Date birthday)</span> </span>{
        <span class="hljs-keyword">this</span>.birthday = birthday;
    }
}</code></pre>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式</span>
<span class="hljs-comment">涉及的标签：</span>
<span class="hljs-comment">property属性：</span>
<span class="hljs-comment">name：找的是类中 set 方法后面的部分</span>
<span class="hljs-comment">ref：给属性赋值是其他 bean 类型的</span>
<span class="hljs-comment">value：给属性赋值是基本数据类型和 string 类型的</span>
<span class="hljs-comment">实际开发中，此种方式用的较多。</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"test"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"21"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"birthday"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"now"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"now"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"java.util.Date"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
<p>第三种：使用 p 名称空间注入数据（本质还是调用 set 方法）此种方式是通过在 xml 中导入 p 名称空间，使用 p:propertyName 来注入数据，它的本质仍然是调用类中的set 方法实现注入功能。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceImpl4</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IAccountService</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-keyword">private</span> Date birthday;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>{
        <span class="hljs-keyword">this</span>.age = age;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBirthday</span><span class="hljs-params">(Date birthday)</span> </span>{
        <span class="hljs-keyword">this</span>.birthday = birthday;
    }
}</code></pre>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">"http://www.springframework.org/schema/p"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">" http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span></span>
<span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl4"</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">"test"</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">"21"</span> <span class="hljs-attr">p:birthdayref</span>=<span class="hljs-string">"now"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
<p>注入集合属性</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"accountService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.service.impl.AccountServiceImpl"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt;</span>
    
<span class="hljs-comment">&lt;!-- 给数组注入数据 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myStrs"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    
<span class="hljs-comment">&lt;!-- 注入 list 集合数据 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myList"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    
<span class="hljs-comment">&lt;!-- 注入 set 集合数据 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mySet"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>CCC<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    
<span class="hljs-comment">&lt;!-- 注入 Map 数据 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myMap"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testA"</span>&gt;</span>aaa<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testB"</span>&gt;</span>bbb<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    
<span class="hljs-comment">&lt;!-- 注入 properties 数据 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myProps"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testA"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"aaa"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"testB"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>bbb<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门04Spring整合JUnit</title>
    <url>/2020/03/04/spring/Spring%E5%85%A5%E9%97%A804Spring%E6%95%B4%E5%90%88JUnit/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2015/07/31/06/50/forest-868715_1280.jpg" alt=""></p>
<hr>
<h1>Spring入门04Spring整合JUnit</h1>
<p>使用@RunWith 注解替换原有运行器</p>
<pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceTest</span> </span>{
}</code></pre>
<p>使用@ContextConfiguration 指定 spring 配置文件的位置</p>
<pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span>
<span class="hljs-meta">@ContextConfiguration(locations= {"classpath:bean.xml"})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountServiceTest</span> </span>{
}

<span class="hljs-comment">/*</span>
<span class="hljs-comment">@ContextConfiguration 注解：</span>
<span class="hljs-comment">locations 属性： 用于指定配置文件的位置。如果是类路径下，需要用 classpath:表明</span>
<span class="hljs-comment">classes 属性： 用于指定注解的类。当不使用 xml 配置时，需要用此属性指定注解类的位置</span>
<span class="hljs-comment">*/</span></code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门05AOP与事务控制</title>
    <url>/2020/03/05/spring/Spring%E5%85%A5%E9%97%A805AOP%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2021/01/06/07/34/women-5893419_1280.jpg" alt=""></p>
<hr>
<h1>Spring入门05AOP与事务控制</h1>
<h2 id="1-Spring-中的事务控制">1. Spring 中的事务控制</h2>
<ol>
<li>JavaEE 体系进行分层开发，事务处理位于业务层， Spring 提供了分层设计业务层的事务处理解决方案。</li>
<li>spring 框架为我们提供了一组事务控制的接口。具体在后面的第二小节介绍。这组接口是在spring-tx-5.0.2.RELEASE.jar 中。</li>
<li>spring 的事务控制都是基于 AOP 的，它既可以使用编程的方式实现，也可以使用配置的方式实现。我们学习的重点是使用配置的方式实现</li>
</ol>
<h3 id="1-2-Spring-中事务控制的-API-介绍">1.2 Spring 中事务控制的 API 介绍</h3>
<p><code>PlatformTransactionManager  </code></p>
<p>此接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/spring/image-20200530185415933.png" alt="image-20200530185415933" style="zoom:50%;">
<p>真正使用的事务管理对象：</p>
<p><code>org.springframework.jdbc.datasource.DataSourceTransactionManager </code></p>
<p>使用 SpringJDBC 或 iBatis 进行持久化数据时使用<br>
<code>org.springframework.orm.hibernate5.HibernateTransactionManager </code></p>
<p>使用Hibernate 版本进行持久化数据时使用</p>
<p><code>TransactionDefinition  </code></p>
<p>它是事务的定义信息对象，里面有如下方法：</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/spring/image-20200530185642199.png" alt="image-20200530185642199" style="zoom:50%;">
<p>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置。</p>
<p>是否只读：建议查询时设置为只读。</p>
<p><code>TransactionStatus  </code></p>
<p>此接口提供的是事务具体的运行状态</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/spring/image-20200530185822949.png" alt="image-20200530185822949" style="zoom:50%;">
<h3 id="1-2-Spring-中事务控制的相关术语">1.2 Spring 中事务控制的相关术语</h3>
<p>事务的隔离级别  ：</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/spring/image-20200530193028495.png" alt="image-20200530193028495" style="zoom:50%;">
<p>事务的传播行为  ：</p>
<ol>
<li><code>REQUIRED</code>：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选<br>
择（默认值）</li>
<li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</li>
<li><code>MANDATORY</code>：使用当前的事务，如果当前没有事务，就抛出异常</li>
<li><code>REQUERS_NEW</code>：新建事务，如果当前在事务中，把当前事务挂起。</li>
<li><code>NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>
<li><code>NEVER</code>：以非事务方式运行，如果当前存在事务，抛出异常</li>
<li><code>NESTED</code>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作。</li>
</ol>
<h2 id="2-Spring中的AOP：让业务层来控制事务的提交和回滚。">2. Spring中的AOP：让业务层来控制事务的提交和回滚。</h2>
<p>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p>
<h3 id="2-1-AOP的相关术语">2.1 AOP的相关术语</h3>
<p>1.<code> Joinpoint(连接点)</code>：所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。</p>
<p>2.<code> Pointcut(切入点)</code>：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。</p>
<ol start="3">
<li>
<p><code>Advice(通知/增强)</code>：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。</p>
<p>通知的类型： 前置通知,后置通知,异常通知,最终通知,环绕通知。</p>
</li>
<li>
<p><code>Introduction(引介)</code>：引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。</p>
</li>
<li>
<p><code>Target(目标对象)</code>：代理的目标对象。</p>
</li>
<li>
<p><code>Weaving(织入)</code>：是指把增强应用到目标对象来创建新的代理对象的过程。spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</p>
</li>
<li>
<p><code>Proxy（代理）</code>：一个类被 AOP 织入增强后，就产生一个结果代理类。</p>
</li>
<li>
<p><code>Aspect(切面)</code>：是切入点和通知（引介）的结合。</p>
</li>
</ol>
<h3 id="2-2-学习-spring-中的-AOP-要明确的事">2.2 学习 spring 中的 AOP 要明确的事</h3>
<p>开发阶段（我们做的）</p>
<ol>
<li>
<p>编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。</p>
</li>
<li>
<p>把公用代码抽取出来，制作成通知。（开发阶段最后再做）： AOP 编程人员来做。</p>
</li>
<li>
<p>在配置文件中，声明切入点与通知间的关系，即切面。： AOP 编程人员来做。</p>
</li>
</ol>
<p>运行阶段（ Spring 框架完成的）</p>
<p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门06基于XML的AOP配置</title>
    <url>/2020/03/06/spring/Spring%E5%85%A5%E9%97%A806%E5%9F%BA%E4%BA%8EXML%E7%9A%84AOP%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2015/04/23/21/59/tree-736875_1280.jpg" alt=""></p>
<hr>
<h1>Spring入门06基于XML的AOP配置</h1>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">"http://www.springframework.org/schema/aop"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">"http://www.springframework.org/schema/tx"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/aop</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
<p>配置</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 配置数据源--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"comboPooledDataSource"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 配置事务的通知 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 指定方法名称：是业务核心方法</span>
<span class="hljs-comment">			read-only：是否是只读事务。默认 false，不只读。</span>
<span class="hljs-comment">			isolation：指定事务的隔离级别。默认值是使用数据库的默认隔离级别。</span>
<span class="hljs-comment">			propagation：指定事务的传播行为。</span>
<span class="hljs-comment">			timeout：指定超时时间。默认值为： -1。永不超时。</span>
<span class="hljs-comment">			rollback-for：用于指定一个异常，当执行产生该异常时，事务回滚。产生其他异常，事务不回滚。没有默认值，任何异常都回滚。</span>
<span class="hljs-comment">			no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时，事务回滚。没有默认值，任何异常都回滚。</span>
<span class="hljs-comment">--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"false"</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"find*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"SUPPORTS"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 配置 aop --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 配置切入点表达式 ( 表示识别 com.hnust.service.impl 下的所有方法 ) --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(* com.hnust.service.impl.*.*(..))"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pt1"</span>/&gt;</span>
        <span class="hljs-comment">&lt;!-- 建立通知和切入点表达式的关系 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"pt1"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre>
<p>切入点表达式的说明</p>
<pre><code class="hljs markdown">execution:匹配方法的执行(常用)
execution(表达式)
表达式语法： execution([修饰符] 返回值类型 包名.类名.方法名(参数))
写法说明：
全匹配方式：
public void com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account)

访问修饰符可以省略
void com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account)  

返回值可以使用<span class="hljs-emphasis">*号，表示任意返回值</span>
<span class="hljs-emphasis">*</span> com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account)

包名可以使用<span class="hljs-emphasis">*号，表示任意包，但是有几级包，需要写几个*</span>
<span class="hljs-bullet">*</span> <span class="hljs-emphasis">*.*</span>.<span class="hljs-emphasis">*.*</span>.AccountServiceImpl.saveAccount(com.itheima.domain.Account

使用..来表示当前包，及其子包
<span class="hljs-bullet">*</span> com..AccountServiceImpl.saveAccount(com.itheima.domain.Account)

类名可以使用<span class="hljs-emphasis">*号，表示任意类</span>
<span class="hljs-emphasis">*</span> com..<span class="hljs-emphasis">*.saveAccount(com.itheima.domain.Account)</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">方法名可以使用*</span>号，表示任意方法
<span class="hljs-bullet">*</span> com..<span class="hljs-emphasis">*.*</span>( com.itheima.domain.Account)

参数列表可以使用<span class="hljs-emphasis">*，表示参数可以是任意数据类型，但是必须有参数</span>
<span class="hljs-emphasis">*</span> com..<span class="hljs-emphasis">*.*</span>(<span class="hljs-emphasis">*)</span>
<span class="hljs-emphasis"></span>
<span class="hljs-emphasis">参数列表可以使用..表示有无参数均可，有参数可以是任意类型</span>
<span class="hljs-emphasis">*</span> com..<span class="hljs-emphasis">*.*</span>(..)

全通配方式：
<span class="hljs-bullet">*</span> <span class="hljs-emphasis">*..*</span>.<span class="hljs-emphasis">*(..)</span>
<span class="hljs-emphasis">注：通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。</span>
<span class="hljs-emphasis">execution(*</span> com.itheima.service.impl.<span class="hljs-emphasis">*.*</span>(..))</code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门07基于注解的AOP配置</title>
    <url>/2020/03/07/spring/Spring%E5%85%A5%E9%97%A807%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84AOP%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2015/04/23/22/00/tree-736885_1280.jpg" alt=""></p>
<hr>
<h1>Spring入门07基于注解的AOP配置</h1>
<h2 id="1-使用步骤">1. 使用步骤</h2>
<p>导入约束</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">"http://www.springframework.org/schema/aop"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">"http://www.springframework.org/schema/tx"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/aop</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>
    
<span class="hljs-comment">&lt;!-- 配置 spring 创建容器时要扫描的包 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.itheima"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
<p>在业务层使用@Transactional 注解</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">*该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。</span>
<span class="hljs-comment">*出现接口上，表示该接口的所有实现类都有事务支持。</span>
<span class="hljs-comment">*出现在类上，表示类中所有方法有事务支持</span>
<span class="hljs-comment">*出现在方法上，表示方法有事务支持。</span>
<span class="hljs-comment">*以上三个位置的优先级：方法&gt;类&gt;接口</span>
<span class="hljs-comment">**/</span>

<span class="hljs-meta">@Transactional(readOnly=false,propagation=Propagation.REQUIRED)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(String sourceName, String targeName, Float money)</span> </span>{
    ..........
}</code></pre>
<p>在配置文件中开启 spring 对注解事务的支持</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启 spring 对注解事务的支持 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>/&gt;</span></code></pre>
<p>不使用 xml 的配置方式</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableTransactionManagement</span><span class="hljs-comment">//开启事务支持</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringTxConfiguration</span> </span>{
<span class="hljs-comment">//里面配置数据源，配置 JdbcTemplate,配置事务管理器。在之前的步骤已经写过了。</span>
}</code></pre>
<h2 id="2-自定义事务控制器和配置AOP">2. 自定义事务控制器和配置AOP</h2>
<h3 id="2-1-基于xml">2.1 基于xml</h3>
<p>自己写一个事务控制器，抽取公共代码作为通知</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionManager</span> </span>{
<span class="hljs-comment">//定义一个 DBAssit</span>
<span class="hljs-keyword">private</span> DBAssit dbAssit ;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDbAssit</span><span class="hljs-params">(DBAssit dbAssit)</span> </span>{
<span class="hljs-keyword">this</span>.dbAssit = dbAssit;
}
<span class="hljs-comment">//开启事务</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beginTransaction</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">try</span> {
dbAssit.getCurrentConnection().setAutoCommit(<span class="hljs-keyword">false</span>);
} <span class="hljs-keyword">catch</span> (SQLException e) {
e.printStackTrace();
}
}
<span class="hljs-comment">//提交事务</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">try</span> {
dbAssit.getCurrentConnection().commit();
} <span class="hljs-keyword">catch</span> (SQLException e) {
e.printStackTrace();
}
}
<span class="hljs-comment">//回滚事务</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">try</span> {
dbAssit.getCurrentConnection().rollback();
} <span class="hljs-keyword">catch</span> (SQLException e) {
e.printStackTrace();
}
}
<span class="hljs-comment">//释放资源</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">try</span> {
dbAssit.releaseConnection();
} <span class="hljs-keyword">catch</span> (Exception e) {
e.printStackTrace();
}
}
}</code></pre>
<p>注入容器中</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.utils.TransactionManager"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dbAssit"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dbAssit"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
<p>通知类型在<code>&lt;aop:aspect&gt;&lt;/aop:aspect&gt;</code>中配置</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">aop:before</span>
<span class="hljs-comment">作用：用于配置前置通知。 指定增强的方法在切入点方法之前执行</span>
<span class="hljs-comment">属性：</span>
<span class="hljs-comment">	method:用于指定通知类中的增强方法名称</span>
<span class="hljs-comment">	ponitcut-ref：用于指定切入点的表达式的引用</span>
<span class="hljs-comment">	poinitcut：用于指定切入点表达式</span>
<span class="hljs-comment">执行时间点：</span>
<span class="hljs-comment">	切入点方法执行之前执行</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"beginTransaction"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"pt1"</span>/&gt;</span>

<span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">aop:after-returning</span>
<span class="hljs-comment">作用：用于配置后置通知</span>
<span class="hljs-comment">属性：</span>
<span class="hljs-comment">	method： 指定通知中方法的名称。</span>
<span class="hljs-comment">	pointct： 定义切入点表达式</span>
<span class="hljs-comment">	pointcut-ref： 指定切入点表达式的引用</span>
<span class="hljs-comment">执行时间点：</span>
<span class="hljs-comment">	切入点方法正常执行之后。它和异常通知只能有一个执行</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"commit"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"pt1"</span>/&gt;</span>

<span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">aop:after-throwing</span>
<span class="hljs-comment">作用：用于配置异常通知</span>
<span class="hljs-comment">属性：</span>
<span class="hljs-comment">	method： 指定通知中方法的名称。</span>
<span class="hljs-comment">    pointct： 定义切入点表达式</span>
<span class="hljs-comment">	pointcut-ref： 指定切入点表达式的引用</span>
<span class="hljs-comment">执行时间点：</span>
<span class="hljs-comment">	切入点方法执行产生异常后执行。它和后置通知只能执行一个</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"rollback"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"pt1"</span>/&gt;</span>

<span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">aop:after</span>
<span class="hljs-comment">作用：用于配置最终通知</span>
<span class="hljs-comment">属性：</span>
<span class="hljs-comment">	method： 指定通知中方法的名称。</span>
<span class="hljs-comment">	pointct： 定义切入点表达式</span>
<span class="hljs-comment">	pointcut-ref： 指定切入点表达式的引用</span>
<span class="hljs-comment">执行时间点：</span>
<span class="hljs-comment">	无论切入点方法执行时是否有异常，它都会在其后面执行。</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"release"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"pt1"</span>/&gt;</span>

<span class="hljs-comment">&lt;!--例子：--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(* com.itheima.service.impl.*.*(..))"</span></span>
<span class="hljs-tag"><span class="hljs-attr">id</span>=<span class="hljs-string">"pt1"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"txManager"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置环绕通知 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"transactionAround"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"pt1"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></code></pre>
<h3 id="2-2-基于注解">2.2 基于注解</h3>
<p>导入约束</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">"http://www.springframework.org/schema/aop"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/aop</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 告知 spring，在创建容器时要扫描的包 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.itheima"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
<p>把通知类也使用注解配置</p>
<pre><code class="hljs java"><span class="hljs-meta">@Component("txManager")</span>
<span class="hljs-meta">@Aspect</span><span class="hljs-comment">//表明当前类是一个切面类</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionManager</span> </span>{
<span class="hljs-comment">//定义一个 DBAssit</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> DBAssit dbAssit ;
    
    <span class="hljs-comment">/*</span>
<span class="hljs-comment">    @Before</span>
<span class="hljs-comment">    @AfterReturning</span>
<span class="hljs-comment">    @AfterThrowing</span>
<span class="hljs-comment">    @After</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-meta">@Before("execution(* com.itheima.service.impl.*.*(..))")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beginTransaction</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            dbAssit.getCurrentConnection().setAutoCommit(<span class="hljs-keyword">false</span>);
        } <span class="hljs-keyword">catch</span> (SQLException e) {
            e.printStackTrace();
        }
    }
    
}</code></pre>
<p>在 spring 配置文件中开启 spring 对注解 AOP 的支持</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启 spring 对注解 AOP 的支持 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span></code></pre>
<p>环绕通知注解配置</p>
<pre><code class="hljs java"><span class="hljs-meta">@Around("execution(* com.itheima.service.impl.*.*(..))")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">transactionAround</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> </span>{
<span class="hljs-comment">//定义返回值</span>
Object rtValue = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">try</span> {
<span class="hljs-comment">//获取方法执行所需的参数</span>
Object[] args = pjp.getArgs();
<span class="hljs-comment">//前置通知：开启事务</span>
beginTransaction();
<span class="hljs-comment">//执行方法</span>
rtValue = pjp.proceed(args);
<span class="hljs-comment">//后置通知：提交事务</span>
commit();
}<span class="hljs-keyword">catch</span>(Throwable e) {
<span class="hljs-comment">//异常通知：回滚事务</span>
rollback();
e.printStackTrace();
}<span class="hljs-keyword">finally</span> {
<span class="hljs-comment">//最终通知：释放资源</span>
release();
}
<span class="hljs-keyword">return</span> rtValue;
}</code></pre>
<p>不使用 XML 的配置方式</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages="com.itheima")</span>
<span class="hljs-meta">@EnableAspectJAutoProxy</span><span class="hljs-comment">//开启注解AOP的支持，相当于&lt;aop:aspectj-autoproxy/&gt;</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span> </span>{
}</code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门08JDBCTemplate的使用</title>
    <url>/2020/03/08/spring/Spring%E5%85%A5%E9%97%A808JDBCTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_1280.jpg" alt=""></p>
<hr>
<h1>Spring入门08JDBCTemplate的使用</h1>
<h2 id="JdbcTemplate-概述">JdbcTemplate 概述</h2>
<p>它是 spring 框架中提供的一个对象，是对原始 Jdbc API 对象的简单封装。 spring 框架为我们提供了很多的操作模板类。</p>
<ol>
<li>操作关系型数据的：<code>JdbcTemplate</code>，<code>HibernateTemplate</code></li>
<li>操作 nosql 数据库的：<code>RedisTemplate</code></li>
<li>操作消息队列的：<code>JmsTemplate</code></li>
</ol>
<h2 id="JdbcTemplate-的使用">JdbcTemplate 的使用</h2>
<p>配置数据源</p>
<pre><code class="hljs xml">C3P0
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql:///spring_day02"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1234"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

DBCP
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql:// /spring_day02"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1234"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

spring 内置数据源
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql:///spring_day02"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1234"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
<p>将数据库连接的信息配置到属性文件中</p>
<pre><code class="hljs properties"><span class="hljs-meta">jdbc.driverClass</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span>
<span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql:///spring_day02</span>
<span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">123</span></code></pre>
<p>引入该外部属性文件，有两种方式</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"location"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"classpath:jdbc.properties"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:jdbc.properties"</span>/&gt;</span></code></pre>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.driverClass}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.url}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.username}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.password}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring+Mybatis+SpringMVC整合</title>
    <url>/2020/03/09/springboot/Spring+Mybatis+SpringMVC%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2021/02/02/21/20/sea-5975484_1280.jpg" alt=""></p>
<hr>
<h1>Spring+Mybatis+SpringMVC整合</h1>
<h2 id="0-创建Maven工程">0. 创建Maven工程</h2>
<h2 id="1-导入依赖（pom-xml）">1. 导入依赖（pom.xml）</h2>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>5.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.version</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- spring --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>


    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${mysql.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- log start --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${log4j.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${slf4j.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${slf4j.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- log end --&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${mybatis.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      
  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre>
<h2 id="2-补足缺失的文件夹">2. 补足缺失的文件夹</h2>
<p>新建的Maven项目可能缺少某些文件夹，看情况新建出来</p>
<h2 id="3-导入配置文件-resources文件夹">3. 导入配置文件(resources文件夹)</h2>
<h3 id="applicationContext-xml">applicationContext.xml</h3>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">"http://www.springframework.org/schema/aop"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">"http://www.springframework.org/schema/tx"</span> <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">"http://www.springframework.org/schema/tool"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/aop</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tool</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tool/spring-tool.xsd"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 开启注解扫描的包,希望只扫描 service 和 dao ,controller不需要扫描 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.hnust"</span>&gt;</span>
        <span class="hljs-comment">&lt;!--  哪些注解不扫描   --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"annotation"</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"org.springframework.stereotype.Controller"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>

<span class="hljs-comment">&lt;!--spring整合mybatis框架--&gt;</span>

    <span class="hljs-comment">&lt;!-- 加载配置文件,配置数据池的属性从 jdbcConfig.properties文件中获取  --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:jdbcConfig.properties"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- 配置连接池，属性是从 jdbcConfig.properties文件中获取  --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"comboPooledDataSource"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClass"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.driver}"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"jdbcUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.url}"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.username}"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${jdbc.password}"</span>/&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!--  配置SqlSession工厂 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.SqlSessionFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sqlSessionFactoryBean"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 加载 mybatis 的全局配置文件 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"configLocation"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"classpath:SqlMapConfig.xml"</span> /&gt;</span>
        <span class="hljs-comment">&lt;!--   配置数据源  --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"comboPooledDataSource"</span>/&gt;</span>
         <span class="hljs-comment">&lt;!--   配置mapper识别路径，识别路径下的所有xml文件--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mapperLocations"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"classpath:com/hnust/dao/*.xml"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 配置 dao 所在的包,spring根据 dao中的所有接口创建其代理对象，存入IOC容器中--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mapperScannerConfigurer"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basePackage"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.hnust.dao"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 配置数据源--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"comboPooledDataSource"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 配置事务的通知 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span>
        <span class="hljs-comment">&lt;!--配置通知在哪些方法上起作用,起什么作用--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"false"</span>/&gt;</span>
            <span class="hljs-comment">&lt;!--propagation：指定事务的传播行为。read-only：是否是只读事务。默认 false，不只读。--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"find*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"SUPPORTS"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 配置 aop --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 配置切入点表达式 ( 表示识别 com.hnust.service.impl 下的所有方法 ) --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(* com.hnust.service.impl.*.*(..))"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pt1"</span>/&gt;</span>
        <span class="hljs-comment">&lt;!-- 建立通知和切入点表达式的关系 --&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"pt1"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>
</code></pre>
<h3 id="jdbcConfig-properties">jdbcConfig.properties</h3>
<pre><code class="hljs properties"><span class="hljs-comment">#单独抽取出来的属性,用于更简单的配置</span>
<span class="hljs-meta">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span>
<span class="hljs-meta">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/day</span>
<span class="hljs-meta">jdbc.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">jdbc.password</span>=<span class="hljs-string">root</span></code></pre>
<h3 id="SqlMapConfig-xml">SqlMapConfig.xml</h3>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span>
<span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span>
<span class="hljs-meta">        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span>
<span class="hljs-comment">&lt;!--mybatis的主配置文件--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>

<span class="hljs-comment">&lt;!--    &amp;lt;!&amp;ndash; 加载配置文件,配置数据池的属性从 jdbcConfig.properties文件中获取（spring整合后可以不写）  &amp;ndash;&amp;gt;--&gt;</span>
<span class="hljs-comment">&lt;!--    &lt;properties resource="jdbcConfig.properties"/&gt;--&gt;</span>

    <span class="hljs-comment">&lt;!-- 配置别名，之后该包中所有类的别名就是其类名--&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"com.hnust.domain"</span>/&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span>

<span class="hljs-comment">&lt;!--    spring整合之后，下面的可以不写--&gt;</span>
<span class="hljs-comment">&lt;!--&amp;lt;!&amp;ndash; 配置环境   &amp;ndash;&amp;gt;--&gt;</span>
<span class="hljs-comment">&lt;!--    &lt;environments default="mysql"&gt;--&gt;</span>

<span class="hljs-comment">&lt;!--&amp;lt;!&amp;ndash; 配置 mysql 的环境 &amp;ndash;&amp;gt;--&gt;</span>
<span class="hljs-comment">&lt;!--        &lt;environment id="mysql"&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--&amp;lt;!&amp;ndash;   配置事务的类型   &amp;ndash;&amp;gt;--&gt;</span>
<span class="hljs-comment">&lt;!--            &lt;transactionManager type="JDBC" /&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--&amp;lt;!&amp;ndash;   配置数据连接池（数据源）         &amp;ndash;&amp;gt;--&gt;</span>
<span class="hljs-comment">&lt;!--            &lt;dataSource type="POOLED"&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--&amp;lt;!&amp;ndash; 配置连接数据库的信息&amp;ndash;&amp;gt;--&gt;</span>
<span class="hljs-comment">&lt;!--                &lt;property name="driver" value=""/&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--                &lt;property name="url" value=""/&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--                &lt;property name="username" value=""/&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--                &lt;property name="password" value=""/&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--            &lt;/dataSource&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--        &lt;/environment&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--    &lt;/environments&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--&amp;lt;!&amp;ndash;    指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件&amp;ndash;&amp;gt;--&gt;</span>
<span class="hljs-comment">&lt;!--    &lt;mappers&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--&amp;lt;!&amp;ndash;        直接写包名，注意目录结构要相同，接口名和配置文件名相同&amp;ndash;&amp;gt;--&gt;</span>
<span class="hljs-comment">&lt;!--        &lt;package name="com.hnust.dao"/&gt;--&gt;</span>
<span class="hljs-comment">&lt;!--&amp;lt;!&amp;ndash;        &lt;mapper resource="com/hnust/dao/AccountDao.xml"/&gt;&amp;ndash;&amp;gt;--&gt;</span>
<span class="hljs-comment">&lt;!--    &lt;/mappers&gt;--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre>
<h3 id="mvc-xml">mvc.xml</h3>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">"http://www.springframework.org/schema/mvc"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/mvc</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 扫描controller的注解，别的不扫描 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.hnust"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"annotation"</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"org.springframework.stereotype.Controller"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 配置视图解析器 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- JSP文件所在的目录 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/"</span> /&gt;</span>
        <span class="hljs-comment">&lt;!-- 文件的后缀名 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>

    <span class="hljs-comment">&lt;!-- 设置静态资源不过滤 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/css/"</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/css/**"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/images/"</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/images/**"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/js/"</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/js/**"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- 开启对SpringMVC注解的支持 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span> /&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
<h3 id="log4j-properties">log4j.properties</h3>
<pre><code class="hljs properties"><span class="hljs-comment"># Set root category priority to INFO and its only appender to CONSOLE.</span>
<span class="hljs-comment">#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal</span>
<span class="hljs-meta">log4j.rootCategory</span>=<span class="hljs-string">info, CONSOLE, LOGFILE</span>

<span class="hljs-comment"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span>
<span class="hljs-meta">log4j.logger.org.apache.axis.enterprise</span>=<span class="hljs-string">FATAL, CONSOLE</span>

<span class="hljs-comment"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span>
<span class="hljs-meta">log4j.appender.CONSOLE</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span>
<span class="hljs-meta">log4j.appender.CONSOLE.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span>
<span class="hljs-meta">log4j.appender.CONSOLE.layout.ConversionPattern</span>=<span class="hljs-string">%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n</span>

<span class="hljs-comment"># LOGFILE is set to be a File appender using a PatternLayout.</span>
<span class="hljs-meta">log4j.appender.LOGFILE</span>=<span class="hljs-string">org.apache.log4j.FileAppender</span>
<span class="hljs-meta">log4j.appender.LOGFILE.File</span>=<span class="hljs-string">d:axis.log</span>
<span class="hljs-meta">log4j.appender.LOGFILE.Append</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">log4j.appender.LOGFILE.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span>
<span class="hljs-meta">log4j.appender.LOGFILE.layout.ConversionPattern</span>=<span class="hljs-string">%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n</span></code></pre>
<h3 id="web-xml">web.xml</h3>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span>
<span class="hljs-comment">&lt;!--  配置中文字符过滤器 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span>

  <span class="hljs-comment">&lt;!--  配置spring 的监听器用于加载spring 的配置文件(默认只加载web-inf下的application.xml)--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>

<span class="hljs-comment">&lt;!--  配置前端核心控制器--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
<span class="hljs-comment">&lt;!--    启动就加载springmvc.xml的配置文件 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span>
</code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot01简介和快速入门</title>
    <url>/2020/04/01/springboot/SpringBoot01%E7%AE%80%E4%BB%8B%E5%92%8C%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2016/10/21/14/50/plouzane-1758197_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot01简介和快速入门</h1>
<h2 id="1-原有Spring优缺点分析">1  原有Spring优缺点分析</h2>
<h3 id="1-1-Spring的优点分析">1.1 Spring的优点分析</h3>
<p>Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。</p>
<h3 id="1-2-Spring的缺点分析">1.2 Spring的缺点分析</h3>
<p>虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。</p>
<p>所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。</p>
<p>除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</p>
<h2 id="2-SpringBoot的概述">2 SpringBoot的概述</h2>
<h3 id="2-1-SpringBoot解决上述Spring的缺点">2.1 SpringBoot解决上述Spring的缺点</h3>
<p>SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p>
<h3 id="2-2-SpringBoot的特点">2.2 SpringBoot的特点</h3>
<ul>
<li>为基于Spring的开发提供更快的入门体验</li>
<li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求</li>
<li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等</li>
<li>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</li>
</ul>
<h3 id="2-3-SpringBoot的核心功能">2.3 SpringBoot的核心功能</h3>
<ul>
<li>
<p>起步依赖</p>
<p>起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。</p>
<p>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p>
</li>
<li>
<p>自动配置</p>
<p>Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p>
</li>
</ul>
<p>​	注意：起步依赖和自动配置的原理剖析会在第三章《SpringBoot原理分析》进行详细讲解</p>
<h2 id="3-SpringBoot快速入门">3 SpringBoot快速入门</h2>
<h3 id="3-1-创建Maven工程">3.1 创建Maven工程</h3>
<p>使用idea工具创建一个maven工程，该工程为普通的java工程即可</p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/1.png" alt=""></p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/2.png" alt=""></p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/3.png" alt=""></p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/4.png" alt=""></p>
<hr>
<h3 id="3-2-添加SpringBoot的起步依赖">3.2 添加SpringBoot的起步依赖</h3>
<p>SpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre>
<p>SpringBoot要集成SpringMVC进行Controller的开发，所以项目要导入web的启动依赖</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre>
<h3 id="3-3-编写SpringBoot引导类">3.3 编写SpringBoot引导类</h3>
<p>要通过SpringBoot提供的引导类起步SpringBoot才可以进行访问</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima;

<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpringBootApplication</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        SpringApplication.run(MySpringBootApplication.class);
    }

}</code></pre>
<h3 id="3-4-编写Controller">3.4 编写Controller</h3>
<p>在引导类MySpringBootApplication同级包或者子级包中创建QuickStartController</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.controller;

<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;

<span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickStartController</span> </span>{
    
    <span class="hljs-meta">@RequestMapping("/quick")</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">quick</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"springboot 访问成功!"</span>;
    }
    
}</code></pre>
<h3 id="3-5-测试">3.5 测试</h3>
<p>执行SpringBoot起步类的主方法，控制台打印日志如下：</p>
<pre><code class="hljs maxima">.   ____          <span class="hljs-symbol">_</span>            <span class="hljs-symbol">__</span> <span class="hljs-symbol">_</span> <span class="hljs-symbol">_</span>
 /\\ / ___'<span class="hljs-symbol">_</span> <span class="hljs-symbol">__</span> <span class="hljs-symbol">_</span> <span class="hljs-symbol">_</span>(<span class="hljs-symbol">_</span>)<span class="hljs-symbol">_</span> <span class="hljs-symbol">__</span>  <span class="hljs-symbol">__</span> <span class="hljs-symbol">_</span> \ \ \ \
( ( )\___ | '<span class="hljs-symbol">_</span> | '<span class="hljs-symbol">_</span>| | '<span class="hljs-symbol">_</span> \/ <span class="hljs-symbol">_</span>` | \ \ \ \
 \\/  ___)| |<span class="hljs-symbol">_</span>)| | | | | || (<span class="hljs-symbol">_</span>| |  ) ) ) )
  '  |____| .<span class="hljs-symbol">__</span>|<span class="hljs-symbol">_</span>| |<span class="hljs-symbol">_</span>|<span class="hljs-symbol">_</span>| |<span class="hljs-symbol">_</span>\<span class="hljs-symbol">__</span>, | / / / /
 =========|<span class="hljs-symbol">_</span>|==============|___/=/<span class="hljs-symbol">_</span>/<span class="hljs-symbol">_</span>/<span class="hljs-symbol">_</span>/
 :: Spring Boot ::        (v2<span class="hljs-number">.0</span><span class="hljs-number">.1</span>.RELEASE)

<span class="hljs-number">2018</span>-<span class="hljs-number">05</span>-<span class="hljs-number">08</span> <span class="hljs-number">14</span>:<span class="hljs-number">29</span>:<span class="hljs-number">59.714</span>  INFO <span class="hljs-number">5672</span> --- [           main] com.itheima.MySpringBootApplication      : Starting MySpringBootApplication on DESKTOP-RRUNFUH with PID <span class="hljs-number">5672</span> (C:\Users\muzimoo\IdeaProjects\IdeaTest\springboot_quick\target\classes started by muzimoo <span class="hljs-keyword">in</span> C:\Users\muzimoo\IdeaProjects\IdeaTest)
... ... ...
o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [<span class="hljs-comment">/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]</span>
<span class="hljs-comment">2018-05-08 14:30:03.126  INFO 5672 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup</span>
<span class="hljs-comment">2018-05-08 14:30:03.196  INFO 5672 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''</span>
<span class="hljs-comment">2018-05-08 14:30:03.206  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Started MySpringBootApplication in 4.252 seconds (JVM running for 5.583)</span></code></pre>
<p>通过日志发现，Tomcat started on port(s): 8080 (http) with context path ‘’</p>
<p>tomcat已经起步，端口监听8080，web应用的虚拟工程名称为空</p>
<p>打开浏览器访问url地址为：<a class="link" href="http://localhost:8080/quick">http://localhost:8080/quick<i class="fas fa-external-link-alt"></i></a></p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/5.png" alt=""></p>
<hr>
<h2 id="4-快速入门解析">4 快速入门解析</h2>
<h3 id="4-1-SpringBoot代码解析">4.1 SpringBoot代码解析</h3>
<ul>
<li><code>@SpringBootApplication</code>：标注SpringBoot的启动类，该注解具备多种功能（后面详细剖析）</li>
<li><code>SpringApplication.run(MySpringBootApplication.class)</code> 代表运行SpringBoot的启动类，参数为SpringBoot启动类的字节码对象</li>
</ul>
<h3 id="4-2-SpringBoot工程热部署">4.2 SpringBoot工程热部署</h3>
<p>我们在开发中反复修改类、页面等资源，每次修改后都是需要重新启动才生效，这样每次启动都很麻烦，浪费了大量的时间，我们可以在修改代码后不重启就能生效，在 pom.xml 中添加如下配置就可以实现这样的功能，我们称之为热部署。</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--热部署配置--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<p>注意：IDEA进行SpringBoot热部署失败原因</p>
<p>出现这种情况，并不是热部署配置问题，其根本原因是因为Intellij IEDA默认情况下不会自动编译，需要对IDEA进行自动编译的设置，如下：</p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/19.png" alt=""></p>
<hr>
<p>然后 Shift+Ctrl+Alt+/，选择Registry</p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/20.png" alt=""></p>
<hr>
<h3 id="4-3-使用idea快速创建SpringBoot项目">4.3 使用idea快速创建SpringBoot项目</h3>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/6.png" alt=""></p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/7.png" alt=""></p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/8.png" alt=""></p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/9.png" alt=""></p>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/10.png" alt=""></p>
<hr>
<p>通过idea快速创建的SpringBoot项目的pom.xml中已经导入了我们选择的web的起步依赖的坐标</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag">	<span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.itheima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_quick2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springboot_quick2<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>


<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<p>可以使用快速入门的方式创建Controller进行访问，此处不再赘述</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot03整合Mybatis</title>
    <url>/2020/04/03/springboot/SpringBoot03%E6%95%B4%E5%90%88Mybatis/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2015/03/26/09/48/chicago-690364_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot03整合Mybatis</h1>
<h2 id="1-添加Mybatis的起步依赖">1 添加Mybatis的起步依赖</h2>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mybatis起步依赖--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<h2 id="2-添加数据库驱动坐标">2 添加数据库驱动坐标</h2>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MySQL连接驱动 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<h2 id="3-添加数据库连接信息">3 添加数据库连接信息</h2>
<p>在<code>application.properties</code>中添加数据量的连接信息</p>
<pre><code class="hljs properties"><span class="hljs-comment">#DB Configuration:</span>
<span class="hljs-meta">spring.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
<span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8</span>
<span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span></code></pre>
<h2 id="4-创建user表">4 创建user表</h2>
<p>在test数据库中创建user表</p>
<pre><code class="hljs sql"><span class="hljs-comment">-- ----------------------------</span>
<span class="hljs-comment">-- Table structure for `user`</span>
<span class="hljs-comment">-- ----------------------------</span>
<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `<span class="hljs-keyword">user</span>`;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>` (
  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,
  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,
  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)
) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">10</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;

<span class="hljs-comment">-- ----------------------------</span>
<span class="hljs-comment">-- Records of user</span>
<span class="hljs-comment">-- ----------------------------</span>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>` <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'1'</span>, <span class="hljs-string">'zhangsan'</span>, <span class="hljs-string">'123'</span>, <span class="hljs-string">'张三'</span>);
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>` <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'2'</span>, <span class="hljs-string">'lisi'</span>, <span class="hljs-string">'123'</span>, <span class="hljs-string">'李四'</span>);</code></pre>
<h2 id="5-创建实体Bean">5 创建实体Bean</h2>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
    <span class="hljs-comment">// 主键</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-comment">// 用户名</span>
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-comment">// 密码</span>
    <span class="hljs-keyword">private</span> String password;
    <span class="hljs-comment">// 姓名</span>
    <span class="hljs-keyword">private</span> String name;
  
    <span class="hljs-comment">//此处省略getter和setter方法 .. ..</span>
    
}</code></pre>
<h2 id="6-编写Mapper">6 编写Mapper</h2>
<pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserList</span><span class="hljs-params">()</span></span>;
}</code></pre>
<p>注意：@Mapper标记该类是一个mybatis的mapper接口，可以被spring boot自动扫描到spring上下文中</p>
<h2 id="7-配置Mapper映射文件">7 配置Mapper映射文件</h2>
<p>在src\main\resources\mapper路径下加入UserMapper.xml配置文件"</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"com.itheima.mapper.UserMapper"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"queryUserList"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"user"</span>&gt;</span>
        select * from user
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre>
<h2 id="8-在application-properties中添加mybatis的信息">8 在application.properties中添加mybatis的信息</h2>
<pre><code class="hljs properties"><span class="hljs-comment">#spring集成Mybatis环境</span>
<span class="hljs-comment">#pojo别名扫描包</span>
<span class="hljs-meta">mybatis.type-aliases-package</span>=<span class="hljs-string">com.itheima.domain</span>
<span class="hljs-comment">#加载Mybatis映射文件</span>
<span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*Mapper.xml</span></code></pre>
<h2 id="9-编写测试Controller">9 编写测试Controller</h2>
<pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperController</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserMapper userMapper;

    <span class="hljs-meta">@RequestMapping("/queryUser")</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUser</span><span class="hljs-params">()</span></span>{
        List&lt;User&gt; users = userMapper.queryUserList();
        <span class="hljs-keyword">return</span> users;
    }

}</code></pre>
<h2 id="10-测试">10 测试</h2>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/14.png" alt=""></p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot04整合Junit</title>
    <url>/2020/04/04/springboot/SpringBoot04%E6%95%B4%E5%90%88Junit/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2013/06/12/22/20/mountains-139012_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot04整合Junit</h1>
<h2 id="1-添加Junit的起步依赖">1 添加Junit的起步依赖</h2>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--测试的起步依赖--&gt;</span>
 		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--junit--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h2 id="2-编写测试类">2 编写测试类</h2>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.test;

<span class="hljs-keyword">import</span> com.itheima.MySpringBootApplication;
<span class="hljs-keyword">import</span> com.itheima.domain.User;
<span class="hljs-keyword">import</span> com.itheima.mapper.UserMapper;
<span class="hljs-keyword">import</span> org.junit.Test;
<span class="hljs-keyword">import</span> org.junit.runner.RunWith;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;
<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-meta">@RunWith(SpringRunner.class)</span>
<span class="hljs-meta">@SpringBootTest(classes = MySpringBootApplication.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapperTest</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserMapper userMapper;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        List&lt;User&gt; users = userMapper.queryUserList();
        System.out.println(users);
    }

}</code></pre>
<p>其中，</p>
<p><code>SpringRunner</code>继承自<code>SpringJUnit4ClassRunner</code>，使用哪一个Spring提供的测试测试引擎都可以</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringRunner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringJUnit4ClassRunner</span> </span></code></pre>
<p><code>@SpringBootTest</code>的属性指定的是引导类的字节码对象</p>
<h2 id="3-控制台打印信息">3 控制台打印信息</h2>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/15.png" alt=""></p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot05整合Spring Data JPA</title>
    <url>/2020/04/05/springboot/SpringBoot05%E6%95%B4%E5%90%88Spring%20Data%20JPA/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2013/10/02/23/03/mountains-190055_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot05整合Spring Data JPA</h1>
<h2 id="1-添加Spring-Data-JPA的起步依赖">1 添加Spring Data JPA的起步依赖</h2>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- springBoot JPA的起步依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<h2 id="2-添加数据库驱动依赖">2 添加数据库驱动依赖</h2>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MySQL连接驱动 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<h2 id="3-在application-properties中配置数据库和jpa的相关属性">3 在application.properties中配置数据库和jpa的相关属性</h2>
<pre><code class="hljs properties"><span class="hljs-comment">#DB Configuration:</span>
<span class="hljs-meta">spring.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span>
<span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8</span>
<span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span>
<span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span>

<span class="hljs-comment">#JPA Configuration:</span>
<span class="hljs-meta">spring.jpa.database</span>=<span class="hljs-string">MySQL</span>
<span class="hljs-meta">spring.jpa.show-sql</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">spring.jpa.generate-ddl</span>=<span class="hljs-string">true</span>
<span class="hljs-meta">spring.jpa.hibernate.ddl-auto</span>=<span class="hljs-string">update</span>
<span class="hljs-meta">spring.jpa.hibernate.naming_strategy</span>=<span class="hljs-string">org.hibernate.cfg.ImprovedNamingStrategy</span></code></pre>
<h2 id="4-创建实体配置实体">4 创建实体配置实体</h2>
<pre><code class="hljs java"><span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
    <span class="hljs-comment">// 主键</span>
    <span class="hljs-meta">@Id</span>
    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-comment">// 用户名</span>
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-comment">// 密码</span>
    <span class="hljs-keyword">private</span> String password;
    <span class="hljs-comment">// 姓名</span>
    <span class="hljs-keyword">private</span> String name;
 
    <span class="hljs-comment">//此处省略setter和getter方法... ...</span>
}</code></pre>
<h2 id="5-编写UserRepository">5 编写UserRepository</h2>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Long</span>&gt;</span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;
}</code></pre>
<h2 id="6-编写测试类">6 编写测试类</h2>
<pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span>
<span class="hljs-meta">@SpringBootTest(classes=MySpringBootApplication.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaTest</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>{
        List&lt;User&gt; users = userRepository.findAll();
        System.out.println(users);
    }

}</code></pre>
<h2 id="7-控制台打印信息">7 控制台打印信息</h2>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/16.png" alt=""></p>
<p>注意：如果是jdk9，执行报错如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/17.png" alt=""></p>
<p>原因：jdk缺少相应的jar</p>
<p>解决方案：手动导入对应的maven坐标，如下：</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jdk9需要导入如下坐标--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot06整合Redis</title>
    <url>/2020/04/06/springboot/SpringBoot06%E6%95%B4%E5%90%88Redis/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2014/09/10/00/59/mountains-440520_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot06整合Redis</h1>
<h2 id="1-添加redis的起步依赖">1 添加redis的起步依赖</h2>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置使用redis启动器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<h2 id="2-配置redis的连接信息">2 配置redis的连接信息</h2>
<pre><code class="hljs properties"><span class="hljs-comment">#Redis</span>
<span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">127.0.0.1</span>
<span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span></code></pre>
<h2 id="3-注入RedisTemplate测试redis操作">3 注入RedisTemplate测试redis操作</h2>
<pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span>
<span class="hljs-meta">@SpringBootTest(classes = SpringbootJpaApplication.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisTest</span> </span>{

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserRepository userRepository;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>{
        <span class="hljs-comment">//从redis缓存中获得指定的数据</span>
        String userListData = redisTemplate.boundValueOps(<span class="hljs-string">"user.findAll"</span>).get();
        <span class="hljs-comment">//如果redis中没有数据的话</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span>==userListData){
            <span class="hljs-comment">//查询数据库获得数据</span>
            List&lt;User&gt; all = userRepository.findAll();
            <span class="hljs-comment">//转换成json格式字符串</span>
            ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();
            userListData = om.writeValueAsString(all);
            <span class="hljs-comment">//将数据存储到redis中，下次在查询直接从redis中获得数据，不用在查询数据库</span>
            redisTemplate.boundValueOps(<span class="hljs-string">"user.findAll"</span>).set(userListData);
            System.out.println(<span class="hljs-string">"===============从数据库获得数据==============="</span>);
        }<span class="hljs-keyword">else</span>{
            System.out.println(<span class="hljs-string">"===============从redis缓存中获得数据==============="</span>);
        }

        System.out.println(userListData);

    }

}</code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot07热部署和war包部署</title>
    <url>/2020/04/07/springboot/SpringBoot07%E7%83%AD%E9%83%A8%E7%BD%B2%E5%92%8Cwar%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2021/02/07/19/57/gazelle-5992510_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot07热部署和war部署</h1>
<h2 id="springboot热部署">springboot热部署</h2>
<p>热部署：在不重启服务器的情况下，就可以将代码的修改立即生效的过程</p>
<p>三种方式实现热部署：</p>
<ol>
<li>springboot-devtools：</li>
<li>spring-loaded：有时不能生效</li>
<li>jrebel：jvm占用内存少，修改之后立即生效，要钱</li>
</ol>
<h3 id="springboot-devtools">springboot-devtools</h3>
<ol>
<li>
<p>引入依赖：</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--热部署依赖--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
<li>
<p>开启idea的自动编译功能</p>
</li>
</ol>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20200706194837105.png" alt="image-20200706194837105" style="zoom: 50%;">
<ol start="3">
<li>开启idea在程序运行过程中交换类加载器</li>
</ol>
<pre><code class="hljs stylus">ctrl+alt+shift+/,选择registry,勾选complier<span class="hljs-selector-class">.sutomake</span><span class="hljs-selector-class">.allow</span><span class="hljs-selector-class">.when</span><span class="hljs-selector-class">.app</span>.running</code></pre>
<ol start="4">
<li>运行时出现如下提示，说明成功开启：</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20200706195421788.png" alt="image-20200706195421788"></p>
<h2 id="war包部署">war包部署</h2>
<h3 id="设置打包方式为war">设置打包方式为war</h3>
<p><code>&lt;packaging&gt;war&lt;/packaging&gt;</code></p>
<h3 id="在插件中指定入口类">在插件中指定入口类</h3>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-comment">&lt;!--使用热部署出现中文乱码解决方案--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">fork</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">fork</span>&gt;</span>
          <span class="hljs-comment">&lt;!--增加jvm参数--&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">jvmArguments</span>&gt;</span>-Dfile.encoding=UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">jvmArguments</span>&gt;</span>
          <span class="hljs-comment">&lt;!--指定入口类--&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.baizhi.Application<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre>
<h3 id="排除内嵌的tomcat">排除内嵌的tomcat</h3>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>   <span class="hljs-comment">&lt;!--去掉内嵌tomcat--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <span class="hljs-comment">&lt;!--去掉使用内嵌tomcat解析jsp--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<h3 id="配置入口类">配置入口类</h3>
<pre><code class="hljs java"><span class="hljs-comment">//1.继承SpringBootServletInitializer</span>
<span class="hljs-comment">//2.覆盖configure方法</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        SpringApplication.run(Application.class,args);
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>{
        <span class="hljs-keyword">return</span> builder.sources(Application.class);
    }
}</code></pre>
<h3 id="打包测试">打包测试</h3>
<pre><code class="hljs java"><span class="hljs-comment">/* 一旦使用war包部署注意:</span>
<span class="hljs-comment">	1. application.yml 中配置port context-path 失效</span>
<span class="hljs-comment">	2. 访问时使用打成war包的名字和外部tomcat端口号进行访问项目</span>
<span class="hljs-comment">*/</span></code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot08面向切面编程</title>
    <url>/2020/04/08/springboot/SpringBoot08%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2015/05/15/14/49/rhinoceros-768714_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot08面向切面编程</h1>
<h2 id="引言">引言</h2>
<blockquote>
<p>springboot是对原有项目中spring框架和springmvc的进一步封装,因此在springboot中同样支持spring框架中AOP切面编程,不过在springboot中为了快速开发仅仅提供了注解方式的切面编程.</p>
</blockquote>
<h2 id="使用">使用</h2>
<h3 id="引入依赖">引入依赖</h3>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<h3 id="相关注解">相关注解</h3>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">    <span class="hljs-doctag">@Aspect</span> 用来类上,代表这个类是一个切面</span>
<span class="hljs-comment">    <span class="hljs-doctag">@Before</span> 用在方法上代表这个方法是一个前置通知方法 </span>
<span class="hljs-comment">    <span class="hljs-doctag">@After</span> 用在方法上代表这个方法是一个后置通知方法 <span class="hljs-doctag">@Around</span> 用在方法上代表这个方法是一个环绕的方法</span>
<span class="hljs-comment">    <span class="hljs-doctag">@Around</span> 用在方法上代表这个方法是一个环绕的方法</span>
<span class="hljs-comment">**/</span></code></pre>
<h4 id="前置切面">前置切面</h4>
<pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>{
    <span class="hljs-meta">@Before("execution(* com.baizhi.service.*.*(..))")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>{
        System.out.println(<span class="hljs-string">"前置通知"</span>);
        joinPoint.getTarget();<span class="hljs-comment">//目标对象</span>
        joinPoint.getSignature();<span class="hljs-comment">//方法签名</span>
        joinPoint.getArgs();<span class="hljs-comment">//方法参数</span>
    }
}</code></pre>
<h4 id="后置切面">后置切面</h4>
<pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>{
    <span class="hljs-meta">@After("execution(* com.baizhi.service.*.*(..))")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>{
        System.out.println(<span class="hljs-string">"后置通知"</span>);
        joinPoint.getTarget();<span class="hljs-comment">//目标对象</span>
        joinPoint.getSignature();<span class="hljs-comment">//方法签名</span>
        joinPoint.getArgs();<span class="hljs-comment">//方法参数</span>
    }
}</code></pre>
<blockquote>
<p>注意: 前置通知和后置通知都没有返回值,方法参数都为joinpoint</p>
</blockquote>
<h4 id="环绕切面">环绕切面</h4>
<pre><code class="hljs java"><span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>{
    <span class="hljs-meta">@Around("execution(* com.baizhi.service.*.*(..))")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">before</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
        System.out.println(<span class="hljs-string">"进入环绕通知"</span>);
        proceedingJoinPoint.getTarget();<span class="hljs-comment">//目标对象</span>
        proceedingJoinPoint.getSignature();<span class="hljs-comment">//方法签名</span>
        proceedingJoinPoint.getArgs();<span class="hljs-comment">//方法参数</span>
        Object proceed = proceedingJoinPoint.proceed();<span class="hljs-comment">//放行执行目标方法</span>
        System.out.println(<span class="hljs-string">"目标方法执行之后回到环绕通知"</span>);
        <span class="hljs-keyword">return</span> proceed;<span class="hljs-comment">//返回目标方法返回值</span>
    }
}</code></pre>
<blockquote>
<p>注意: 环绕通知存在返回值,参数为<code>ProceedingJoinPoint</code>,如果执行放行,不会执行目标方法,一旦放行必须将目标方法的返回值返回,否则调用者无法接受返回数据</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot09文件上传下载</title>
    <url>/2020/04/09/springboot/SpringBoot09%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2012/06/19/10/32/owl-50267_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot09文件上传下载</h1>
<h2 id="文件上传">文件上传</h2>
<p>定义:<code>用户访问当前系统,将自己本地计算机中文件通过浏览器上传到当前系统所在的服务器过程中称之为文件的上传</code></p>
<h3 id="准备上传页面">准备上传页面</h3>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"路径...."</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">"multipart/form-data"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"aa"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"上传"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">	1. 表单提交方式必须是post</span>
<span class="hljs-comment">	2. 表单的enctype属性必须为multipart/form-data</span>
<span class="hljs-comment">	3. 后台接受变量名字要与文件选择name属性一致</span>
<span class="hljs-comment">--&gt;</span></code></pre>
<h3 id="编写控制器">编写控制器</h3>
<pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@RequestMapping("/file")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileController</span> </span>{
  <span class="hljs-meta">@RequestMapping("/upload")</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload</span><span class="hljs-params">(MultipartFile aa, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        String realPath = request.getRealPath(<span class="hljs-string">"/upload"</span>);
        aa.transferTo(<span class="hljs-keyword">new</span> File(realPath,aa.getOriginalFilename()));<span class="hljs-comment">//文件上传</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;
  }
}</code></pre>
<h3 id="修改文件上传大小">修改文件上传大小</h3>
<pre><code class="hljs yml"><span class="hljs-comment">#上传时出现如下异常:  上传文件的大小超出默认配置  默认10M</span>
<span class="hljs-attr">nested exception is java.lang.IllegalStateException:</span> <span class="hljs-string">org.apache.tomcat.util.http.fileupload.FileUploadBase$SizeLimitExceededException:</span> <span class="hljs-string">the</span> <span class="hljs-string">request</span> <span class="hljs-string">was</span> <span class="hljs-string">rejected</span> <span class="hljs-string">because</span> <span class="hljs-string">its</span> <span class="hljs-string">size</span> <span class="hljs-string">(38443713)</span> <span class="hljs-string">exceeds</span> <span class="hljs-string">the</span> <span class="hljs-string">configured</span> <span class="hljs-string">maximum</span> <span class="hljs-string">(10485760)</span>
<span class="hljs-comment">#修改上传文件大小:</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">http:</span>
    <span class="hljs-attr">multipart:</span>
       <span class="hljs-attr">max-request-size:</span> <span class="hljs-number">209715200</span>  <span class="hljs-comment">#用来控制文件上传大小的限制</span>
       <span class="hljs-attr">max-file-size:</span> <span class="hljs-number">209715200</span> <span class="hljs-comment">#用来指定服务端最大文件大小   </span>

<span class="hljs-string">spring.servlet.multipart.max-file-size=500MB</span>
<span class="hljs-string">spring.servlet.multipart.max-request-size=500MB</span></code></pre>
<h2 id="文件下载">文件下载</h2>
<h3 id="提供下载文件链接">提供下载文件链接</h3>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"../file/download?fileName=corejava.txt"</span>&gt;</span>corejava.txt<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>
<h3 id="开发控制器">开发控制器</h3>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/download")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">download</span><span class="hljs-params">(String fileName, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        String realPath = request.getRealPath(<span class="hljs-string">"/upload"</span>);
        FileInputStream is = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(realPath, fileName));
        ServletOutputStream os = response.getOutputStream();
        response.setHeader(<span class="hljs-string">"content-disposition"</span>,<span class="hljs-string">"attachment;fileName="</span>+ URLEncoder.encode(fileName,<span class="hljs-string">"UTF-8"</span>));
        IOUtils.copy(is,os);
        IOUtils.closeQuietly(is);
        IOUtils.closeQuietly(os);
    }</code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot10拦截器使用</title>
    <url>/2020/04/10/springboot/SpringBoot10%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2016/11/02/17/38/japan-1792369_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot10拦截器使用</h1>
<h2 id="开发拦截器">开发拦截器</h2>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object o)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        System.out.println(<span class="hljs-string">"======1====="</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//返回true 放行  返回false阻止</span>
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object o, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        System.out.println(<span class="hljs-string">"=====2====="</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object o, Exception e)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        System.out.println(<span class="hljs-string">"=====3====="</span>);
    }
}</code></pre>
<h2 id="配置拦截器">配置拦截器</h2>
<pre><code class="hljs java"><span class="hljs-comment">//1.x中拦截器配置</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterceptorConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>{
        <span class="hljs-comment">//添加拦截器</span>
        registry.addInterceptor(<span class="hljs-keyword">new</span> MyInterceptor())
            .addPathPatterns(<span class="hljs-string">"/**"</span>)<span class="hljs-comment">//定义拦截路径</span>
            .excludePathPatterns(<span class="hljs-string">"/hello/**"</span>); <span class="hljs-comment">//排除拦截路径</span>
    }
}

<span class="hljs-comment">//2.x中拦截器配置</span>
    <span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterceptorConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>{
        registry.addInterceptor(<span class="hljs-keyword">new</span> MyInterceptor())<span class="hljs-comment">//添加拦截器</span>
                .addPathPatterns(<span class="hljs-string">"/hello/**"</span>)<span class="hljs-comment">//添加拦截的请求路径</span>
                .excludePathPatterns(<span class="hljs-string">"/hello/world"</span>);<span class="hljs-comment">//添加排除那些请求路径不经过拦截器</span>
    }
}</code></pre>
<p><code>注意:在springboot2.x版本中自定义拦截器之后出现项目中静态资源 404情况,需要在自定义拦截器的配置中加入如下配置即可:</code></p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterceptorConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>{
        registry.addInterceptor(<span class="hljs-keyword">new</span> LoginInterceptor())
                .addPathPatterns(<span class="hljs-string">"/file/**"</span>)
                .excludePathPatterns(<span class="hljs-string">"/js/**"</span>, <span class="hljs-string">"/css/**"</span>, <span class="hljs-string">"/files/**"</span>);<span class="hljs-comment">//放行静态资源 静态资源被认为是一个控制器请求</span>
    }
        <span class="hljs-comment">//springboot2.x 静态资源在自定义拦截器之后无法访问的解决方案</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>{
        registry.addResourceHandler(<span class="hljs-string">"/**"</span>) <span class="hljs-comment">//代表以什么样的请求路径访问静态资源</span>
                .addResourceLocations(<span class="hljs-string">"classpath:/static/"</span>)
                .addResourceLocations(<span class="hljs-string">"classpath:/templates/"</span>);

    }
}</code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot11配置JSP和thymeleaf模板解析</title>
    <url>/2020/04/11/springboot/SpringBoot11%E9%85%8D%E7%BD%AEJSP%E5%92%8Cthymeleaf%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2014/10/07/13/48/mountain-477832_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot11配置JSP和thymeleaf模板解析</h1>
<h2 id="1-集成jsp模板">1 集成jsp模板</h2>
<h3 id="引入jsp的集成jar包">引入jsp的集成jar包</h3>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<h3 id="引入jsp运行插件">引入jsp运行插件</h3>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>springboot_day1<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>
    <span class="hljs-comment">&lt;!--引入jsp运行插件--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre>
<h3 id="配置视图解析器">配置视图解析器</h3>
<pre><code class="hljs yml"><span class="hljs-comment">#在配置文件中引入视图解析器</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">mvc:</span>
    <span class="hljs-attr">view:</span>
      <span class="hljs-attr">prefix:</span> <span class="hljs-string">/</span>   	<span class="hljs-comment"># /代表访问项目中webapp中页面</span>
      <span class="hljs-attr">suffix:</span> <span class="hljs-string">.jsp</span></code></pre>
<h3 id="第一种方式使用插件启动">第一种方式使用插件启动</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20191129124602959.png" alt="image-20191129124602959"></p>
<h3 id="第二种方式使用idea中指定工作目录启动-推荐">第二种方式使用idea中指定工作目录启动  [推荐]</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20191129124727562.png" alt="image-20191129124727562"></p>
<h3 id="启动访问jsp页面">启动访问jsp页面</h3>
<pre><code class="hljs markdown">http://localhost:8989/cmfz/index.jsp</code></pre>
<h3 id="修改jsp无须重启应用">修改jsp无须重启应用</h3>
<pre><code class="hljs properties"><span class="hljs-meta">server.servlet.jsp.init-parameters.development</span>=<span class="hljs-string">true</span></code></pre>
<h2 id="2-集成thymelaf模板">2 集成thymelaf模板</h2>
<blockquote>
<p>Thymeleaf是一个用于web和独立环境的现代服务器端Java模板引擎。  --摘自官网https://www.thymeleaf.org/</p>
</blockquote>
<p><code>Thymeleaf</code>是跟<code>Velocity</code>、<code>FreeMarker</code>类似的模板引擎，它可以完全替代JSP，相较与其他的模板引擎相比, <code>Thymeleaf</code>在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。</p>
<h3 id="引入依赖">引入依赖</h3>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--使用thymelaf--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<h3 id="编写配置">编写配置</h3>
<pre><code class="hljs properties"><span class="hljs-meta">spring.thymeleaf.prefix</span>=<span class="hljs-string">classpath:/templates/      #使用模板目录</span>
<span class="hljs-meta">spring.thymeleaf.suffix</span>=<span class="hljs-string">.html                      #使用模板后缀</span>
<span class="hljs-meta">spring.thymeleaf.encoding</span>=<span class="hljs-string">UTF-8                    #使用模板编码</span>
<span class="hljs-meta">spring.thymeleaf.enabled</span>=<span class="hljs-string">true                      #开始thymelaf模板</span>
<span class="hljs-meta">spring.thymeleaf.servlet.content-type</span>=<span class="hljs-string">text/html    #使用模板响应类型</span></code></pre>
<h3 id="编写控制器测试">编写控制器测试</h3>
<pre><code class="hljs java"><span class="hljs-meta">@Controller</span>    <span class="hljs-comment">//一定要是@Controller 不能再使用@RestController注解</span>
<span class="hljs-meta">@RequestMapping("hello")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>{
    <span class="hljs-meta">@GetMapping("hello")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{
        System.out.println(<span class="hljs-string">"测试与 thymeleaf 的集成"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;
    }
}</code></pre>
<h3 id="在templates目录中定义模板">在templates目录中定义模板</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="http://img.sky123.top/springboot/image-20200323085834206.png" alt="image-20200323085834206"></p>
<h3 id="测试访问">测试访问</h3>
<pre><code class="hljs http">http://localhost:8989/springboot_day3/hello/hello</code></pre>
<h3 id="查看结果">查看结果</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20200323085948499.png" alt="image-20200323085948499"></p>
<h3 id="开启直接访问html页面">开启直接访问html页面</h3>
<pre><code class="hljs properties"><span class="hljs-meta">spring.resources.static-locations</span>=<span class="hljs-string">classpath:/templates/,classpath:/static/</span></code></pre>
<h3 id="测试结果">测试结果</h3>
<pre><code class="hljs http">http://localhost:8989/springboot_day3/index.html</code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20200323090142705.png" alt="image-20200323090142705"></p>
<h2 id="3-Thymeleaf基本使用">3 Thymeleaf基本使用</h2>
<p><code>使用时必须在页面中加入thymeleaf如下命名空间:</code></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></code></pre>
<h3 id="展示单个数据">展示单个数据</h3>
<h4 id="设置数据">设置数据</h4>
<pre><code class="hljs java">model.addAttribute(<span class="hljs-string">"name"</span>,<span class="hljs-string">"张三"</span>); 或 request.setAttribute(<span class="hljs-string">"name"</span>,<span class="hljs-string">"小黑"</span>);</code></pre>
<h4 id="获取数据">获取数据</h4>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${name}"</span>/&gt;</span>  ---&gt;获取数据</code></pre>
<p><code>注意:在springboot2.x版本中必须加入国际化配置文件才能正常展示:</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20200323100724749.png" alt="image-20200323100724749"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20200323100747881.png" alt="image-20200323100747881"></p>
<h4 id="获取并解析含有html标签数据">获取并解析含有html标签数据</h4>
<pre><code class="hljs java">model.addAttribute(<span class="hljs-string">"name"</span>,<span class="hljs-string">"&lt;a href=''&gt;张三&lt;/a&gt;"</span>);
model.addAttribute(<span class="hljs-string">"username"</span>,<span class="hljs-string">"小陈"</span>);</code></pre>
<ul>
<li>直接获取原样输出</li>
</ul>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${name}"</span>/&gt;</span></code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20200323100956740.png" alt="image-20200323100956740"></p>
<ul>
<li>获取并解析</li>
</ul>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">"${name}"</span>/&gt;</span></code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20200323101457134.png" alt="image-20200323101457134"></p>
<ul>
<li>
<p>将数据赋值给表单元素</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"${username}"</span>/&gt;</span></code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20200323103452620.png" alt="image-20200323103452620"></p>
</li>
</ul>
<pre><code class="hljs markdown"><span class="hljs-section"># 总结</span>
<span class="hljs-code">	1.使用 th:text="${属性名}"  获取对应数据,获取数据时会将对应标签中数据清空,因此最好是空标签</span>
<span class="hljs-code">	2.使用 th:utext="${属性名}" 获取对应的数据,可以将数据中html先解析在渲染到页面</span>
<span class="hljs-code">	3.使用 th:value="${属性名}" 获取数据直接作为表单元素value属性</span></code></pre>
<h3 id="展示对象数据">展示对象数据</h3>
<pre><code class="hljs java">model.addAttribute(<span class="hljs-string">"user"</span>,<span class="hljs-keyword">new</span> User(<span class="hljs-string">"21"</span>,<span class="hljs-string">"xiaochen"</span>,<span class="hljs-number">23</span>,<span class="hljs-keyword">new</span> Date()));</code></pre>
<pre><code class="hljs html">id:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.id}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
name:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.name}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
age:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.age}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
bir: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.bir}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  ====  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${#dates.format(user.bir, 'yyyy-MM-dd HH:mm')}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> 日期格式化</code></pre>
<h3 id="条件展示数据">条件展示数据</h3>
<pre><code class="hljs java">model.addAttribute(<span class="hljs-string">"user"</span>,<span class="hljs-keyword">new</span> User(<span class="hljs-string">"21"</span>,<span class="hljs-string">"xiaochen"</span>,<span class="hljs-number">23</span>,<span class="hljs-keyword">new</span> Date()));</code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">"${user.age} eq 23"</span>&gt;</span>
  青年
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
<pre><code class="hljs markdown"><span class="hljs-section"># 运算符</span>
<span class="hljs-code">    gt：great than（大于）&gt;</span>
<span class="hljs-code">    ge：great equal（大于等于）&gt;=</span>
<span class="hljs-code">    eq：equal（等于）==</span>
<span class="hljs-code">    lt：less than（小于）&lt;</span>
<span class="hljs-code">    le：less equal（小于等于）&lt;=</span>
<span class="hljs-code">    ne：not equal（不等于）!=</span></code></pre>
<h3 id="展示多条数据">展示多条数据</h3>
<ul>
<li>直接遍历集合</li>
</ul>
<pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"user:${users}"</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.id}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.name}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.age}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${#dates.format(user.bir,'yyyy-MM-dd')}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
<ul>
<li>遍历时获取遍历状态</li>
</ul>
<pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"user,userStat:${users}"</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${userStat.count}"</span>/&gt;</span>-<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.id}"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>   获取遍历次数  count 从1开始 index 从0开始
   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${userStat.odd}"</span>/&gt;</span>-<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.name}"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>   获取当前遍历是否是奇数行
   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${userStat.even}"</span>/&gt;</span>-<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.age}"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>   获取当前遍历是否是偶数行
   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${userStat.size}"</span>/&gt;</span>-<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${user.bir}"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>   获取当前集合的总条数
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
<h3 id="引入静态资源">引入静态资源</h3>
<p><code>使用thymeleaf模板项目中静态资源默认放在resources路径小static目录中</code></p>
<ul>
<li>
<p>项目中放入对应静态资源</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/image-20200323142307411.png" alt="image-20200323142307411" style="zoom:200%;">
</li>
<li>
<p>页面中引入</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/css/index.css}"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/js/jquery-min.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot多环境切换</title>
    <url>/2020/08/01/springboot/Springboot%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/dunes-5568253_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot多环境切换</h1>
<h2 id="好处">好处</h2>
<ol>
<li>
<p>不同环境配置可以配置不同的参数,不用来回改参数</p>
</li>
<li>
<p>便于部署，提高效率，减少出错</p>
</li>
</ol>
<h2 id="步骤">步骤</h2>
<p>在默认文件中 <code>application.yml</code>  中 配置切换属性：</p>
<pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">profiles:</span>
    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span></code></pre>
<p>新建 <code>application-dev.yml</code> 文件：</p>
<pre><code class="hljs yml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">这是开发环境</span></code></pre>
<p>启动后看到：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301185125610.png" alt="image-20210301185125610"></p>
<p>说明环境切换成功。</p>
<p>同理可以新建多个配置文件，<code>yml 配置方式</code>会自动识别。只需在默认的 <code>application.yml</code> 切换即可。</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger入门</title>
    <url>/2020/08/08/springboot/Swagger/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/tree-838667_1280.jpg" alt=""></p>
<hr>
<h1>Swagger入门</h1>
<p>学习目标：</p>
<ul>
<li>了解Swagger的作用和概念</li>
<li>了解前后端分离的概念</li>
<li>在Springboot中集成Swagger</li>
</ul>
<h2 id="Swagger简介">Swagger简介</h2>
<p>前后端分离：vue+springboot</p>
<ul>
<li>后端：控制层+服务层+数据访问层</li>
<li>前端：前端控制层+视图层</li>
</ul>
<p>前后端的好处：相对独立，松耦合，可以部署在不同的服务器。之间通过API接口通信</p>
<p>问题：</p>
<ul>
<li>前后端在集成协调的时候，无法做到"及时沟通，尽早解决"（由于两端都是独立开发），最终会导致问题集中爆发。</li>
</ul>
<p>解决方案：</p>
<ul>
<li>指定计划的提纲（schema），实时更新最新的API，降低集成的风险</li>
<li>早些年：使用word文档，不是很方便，对文档编写有一定的要求</li>
<li>前后端分离：
<ul>
<li>测试接口工具：postman（不推荐再使用了）</li>
<li>后端提供接口，需要实时更新最新的改动</li>
</ul>
</li>
</ul>
<h2 id="Swagger">Swagger</h2>
<p>号称世界上最流行的 API框架，可以实现 API 与 API文档实时更新，支持多种语言（java，php…），直接运行可以在线测试接口。</p>
<p><a class="link" href="https://swagger.io/">swagger官网<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210228101919079.png" alt="image-20210228101919079"></p>
<h3 id="SpringFox-3-0-0-发布">SpringFox 3.0.0 发布</h3>
<p>此版本的亮点：</p>
<blockquote>
<p>Spring5，Webflux支持（仅支持请求映射，尚不支持功能端点）。<br>
Spring Integration支持。<br>
SpringBoot支持springfox Boot starter依赖性（零配置、自动配置支持）。<br>
支持OpenApi 3.0.3。<br>
零依赖。几乎只需要spring-plugin，swagger-core ，现有的swagger2注释将继续工作并丰富openapi3.0规范。</p>
</blockquote>
<p>兼容性说明：</p>
<blockquote>
<p>需要Java 8<br>
需要Spring5.x（未在早期版本中测试）<br>
需要SpringBoot 2.2+（未在早期版本中测试）</p>
</blockquote>
<h3 id="swagger3-0-与2-xx配置差异">swagger3.0 与2.xx配置差异</h3>
<ol>
<li>应用主类（即Controller层）添加注解<code>@EnableOpenApi (swagger2是@EnableSwagger2)</code>。swagger配置类<code>SwaggerProperties.class</code>，与swagger2.xx 版本有差异。自定义一个配置类 <code>SwaggerConfiguration.class</code></li>
<li>访问地址：<a class="link" href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html<i class="fas fa-external-link-alt"></i></a> (swagger2.xx版本访问的地址为http://localhost:8080/swagger-ui.html)</li>
</ol>
<h2 id="Springboot集成Swagger">Springboot集成Swagger</h2>
<p>新建springboot   web 项目</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210228102748582.png" alt="image-20210228102748582"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210228102207420.png" alt="image-20210228102207420"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210228102317842.png" alt="image-20210228102317842"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210228103855243.png" alt="image-20210228103855243"></p>
<p>导入相关依赖</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<p>编写测试代码</p>
<pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>{

    <span class="hljs-meta">@GetMapping("/hello")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;
    }
}</code></pre>
<p>配置Swagger</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210228104926484.png" alt="image-20210228104926484"></p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfig</span> </span>{
    
}</code></pre>
<p>测试访问：<a class="link" href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html<i class="fas fa-external-link-alt"></i></a></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210228110125566.png" alt="image-20210228110125566"></p>
<h2 id="配置Swagger">配置Swagger</h2>
<h3 id="修改Swagger信息">修改Swagger信息</h3>
<p>配置的关键是配置一个关键类 <code>Docket</code></p>
<p>点击 <code>ctrl</code> 进入查看 <code>Docket</code>，在点击进入 <code>ApiInfo.</code> 可以看到默认的配置信息</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301172604042.png" alt="image-20210301172604042"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301172619931.png" alt="image-20210301172619931"></p>
<p>因此配置代码为：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{

    <span class="hljs-comment">//从配置文件中注入值</span>
    <span class="hljs-meta">@Value("${swagger.application-name}")</span>
    <span class="hljs-keyword">private</span> String title;
    <span class="hljs-meta">@Value("${swagger.enable}")</span>
    <span class="hljs-keyword">private</span> Boolean swaggerEnabled;
    <span class="hljs-meta">@Value("${swagger.application-description}")</span>
    <span class="hljs-keyword">private</span> String description;
    <span class="hljs-meta">@Value("${swagger.name}")</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@Value("${swagger.url}")</span>
    <span class="hljs-keyword">private</span> String url;
    <span class="hljs-meta">@Value("${swagger.email}")</span>
    <span class="hljs-keyword">private</span> String email;
    <span class="hljs-meta">@Value("${swagger.version}")</span>
    <span class="hljs-keyword">private</span> String version;
    <span class="hljs-meta">@Value("${swagger.try-host}")</span>
    <span class="hljs-keyword">private</span> String host;


    <span class="hljs-meta">@Bean</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">         * DocumentationType.OAS_30  "openApi", "3.0"</span>
<span class="hljs-comment">         * .host(host)  默认主机</span>
<span class="hljs-comment">         */</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30).apiInfo(apiInfo())
                .host(host)
                <span class="hljs-comment">// 是否开启</span>
                .enable(swaggerEnabled).select()
                .build();
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title">apiInfo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiInfoBuilder()
                .title(title)
                .description(description)
                <span class="hljs-comment">// 作者信息</span>
                .contact(<span class="hljs-keyword">new</span> Contact(name, url, email))
                .version(version)
                .build();
    }
}</code></pre>
<p>这里是从 <code>application.yml</code> 配置文件中读取事先定义的值：</p>
<pre><code class="hljs java">spring:
  application:
    name: 这是Swagger应用的名字
server:
  port: <span class="hljs-number">8080</span>

# ===== 自定义swagger配置 ===== #
swagger:
  enable: <span class="hljs-keyword">true</span>
  application-name: ${spring.application.name}
  application-version: <span class="hljs-number">1.0</span>
  application-description: springfox swagger <span class="hljs-number">3.0</span>整合Demo（这里配置项目的描述）
  <span class="hljs-keyword">try</span>-host: http:<span class="hljs-comment">//localhost:${server.port}</span>
  name: 项目负责人
  email: <span class="hljs-number">142342423</span><span class="hljs-meta">@qq</span>.com
  url: http:<span class="hljs-comment">//www.baidu.com</span>
  version: <span class="hljs-number">2.3</span><span class="hljs-number">.4</span>
</code></pre>
<p>查看  <code>ApiInfoBuilder</code> 可以查看更多的配置信息</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301180154288.png" alt="image-20210301180154288"></p>
<p>效果：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301172838848.png" alt="image-20210301172838848"></p>
<h3 id="配置扫描路径">配置扫描路径</h3>
<p><code>any()：</code>扫描全部</p>
<p><code>none()：</code>都不扫描</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301181141539.png" alt="image-20210301181141539"></p>
<h4 id="包扫描">包扫描</h4>
<pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30).apiInfo(apiInfo())
                .host(host)
                <span class="hljs-comment">// 是否开启</span>
                .enable(swaggerEnabled).select()
                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"com.example.swaggerdemo.controller"</span>))
                .build();</code></pre>
<h4 id="类注解扫描">类注解扫描</h4>
<pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30).apiInfo(apiInfo())
                .host(host)
                <span class="hljs-comment">// 是否开启</span>
                .enable(swaggerEnabled).select()
                .apis(RequestHandlerSelectors.withClassAnnotation(RestController.class))
                .build();</code></pre>
<h4 id="方法注解扫描">方法注解扫描</h4>
<pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30).apiInfo(apiInfo())
                .host(host)
                <span class="hljs-comment">// 是否开启</span>
                .enable(swaggerEnabled).select()
                .apis(RequestHandlerSelectors.withMethodAnnotation(GetMapping.class))
                .build();</code></pre>
<h4 id="效果">效果</h4>
<p>没有了 <code>error</code>  的默认接口，只显示自己写的接口：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301181946804.png" alt="image-20210301181946804"></p>
<h3 id="配置过滤路径">配置过滤路径</h3>
<pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30).apiInfo(apiInfo())
               .host(host)
               <span class="hljs-comment">// 是否开启</span>
               .enable(swaggerEnabled).select()
               .paths(PathSelectors.ant(<span class="hljs-string">"/hello/**"</span>))
               .build();</code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301182510169.png" alt="image-20210301182510169"></p>
<h3 id="配置Swagger的API分组">配置Swagger的API分组</h3>
<p>关键：Docket有个分组方法，但是只能配置一个分组</p>
<pre><code class="hljs java">.groupName(<span class="hljs-string">"A"</span>)</code></pre>
<p>因此要配置多个分组，只需要注入多个 Docket 实例：</p>
<pre><code class="hljs java">
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket1</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30).groupName(<span class="hljs-string">"B"</span>);
}
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket2</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30).groupName(<span class="hljs-string">"C"</span>);
}
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">createRestApi</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * DocumentationType.OAS_30  "openApi", "3.0"</span>
<span class="hljs-comment">     * .host(host)  默认主机</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.OAS_30).apiInfo(apiInfo())
            .host(host)
            .groupName(<span class="hljs-string">"A"</span>)
            <span class="hljs-comment">// 是否开启</span>
            .enable(swaggerEnabled).select()
            .paths(PathSelectors.ant(<span class="hljs-string">"/hello/**"</span>))
            .build();
}
</code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301190020294.png" alt="image-20210301190020294"></p>
<h3 id="配置接口注释">配置接口注释</h3>
<p><code>@Api：</code>用在controller类，描述API接口<br>
<code>@ApiOperation：</code>描述接口方法<br>
<code>@ApiModel：</code>描述对象<br>
<code>@ApiModelProperty：</code>描述对象属性<br>
<code>@ApiImplicitParams：</code>描述接口参数<br>
<code>@ApiResponses：</code>描述接口响应</p>
<p>新建实体类 <code>User</code></p>
<pre><code class="hljs java"><span class="hljs-meta">@ApiModel("关于实体类的描述")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
    <span class="hljs-meta">@ApiModelProperty("关于实体类属性的描述")</span>
    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-meta">@ApiModelProperty("关于实体类属性的描述")</span>
    <span class="hljs-keyword">private</span> String password;
<span class="hljs-comment">//    public User(String username,String password){</span>
<span class="hljs-comment">//        this.username = username;</span>
<span class="hljs-comment">//        this.password = password;</span>
<span class="hljs-comment">//    }</span>
<span class="hljs-comment">//    public User(){</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    }</span>
}</code></pre>
<p>新建接口</p>
<pre><code class="hljs java"><span class="hljs-meta">@GetMapping("/hello")</span>
    <span class="hljs-meta">@ApiOperation("描述接口方法")</span>
    <span class="hljs-meta">@ApiImplicitParams({</span>
<span class="hljs-meta">            @ApiImplicitParam(name="name",value="姓名",dataTypeClass = String.class,required = true)</span>
<span class="hljs-meta">    })</span>
    <span class="hljs-meta">@ApiResponses({</span>
<span class="hljs-meta">            @ApiResponse(code = 200, message = "请求成功"),</span>
<span class="hljs-meta">            @ApiResponse(code = 400, message = "请求参数没填好"),</span>
<span class="hljs-meta">            @ApiResponse(code = 404, message = "请求路径没有或页面跳转路径不对")</span>
<span class="hljs-meta">    })</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String name)</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();
    }</code></pre>
<p>效果：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301193506582.png" alt="image-20210301193506582"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301193519108.png" alt="image-20210301193519108"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210301193532477.png" alt="image-20210301193532477"></p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Swagger</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC入门01环境配置和原理</title>
    <url>/2020/02/01/springmvc/SpringMVC%E5%85%A5%E9%97%A801%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2021/02/10/22/23/lake-6003746_1280.jpg" alt=""></p>
<hr>
<h1>SpringMVC入门01环境配置和原理</h1>
<h2 id="1-SpringMVC概述">1. SpringMVC概述</h2>
<p>SpringMVC 是一种基于 Java 的实现 <code>MVC</code> 设计模型的请求驱动类型的轻量级 Web 框架。</p>
<ol>
<li>
<p>属于 SpringFrameWork 的后续产品，已经融合在 <code>Spring Web Flow</code> 里面。</p>
</li>
<li>
<p>其他 MVC 开发框架，如 Struts1(现在一般不用)， Struts2 等。</p>
</li>
<li>
<p>SpringMVC 已经成为目前最主流的 MVC 框架之一， 并且随着 Spring3.0 的发布， 全面超越 Struts2，成为最优秀的 MVC 框架。</p>
</li>
<li>
<p>同时它还支持<code>RESTful 编程风格的请求</code>。</p>
</li>
</ol>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springmvc01/image-20200530104715043.png" alt="image-20200530104715043" style="zoom: 80%;">
<hr>
<h2 id="2-SpringMVC-环境配置">2. SpringMVC 环境配置</h2>
<h3 id="2-1-创建WEB工程，引入开发的jar包">2.1. 创建WEB工程，引入开发的jar包</h3>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 版本锁定 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${spring.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre>
<h3 id="2-2-配置核心的控制器（配置DispatcherServlet）">2.2. 配置核心的控制器（配置DispatcherServlet）</h3>
<p>在web.xml配置文件中<code>核心控制器DispatcherServlet </code></p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringMVC的核心控制器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servletclass</span>&gt;</span>
    
<span class="hljs-comment">&lt;!-- 配置Servlet的初始化参数，读取springmvc的配置文件，创建spring容器 --&gt;</span> 
<span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
    
<span class="hljs-comment">&lt;!-- 配置servlet启动时加载对象 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre>
<p>编写<code>springmvc.xml</code>的配置文件</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">"http://www.springframework.org/schema/mvc"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/mvc</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置spring创建容器时要扫描的包 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.itheima"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置视图解析器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/pages/"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置spring开启注解mvc的支持</span>
<span class="hljs-comment">&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
<h2 id="3-SpringMVC原理">3. SpringMVC原理</h2>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springmvc01/image-20200530110340704.png" alt="image-20200530110340704"></p>
<hr>
<ol>
<li>服务器启动，应用被加载。 读取到 web.xml 中的配置创建 spring 容器并且初始化容器中的对象。从入门案例中可以看到的是： <code>HelloController</code> 和 <code>InternalResourceViewResolver</code>，但是远不止这些。</li>
<li>浏览器发送请求，被 <code>DispatherServlet</code> 捕获，该 Servlet 并不处理请求，而是把请求转发出去。转发的路径是根据请求 URL，匹配<code>@RequestMapping</code> 中的内容。</li>
<li>匹配到了后，执行对应方法。该方法有一个返回值。</li>
<li>根据方法的返回值，借助 <code>InternalResourceViewResolver</code> 找到对应的结果视图。</li>
<li>渲染结果视图，响应浏览器。</li>
</ol>
<h2 id="4-请求参数的绑定">4. 请求参数的绑定</h2>
<h3 id="4-1-参数绑定机制">4.1 参数绑定机制</h3>
<p>表单中请求参数都是基于 <code>key=value</code> 的 。SpringMVC 绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的  。</p>
<p>支持的数据类型：</p>
<ol>
<li>基本类型和 String 类型  :参数名称必须和控制器中方法的形参名称保持一致。 (严格区分大小写)</li>
<li>实体类，以及关联的实体类：  参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。</li>
<li><code>List 结构和 Map 结构的集合（包括数组）</code>  ：
<ol>
<li>第一种：<br>
要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。<br>
给 List 集合中的元素赋值， 使用下标。<br>
给 Map 集合中的元素赋值， 使用键值对。</li>
<li>第二种：<br>
接收的请求参数是 json 格式数据。需要借助一个注解实现。</li>
</ol>
</li>
</ol>
<p>它还可以实现一些数据类型自动转换。 内置转换器全都在  <code>org.springframework.core.convert.support</code> 包下</p>
<p>如遇特殊类型转换要求，需要我们自己编写自定义类型转换器  。</p>
<h4 id="4-1-1-自定义转换器">4.1.1 自定义转换器</h4>
<p>第一步：定义一个类，实现 Converter 接口，该接口有两个泛型。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">S</span>, <span class="hljs-title">T</span>&gt; </span>{<span class="hljs-comment">//S:表示接受的类型， T：表示目标类型</span>
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 实现类型转换的方法</span>
<span class="hljs-comment">*/</span>
Nullable
<span class="hljs-function">T <span class="hljs-title">convert</span><span class="hljs-params">(S source)</span></span>;
}
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 自定义类型转换器</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringToDateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Converter</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Date</span>&gt; </span>{
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 用于把 String 类型转成日期类型</span>
<span class="hljs-comment">*/</span>
Override
<span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">convert</span><span class="hljs-params">(String source)</span> </span>{
DateFormat format = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">try</span> {
<span class="hljs-keyword">if</span>(StringUtils.isEmpty(source)) {
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"请输入要转换的日期"</span>);
}
format = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>);
Date date = format.parse(source);
<span class="hljs-keyword">return</span> date;
} <span class="hljs-keyword">catch</span> (Exception e) {
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入日期有误"</span>);
}
}
}</code></pre>
<p>第二步：在 spring 配置文件中配置类型转换器。<br>
spring 配置类型转换器的机制是，将自定义的转换器注册到类型转换服务中去。</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置类型转换器工厂 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"converterService"</span></span>
<span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 给工厂注入一个新的类型转换器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"converters"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 配置自定义类型转换器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.web.converter.StringToDateConverter"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre>
<p>第三步：在 annotation-driven 标签中引用配置的类型转换服务</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引用自定义类型转换器 --&gt;</span>
&lt;mvc:annotation-driven
conversion-service="converterService"&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></code></pre>
<h3 id="4-2-请求参数乱码问题">4.2 请求参数乱码问题</h3>
<p>post 请求方式：<br>
在 <code>web.xml</code> 中配置一个过滤器</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置 springMVC 编码过滤器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>
org.springframework.web.filter.CharacterEncodingFilter
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>  
 <span class="hljs-comment">&lt;!-- 设置过滤器中的属性值 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 启动过滤器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 过滤所有请求 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span>
</code></pre>
<p>在 springmvc 的配置文件中可以配置，静态资源不过滤：</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- location 表示路径， mapping 表示文件， **表示该目录下的文件以及子目录的文件 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/css/"</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/css/**"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/images/"</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/images/**"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/scripts/"</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/javascript/**"</span>/&gt;</span></code></pre>
<p>get 请求方式：tomacat 对 GET 和 POST 请求处理方式是不同的， GET 请求的编码问题， 要改 tomcat 的 <code>server.xml</code><br>
配置文件，如下：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span>/&gt;</span>
改为：
<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span></span>
<span class="hljs-tag"></span>
<span class="hljs-tag"><span class="hljs-attr">useBodyEncodingForURI</span>=<span class="hljs-string">"true"</span>/&gt;</span>

如果遇到 ajax 请求仍然乱码，请把：

useBodyEncodingForURI="true"改为 URIEncoding="UTF-8"

即可。  
</code></pre>
<h3 id="4-3-使用-ServletAPI-对象作为方法参数">4.3 使用 ServletAPI 对象作为方法参数</h3>
<p>SpringMVC 还支持使用原始 ServletAPI 对象作为控制器方法的参数。支持原始 <code>ServletAPI</code> 对象有：</p>
<ul>
<li>
<p>HttpServletRequest，HttpServletResponse，HttpSession</p>
</li>
<li>
<p>java.security.Principal</p>
</li>
<li>
<p>Locale</p>
</li>
<li>
<p>InputStream，OutputStream，Reader，Writer</p>
<p>我们可以把上述对象，直接写在控制的方法参数中使用。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringMVC框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC入门03实现文件上传</title>
    <url>/2020/02/03/springmvc/SpringMVC%E5%85%A5%E9%97%A803%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2015/09/09/16/05/forest-931706_1280.jpg" alt=""></p>
<hr>
<h1>SpringMVC入门03实现文件上传</h1>
<h2 id="1-1-文件上传的必要前提">1.1 文件上传的必要前提</h2>
<ol>
<li>
<p>form 表单的 enctype 取值必须是： <code>multipart/form-data</code> (默认值是:<code>application/x-www-form-urlencoded</code>)<br>
enctype:是表单请求正文的类型</p>
</li>
<li>
<p>method 属性取值必须是<code> POST</code></p>
</li>
<li>
<p>提供一个文件选择域<code>&lt;input type="file" /&gt;  </code></p>
</li>
<li>
<p>导包</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--文件上传解析依赖--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
</li>
</ol>
<h2 id="1-2-文件上传的原理分析">1.2 文件上传的原理分析</h2>
<p>当 form 表单的 enctype 取值不是默认值后， request.getParameter()将失效。<br>
<code>enctype=”application/x-www-form-urlencoded”</code>时， form 表单的正文内容是：</p>
<pre><code class="hljs java">key=value&amp;key=value&amp;key=value</code></pre>
<p>当 form 表单的 enctype 取值为 <code>Mutilpart/form-data</code> 时，请求正文内容就变成：<br>
每一部分都是 MIME 类型描述的正文</p>
<pre><code class="hljs pgsql"><span class="hljs-comment">-----------------------------7de1a433602ac                                                    分界符</span>
Content-Disposition: form-data; <span class="hljs-type">name</span>="userName"                                     协议头  

aaa 																																协议的正文
<span class="hljs-comment">-----------------------------7de1a433602ac</span>
Content-Disposition: form-data; <span class="hljs-type">name</span>="file";
filename="C:\Users\zhy\Desktop\fileupload_demofile\b.txt"
Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/plain 																						协议的类型（ MIME 类型）
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
<span class="hljs-comment">-----------------------------7de1a433602ac--  </span></code></pre>
<h2 id="1-3-springmvc-传统方式的文件上传">1.3 springmvc 传统方式的文件上传</h2>
<p>传统方式的文件上传， 指的是我们上传的文件和访问的应用存在于同一台服务器上。</p>
<pre><code class="hljs jsp">&lt;form action=<span class="hljs-string">"/fileUpload"</span> method=<span class="hljs-string">"post"</span> enctype=<span class="hljs-string">"multipart/form-data"</span>&gt;
名称： &lt;input type=<span class="hljs-string">"text"</span> name=<span class="hljs-string">"picname"</span>/&gt;&lt;br/&gt;
图片： &lt;input type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"uploadFile"</span>/&gt;&lt;br/&gt;
&lt;input type=<span class="hljs-string">"submit"</span> value=<span class="hljs-string">"上传"</span>/&gt;
&lt;/form&gt;</code></pre>
<pre><code class="hljs java"><span class="hljs-meta">@Controller("fileUploadController")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController</span> </span>{
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 文件上传</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@RequestMapping("/fileUpload")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testResponseJson</span><span class="hljs-params">(String picname,MultipartFile</span></span>
<span class="hljs-function"><span class="hljs-params">uploadFile,HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception</span>{
<span class="hljs-comment">//定义文件名</span>
String fileName = <span class="hljs-string">""</span>;
<span class="hljs-comment">//1.获取原始文件名</span>
String uploadFileName = uploadFile.getOriginalFilename();
<span class="hljs-comment">//2.截取文件扩展名</span>
String extendName =
uploadFileName.substring(uploadFileName.lastIndexOf(<span class="hljs-string">"."</span>)+<span class="hljs-number">1</span>,
uploadFileName.length());
<span class="hljs-comment">//3.把文件加上随机数，防止文件重复</span>
String uuid = UUID.randomUUID().toString().replace(<span class="hljs-string">"-"</span>, <span class="hljs-string">""</span>).toUpperCase();
<span class="hljs-comment">//4.判断是否输入了文件名</span>
<span class="hljs-keyword">if</span>(!StringUtils.isEmpty(picname)) {
fileName = uuid+<span class="hljs-string">"_"</span>+picname+<span class="hljs-string">"."</span>+extendName;
}<span class="hljs-keyword">else</span> {
fileName = uuid+<span class="hljs-string">"_"</span>+uploadFileName;
}
System.out.println(fileName);
<span class="hljs-comment">//2.获取文件路径</span>
ServletContext context = request.getServletContext();
String basePath = context.getRealPath(<span class="hljs-string">"/uploads"</span>);
<span class="hljs-comment">//3.解决同一文件夹中文件过多问题</span>
String datePath = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>).format(<span class="hljs-keyword">new</span> Date());
<span class="hljs-comment">//4.判断路径是否存在</span>
File file = <span class="hljs-keyword">new</span> File(basePath+<span class="hljs-string">"/"</span>+datePath);
<span class="hljs-keyword">if</span>(!file.exists()) {
file.mkdirs();
}
<span class="hljs-comment">//5.使用 MulitpartFile 接口中方法，把上传的文件写到指定位置</span>
uploadFile.transferTo(<span class="hljs-keyword">new</span> File(file,fileName));
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}
}</code></pre>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置文件上传解析器 --&gt;</span>
&lt;bean id="multipartResolver" &lt;!-- id 的值是固定的--&gt;
class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;
<span class="hljs-comment">&lt;!-- 设置上传文件的最大尺寸为 5MB --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"maxUploadSize"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>5242880<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
注意：
文件上传的解析器 id 是固定的，不能起别的名称，否则无法实现请求参数的绑定。（不光是文件，其他
字段也将无法绑定</code></pre>
<h2 id="1-4-springmvc-跨服务器方式的文件上传">1.4 springmvc 跨服务器方式的文件上传</h2>
<p>在实际开发中，我们会有很多处理不同功能的服务器。例如：</p>
<ul>
<li>应用服务器：负责部署我们的应用</li>
<li>数据库服务器：运行我们的数据库</li>
<li>缓存和消息服务器：负责处理大并发访问的缓存和消息</li>
<li>文件服务器：负责存储用户上传文件的服务器</li>
</ul>
<p>准备两个 tomcat 服务器，并创建一个用于存放图片的 web 工程</p>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springmvc01/image-20200601213408107.png" alt="image-20200601213408107" style="zoom:67%;">
<hr>
<p>导入依赖</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  跨文件上传所需的依赖--&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.jersey<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jersey-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.jersey<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jersey-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--文件上传解析依赖--&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<p>编写控制器实现上传图片</p>
<pre><code class="hljs java"><span class="hljs-meta">@Controller("fileUploadController2")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController2</span> </span>{
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FILESERVERURL =
<span class="hljs-string">"http://localhost:9090/day06_spring_image/uploads/"</span>;
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 文件上传，保存文件到不同服务器</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@RequestMapping("/fileUpload2")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testResponseJson</span><span class="hljs-params">(String picname,MultipartFile uploadFile)</span> <span class="hljs-keyword">throws</span></span>
<span class="hljs-function">    Exception</span>{
<span class="hljs-comment">//定义文件名</span>
String fileName = <span class="hljs-string">""</span>;
<span class="hljs-comment">//1.获取原始文件名</span>
String uploadFileName = uploadFile.getOriginalFilename();
<span class="hljs-comment">//2.截取文件扩展名</span>
String extendName =
uploadFileName.substring(uploadFileName.lastIndexOf(<span class="hljs-string">"."</span>)+<span class="hljs-number">1</span>,
uploadFileName.length());
<span class="hljs-comment">//3.把文件加上随机数，防止文件重复</span>
String uuid = UUID.randomUUID().toString().replace(<span class="hljs-string">"-"</span>, <span class="hljs-string">""</span>).toUpperCase();
<span class="hljs-comment">//4.判断是否输入了文件名</span>
<span class="hljs-keyword">if</span>(!StringUtils.isEmpty(picname)) {
fileName = uuid+<span class="hljs-string">"_"</span>+picname+<span class="hljs-string">"."</span>+extendName;
}<span class="hljs-keyword">else</span> {
fileName = uuid+<span class="hljs-string">"_"</span>+uploadFileName;
}
System.out.println(fileName);
<span class="hljs-comment">//5.创建 sun 公司提供的 jersey 包中的 Client 对象</span>
Client client = Client.create();
<span class="hljs-comment">//6.指定上传文件的地址，该地址是 web 路径</span>
WebResource resource = client.resource(FILESERVERURL+fileName);
<span class="hljs-comment">//7.实现上传</span>
String result = resource.put(String.class,uploadFile.getBytes());
System.out.println(result);
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}
}</code></pre>
<p>编写 jsp 页面 和 配置文件上传解析器，略。。。。</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringMVC框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC入门04异常处理和拦截器</title>
    <url>/2020/02/04/springmvc/SpringMVC%E5%85%A5%E9%97%A804%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2015/06/19/21/24/the-road-815297_1280.jpg" alt=""></p>
<hr>
<h1>SpringMVC入门04异常处理和拦截器</h1>
<h2 id="1-SpringMVC-中的异常处理">1. SpringMVC 中的异常处理</h2>
<h3 id="1-1-异常处理的思路">1.1 异常处理的思路</h3>
<p>系统中异常包括两类：预期异常和运行时异常 <code>RuntimeException</code>，前者通过捕获异常从而获取异常信息，<br>
后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。<br>
系统的 <code>dao、 service、 controller</code> 出现都通过 <code>throws Exception</code> 向上抛出，最后由 <code>springmvc 前端</code><br>
控制器交由异常处理器进行异常处理，如下图：</p>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springmvc01/image-20200601213930767.png" alt="image-20200601213930767" style="zoom:50%;">
<hr>
<h3 id="1-2-异常处理实例">1.2 异常处理实例</h3>
<p>编写异常类和错误页面</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 自定义异常</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>{
<span class="hljs-keyword">private</span> String message;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomException</span><span class="hljs-params">(String message)</span> </span>{
<span class="hljs-keyword">this</span>.message = message;
}
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">return</span> message;
}
}

jsp 页面：error.jsp
&lt;%@ page language=<span class="hljs-string">"java"</span> contentType=<span class="hljs-string">"text/html; charset=UTF-8"</span>
pageEncoding=<span class="hljs-string">"UTF-8"</span>%&gt;
&lt;!DOCTYPE html PUBLIC <span class="hljs-string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>
<span class="hljs-string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=<span class="hljs-string">"Content-Type"</span> content=<span class="hljs-string">"text/html; charset=UTF-8"</span>&gt;
&lt;title&gt;执行失败&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
执行失败！
${message }
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>自定义异常处理器</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 自定义异常处理器</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomExceptionResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>{
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request,</span></span>
<span class="hljs-function"><span class="hljs-params">HttpServletResponse response, Object handler, Exception ex)</span> </span>{
ex.printStackTrace();
CustomException customException = <span class="hljs-keyword">null</span>;
<span class="hljs-comment">//如果抛出的是系统自定义异常则直接转换</span>
<span class="hljs-keyword">if</span>(ex <span class="hljs-keyword">instanceof</span> CustomException){
customException = (CustomException)ex;
}<span class="hljs-keyword">else</span>{
<span class="hljs-comment">//如果抛出的不是系统自定义异常则重新构造一个系统错误异常。</span>
customException = <span class="hljs-keyword">new</span> CustomException(<span class="hljs-string">"系统错误，请与系统管理 员联系！ "</span>);
}
ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();
modelAndView.addObject(<span class="hljs-string">"message"</span>, customException.getMessage());
modelAndView.setViewName(<span class="hljs-string">"error"</span>);
<span class="hljs-keyword">return</span> modelAndView;
}
}</code></pre>
<p>配置异常处理器</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置自定义异常处理器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"handlerExceptionResolver"</span></span>
<span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.exception.CustomExceptionResolver"</span>/&gt;</span></code></pre>
<h2 id="2-SpringMVC-中的拦截器">2. SpringMVC 中的拦截器</h2>
<h3 id="2-1-拦截器的作用">2.1 拦截器的作用</h3>
<p>Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。用户可以自己定义一些拦截器来实现特定的功能。<br>
谈到拦截器，还要向大家提一个词——拦截器链<code>（Interceptor Chain）</code>。拦截器链就是将拦截器按一定的顺<br>
序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。<br>
说到这里，可能大家脑海中有了一个疑问，这不是我们之前学的过滤器吗？是的它和过滤器是有几分相似，但<br>
是也有区别，接下来我们就来说说他们的区别：</p>
<ol>
<li>过滤器是 servlet 规范中的一部分， 任何 java web 工程都可以使用。</li>
<li>拦截器是 <code>SpringMVC 框架</code>自己的，只有使用了 SpringMVC 框架的工程才能用。</li>
<li>过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。</li>
<li>拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp， html,css,image 或者 js 是不会进行拦截的。它也是 AOP 思想的具体应用。</li>
<li>我们要想自定义拦截器， 要求必须实现： <code>HandlerInterceptor 接口</code>。</li>
</ol>
<h3 id="2-2-自定义拦截器的步骤">2.2 自定义拦截器的步骤</h3>
<p>第一步：编写一个普通类实现 HandlerInterceptor 接口</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerInterceptorDemo1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>{
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse</span></span>
<span class="hljs-function"><span class="hljs-params">response, Object handler)</span></span>
<span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>{
System.out.println(<span class="hljs-string">"preHandle 拦截器拦截了"</span>);
<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span>
<span class="hljs-function"><span class="hljs-params">Object handler，ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>{
System.out.println(<span class="hljs-string">"postHandle 方法执行了"</span>);
}
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse</span></span>
<span class="hljs-function"><span class="hljs-params">response, Object handler, Exception ex)</span></span>
<span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>{
System.out.println(<span class="hljs-string">"afterCompletion 方法执行了"</span>);
}
}</code></pre>
<p>第二步：配置拦截器</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置拦截器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/**"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"handlerInterceptorDemo1"</span></span>
<span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.web.interceptor.HandlerInterceptorDemo1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></code></pre>
<h3 id="2-3-拦截器的细节">2.3 拦截器的细节</h3>
<p>拦截器的放行 ：放行的含义是指，如果有下一个拦截器就执行下一个，如果该拦截器处于拦截器链的最后一个，则执行控制器中的方法</p>
<p>拦截器中方法的说明  ：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerInterceptor</span> </span>{
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 如何调用：</span>
<span class="hljs-comment">* 按拦截器定义顺序调用</span>
<span class="hljs-comment">* 何时调用：</span>
<span class="hljs-comment">* 只要配置了都会调用</span>
<span class="hljs-comment">* 有什么用：</span>
<span class="hljs-comment">* 如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去</span>
<span class="hljs-comment">* 进行处理，则返回 true。</span>
<span class="hljs-comment">* 如果程序员决定不需要再调用其他的组件去处理请求，则返回 false。</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse</span></span>
<span class="hljs-function"><span class="hljs-params">response, Object handler)</span></span>
<span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>{
<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">* 如何调用：</span>
<span class="hljs-comment">* 按拦截器定义逆序调用</span>
<span class="hljs-comment">* 何时调用：</span>
<span class="hljs-comment">* 在拦截器链内所有拦截器返成功调用</span>
<span class="hljs-comment">* 有什么用：</span>
<span class="hljs-comment">* 在业务处理器处理完请求后，但是 DispatcherServlet 向客户端返回响应前被调用，</span>
<span class="hljs-comment">* 在该方法中对用户请求 request 进行处理。</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse</span></span>
<span class="hljs-function"><span class="hljs-params">response, Object handler,</span></span>
<span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Nullable</span> ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>{
}
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 如何调用：</span>
<span class="hljs-comment">* 按拦截器定义逆序调用</span>
<span class="hljs-comment">* 何时调用：</span>
<span class="hljs-comment">* 只有 preHandle 返回 true 才调用</span>
<span class="hljs-comment">* 有什么用：</span>
<span class="hljs-comment">* 在 DispatcherServlet 完全处理完请求后被调用，</span>
<span class="hljs-comment">* 可以在该方法中进行一些资源清理的操作。</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse</span></span>
<span class="hljs-function"><span class="hljs-params">response, Object handler,</span></span>
<span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Nullable</span> Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>{
}
}</code></pre>
<p>拦截器的作用路径</p>
<pre><code class="hljs xml">作用路径可以通过在配置文件中配置。
<span class="hljs-comment">&lt;!-- 配置拦截器的作用范围 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/**"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 用于指定对拦截的 url --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">""</span>/&gt;</span><span class="hljs-comment">&lt;!-- 用于指定排除的 url--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"handlerInterceptorDemo1"</span></span>
<span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">"com.itheima.web.interceptor.HandlerInterceptorDemo1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></code></pre>
<h3 id="2-4-拦截器实现登陆验证">2.4 拦截器实现登陆验证</h3>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span></span>{
<span class="hljs-meta">@Override</span>
<span class="hljs-function">Public <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request,</span></span>
<span class="hljs-function"><span class="hljs-params">HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>{
<span class="hljs-comment">//如果是登录页面则放行</span>
<span class="hljs-keyword">if</span>(request.getRequestURI().indexOf(<span class="hljs-string">"login.action"</span>)&gt;=<span class="hljs-number">0</span>){
<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
HttpSession session = request.getSession();
<span class="hljs-comment">//如果用户已登录也放行</span>
<span class="hljs-keyword">if</span>(session.getAttribute(<span class="hljs-string">"user"</span>)!=<span class="hljs-keyword">null</span>){
<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
<span class="hljs-comment">//用户没有登录挑战到登录页面</span>
request.getRequestDispatcher(<span class="hljs-string">"/WEB-INF/jsp/login.jsp"</span>).forward(request,
response);
<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
}</code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringMVC框架</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习笔记07-Promise和axios</title>
    <url>/2020/05/05/vue/Promise%E5%92%8Caxios/</url>
    <content><![CDATA[<h1>vue学习笔记07-Promise和axios</h1>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/forest-166733_1280.jpg" alt=""></p>
<hr>
<h1>Promise</h1>
<h2 id="什么是Promise">什么是Promise?</h2>
<p>ES6中一个非常重要和好用的特性就是Promise。但是初次接触Promise会一脸懵逼，这TM是什么东西？</p>
<p>看看官方或者一些文章对它的介绍和用法，也是一头雾水。</p>
<p><code>Promise到底是做什么的呢？Promise是异步编程的一种解决方案。</code></p>
<p>那什么时候我们会来处理异步事件呢？一种很常见的场景应该就是网络请求了。</p>
<p><code>我们封装一个网络请求的函数，因为不能立即拿到结果，所以不能像简单的3+4=7一样将结果返回。</code></p>
<p><code>所以往往我们会传入另外一个函数，在数据请求成功时，将数据通过传入的函数回调出去。</code></p>
<p>如果只是一个简单的网络请求，那么这种方案不会给我们带来很大的麻烦。但是，当网络请求非常复杂时，就会出现回调地狱。</p>
<h3 id="网络请求的回调地狱">网络请求的回调地狱</h3>
<p>我们来考虑下面的场景(有夸张的成分)：<br>
我们需要通过一个url1从服务器加载一个数据data1，data1中包含了下一个请求的url2<br>
我们需要通过data1取出url2，从服务器加载数据data2，data2中包含了下一个请求的url3<br>
我们需要通过data2取出url3，从服务器加载数据data3，data3中包含了下一个请求的url4<br>
发送网络请求url4，获取最终的数据data4</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001180021363.png" alt="image-20201001180021363"></p>
<p>上面的代码有什么问题吗？</p>
<p>正常情况下，不会有什么问题，可以正常运行并且获取我们想要的结果。<br>
<code>但是，这样额代码难看而且不容易维护。我们更加期望的是一种更加优雅的方式来进行这种异步操作。</code></p>
<p>如何做呢？就是使用Promise。Promise可以以一种非常优雅的方式来解决这个问题。</p>
<h2 id="Promise的使用">Promise的使用</h2>
<h3 id="定时器的异步事件">定时器的异步事件</h3>
<p>我们先来看看Promise最基本的语法。这里，我们用一个定时器来模拟异步事件：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001180144293.png" alt="image-20201001180144293"></p>
<p>假设下面的data是从网络上1秒后请求的数据console.log就是我们的处理方式。</p>
<p>这是我们过去的处理方式，我们将它换成Promise代码</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001180150141.png" alt="image-20201001180150141"></p>
<p>这个例子会让我们感觉脱裤放屁，多此一举</p>
<p>首先，下面的Promise代码明显比上面的代码看起来还要复杂。<br>
其次，下面的Promise代码中包含的resolve、reject、then、catch都是些什么东西？</p>
<p>我们先不管第一个复杂度的问题，因为这样的一个屁大点的程序根本看不出来Promise真正的作用。</p>
<h3 id="定时器异步事件解析">定时器异步事件解析</h3>
<p>我们先来认认真真的读一读这个程序到底做了什么？new Promise很明显是创建一个Promise对象</p>
<p>小括号中((resolve, reject) =&gt; {})也很明显就是一个函数，而且我们这里用的是之前刚刚学习过的箭头函数。<br>
但是resolve, reject它们是什么呢？</p>
<p>我们先知道一个事实：<code>在创建Promise时，传入的这个箭头函数是固定的（一般我们都会这样写）</code></p>
<p>resolve和reject它们两个也是函数，通常情况下，我们会根据请求数据的成功和失败来决定调用哪一个。<br>
成功还是失败？</p>
<p>如果是成功的，那么通常我们会调用resolve(messsage)，这个时候，我们后续的then会被回调。<br>
如果是失败的，那么通常我们会调用reject(error)，这个时候，我们后续的catch会被回调。</p>
<p>OK，这就是Promise最基本的使用了。</p>
<h3 id="Promise三种状态">Promise三种状态</h3>
<p>首先, 当我们开发中有异步操作时, 就可以给异步操作包装一个Promise<br>
异步操作之后会有三种状态我们一起来看一下这三种状态:</p>
<p>pending：等待状态，比如正在进行网络请求，或者定时器没有到时间。</p>
<p>fulfill：满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then()</p>
<p>reject：拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch()</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001180314041.png" alt="image-20201001180314041"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001180320624.png" alt="image-20201001180320624"></p>
<h2 id="Promise链式调用">Promise链式调用</h2>
<p>我们在看Promise的流程图时，发现无论是then还是catch都可以返回一个Promise对象。<br>
所以，我们的代码其实是可以进行链式调用的：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001180432443.png" alt="image-20201001180432443"></p>
<p>这里我们直接通过Promise包装了一下新的数据，将Promise对象返回了<br>
Promise.resovle()：将数据包装成Promise对象，并且在内部回调resolve()函数<br>
Promise.reject()：将数据包装成Promise对象，并且在内部回调reject()函数</p>
<h3 id="链式调用简写">链式调用简写</h3>
<p>简化版代码：<br>
如果我们希望数据直接包装成Promise.resolve，那么在then中可以直接返回数据<br>
注意下面的代码中，我讲return Promise.resovle(data)改成了return data<br>
结果依然是一样的</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001180530409.png" alt="image-20201001180530409"></p>
<h1>网络模块封装</h1>
<ul>
<li>常见的网络请求模块，以及优缺点对比。</li>
<li>JSONP的原理和封装
<ul>
<li>JSONP原理回顾</li>
<li>JSONP请求封装</li>
</ul>
</li>
<li>axios的内容详解
<ul>
<li>认识axios网络模块</li>
<li>发送基本请求</li>
<li>axios创建实例</li>
<li>axios拦截器的使用</li>
</ul>
</li>
</ul>
<h2 id="选择什么网络模块">选择什么网络模块?</h2>
<p>Vue中发送网络请求有非常多的方式, 那么, 在开发中, 如何选择呢?</p>
<p>选择一: 传统的Ajax是基于XMLHttpRequest(XHR)。为什么不用它呢?</p>
<p>非常好解释, 配置和调用方式等非常混乱。编码起来看起来就非常蛋疼。</p>
<p>所以真实开发中很少直接使用, 而是使用jQuery-Ajax</p>
<p>选择二: 在前面的学习中, 我们经常会使用jQuery-Ajax。相对于传统的Ajax非常好用.</p>
<p>为什么不选择它呢?首先, 我们先明确一点: 在Vue的整个开发中都是不需要使用jQuery了.</p>
<p>那么, 就意味着为了方便我们进行一个网络请求, 特意引用一个jQuery, 你觉得合理吗?<br>
jQuery的代码1w+行.<br>
Vue的代码才1w+行.</p>
<p>完全没有必要为了用网络请求就引用这个重量级的框架.</p>
<p>选择三: 官方在Vue1.x的时候, 推出了Vue-resource。Vue-resource的体积相对于jQuery小很多。另外Vue-resource是官方推出的.为什么不选择它呢?</p>
<p>在Vue2.0退出后, Vue作者就在GitHub的Issues中说明了去掉vue-resource, 并且以后也不会再更新.</p>
<p>那么意味着以后vue-reource不再支持新的版本时, 也不会再继续更新和维护.</p>
<p>对以后的项目开发和维护都存在很大的隐患.</p>
<p><code>选择四: 在说明不再继续更新和维护vue-resource的同时, 作者还推荐了一个框架: axios为什么用它呢?</code></p>
<p><code>axios有非常多的优点, 并且用起来也非常方便.</code></p>
<h2 id="jsonp">jsonp</h2>
<p>在前端开发中, 我们一种常见的网络请求方式就是JSONP。使用JSONP最主要的原因往往是为了解决跨域访问的问题.</p>
<p>JSONP的原理是什么呢?</p>
<p>JSONP的核心在于通过<code>&lt;script&gt;</code>标签的src来帮助我们请求数据.</p>
<p>原因是我们的项目部署在<code>domain1.com</code>服务器上时, 是不能直接访问<code>domain2.com</code>服务器上的资料的.</p>
<p>这个时候, 我们利用<code>&lt;script&gt;</code>标签的src帮助我们去服务器请求到数据, 将数据当做一个javascript的函数来执行, 并且执行</p>
<p>的过程中传入我们需要的json.<br>
所以, 封装jsonp的核心就在于我们监听window上的jsonp进行回调时的名称.<br>
JSONP如何封装呢?<br>
我们一起自己来封装一个处理JSONP的代码吧.</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001181211558.png" alt="image-20201001181211558"></p>
<h3 id="JSONP封装">JSONP封装</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001181303298.png" alt="image-20201001181303298"></p>
<h2 id="为什么选择axios">为什么选择axios?</h2>
<p>作者推荐和功能特点</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001181347060.png" alt="image-20201001181347060"></p>
<p>功能特点:</p>
<p>在浏览器中发送 XMLHttpRequests 请求</p>
<p>在 node.js 中发送 http请求</p>
<p>支持 Promise API</p>
<p>拦截请求和响应</p>
<p>转换请求和响应数据</p>
<p><code>补充: axios名称的由来? 个人理解。没有具体的翻译。axios: ajax i/o system.</code></p>
<h3 id="axiox请求方式">axiox请求方式</h3>
<p>支持多种请求方式:</p>
<p>axios(config)</p>
<p>axios.request(config)</p>
<p>axios.get(url[, config])</p>
<p>axios.delete(url[, config])</p>
<p>axios.head(url[, config])</p>
<p>axios.post(url[, data[, config]])</p>
<p>axios.put(url[, data[, config]])</p>
<p>axios.patch(url[, data[, config]])</p>
<h4 id="发送get请求演示">发送get请求演示</h4>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001181523520.png" alt="image-20201001181523520"></p>
<h4 id="发送并发请求">发送并发请求</h4>
<p>有时候, 我们可能需求同时发送两个请求。使用axios.all, 可以放入多个请求的数组.</p>
<p>axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001181609571.png" alt="image-20201001181609571"></p>
<p>在上面的示例中, 我们的BaseURL是固定的。事实上, 在开发中可能很多参数都是固定的。这个时候我们可以进行一些抽取, 也可以利用axiox的全局配置</p>
<pre><code class="hljs js">axios.defaults.baseURL = ‘<span class="hljs-number">123.207</span><span class="hljs-number">.32</span><span class="hljs-number">.32</span>:<span class="hljs-number">8000</span>’
axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;</code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001181716339.png" alt="image-20201001181716339"></p>
<h3 id="常见的配置选项">常见的配置选项</h3>
<p>请求地址：url: ‘/user’	请求类型：method: ‘get’,</p>
<p>请根路径：baseURL: ‘<a class="link" href="http://www.mt.com/api">http://www.mt.com/api<i class="fas fa-external-link-alt"></i></a>’	请求前的数据处理：transformRequest:[function(data){}],</p>
<p>请求后的数据处理：transformResponse: [function(data){}],</p>
<p>自定义的请求头：headers:{‘x-Requested-With’:‘XMLHttpRequest’},</p>
<p>URL查询对象：params:{ id: 12 }	查询对象序列化函数：paramsSerializer: function(params){ }</p>
<p>request body：data: { key: ‘aa’},</p>
<p>超时设置s：timeout: 1000,</p>
<p>跨域是否带Token：withCredentials: false,</p>
<p>自定义请求处理：adapter: function(resolve, reject, config){},</p>
<p>身份验证信息：auth: { uname: ‘’, pwd: ‘12’},</p>
<p>响应的数据格式 json / blob /document /arraybuffer / text / stream：responseType: ‘json’,</p>
<h3 id="axios的实例">axios的实例</h3>
<p>为什么要创建axios的实例呢?当我们从axios模块中导入对象时, 使用的实例是默认的实例.</p>
<p>当给该实例设置一些默认配置时, 这些配置就被固定下来了。但是后续开发中, 某些配置可能会不太一样.</p>
<p>比如某些请求需要使用特定的baseURL或者timeout或者content-Type等。这个时候, 我们就可以创建新的实例, 并且传入属于该实例的配置信息.</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001182018472.png" alt="image-20201001182018472"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001182031415.png" alt="image-20201001182031415"></p>
<h3 id="拦截器">拦截器</h3>
<p>axios提供了拦截器，用于我们在发送每次请求或者得到相应后，进行对应的处理。如何使用拦截器呢？</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001182111819.png" alt="image-20201001182111819"></p>
<p>请求拦截可以做到的事情：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001182137248.png" alt="image-20201001182137248"></p>
<p>请求拦截中错误拦截较少，通常都是配置相关的拦截。可能的错误比如请求超时，可以将页面跳转到一个错误页面中。</p>
<p>响应拦截中完成的事情：</p>
<p>响应的成功拦截中，主要是对数据进行过滤。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001182210645.png" alt="image-20201001182210645"></p>
<p>响应的失败拦截中，可以根据status判断报错的错误码，跳转到不同的错误提示页面。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001182214712.png" alt="image-20201001182214712"></p>
<h2 id="项目开发中的网络模块使用">项目开发中的网络模块使用</h2>
<p>目录结构</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001182916556.png" alt="image-20201001182916556"></p>
<p>在 request.js 中封装网络请求模块</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>
<span class="hljs-keyword">import</span> QS <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span>
<span class="hljs-comment">//import Cookie from 'js-cookie'</span>

<span class="hljs-keyword">const</span> res = {
    code: <span class="hljs-number">0</span>,
    msg: <span class="hljs-string">"请求异常"</span>,
    data: {}
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">url, data, type</span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//自动给请求加上token和collegeId，因为mock原因暂时注释掉</span>
        <span class="hljs-comment">// try {</span>
        <span class="hljs-comment">//     // 获取登录数据</span>
        <span class="hljs-comment">//     if (Cookie.get('token') !== undefined) {</span>
        <span class="hljs-comment">//         const token = JSON.parse(Cookie.get('token'))</span>
        <span class="hljs-comment">//         console.log('token信息',token)</span>
        <span class="hljs-comment">//         if (data !== undefined &amp;&amp; data !== null ) {</span>
        <span class="hljs-comment">//             data.token = token.token</span>
        <span class="hljs-comment">//             data.collegeId = token.collegeId</span>
        <span class="hljs-comment">//         } else {</span>
        <span class="hljs-comment">//             data = {</span>
        <span class="hljs-comment">//                 token: token.token,</span>
        <span class="hljs-comment">//                 collegeId: token.collegeId</span>
        <span class="hljs-comment">//             }</span>
        <span class="hljs-comment">//         }</span>
        <span class="hljs-comment">//     }</span>
        <span class="hljs-comment">// } catch (e) {</span>
        <span class="hljs-comment">//     //</span>
        <span class="hljs-comment">// }</span>
        <span class="hljs-comment">// 判断请求类型</span>
        <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'get'</span>) {
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> axios.get(url, {<span class="hljs-attr">params</span>: data})).data
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'post'</span>) {
            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> axios.post(url, QS.stringify(data), {<span class="hljs-attr">headers</span>: {<span class="hljs-string">'content-type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded;charset=utf-8'</span>}})).data
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> res
        }
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> res
    }
}</code></pre>
<p>api文件夹中调用 request.js 封装的 request函数</p>
<pre><code class="hljs js"><span class="hljs-comment">// 登录、注册、忘记密码模块</span>
<span class="hljs-keyword">import</span> { request } <span class="hljs-keyword">from</span> <span class="hljs-string">'../util/request.js'</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">login</span>(<span class="hljs-params">data</span>) </span>{ <span class="hljs-comment">// 登录接口</span>
    <span class="hljs-keyword">return</span> request( <span class="hljs-string">'/api/login/collegeAdmin'</span>, data, <span class="hljs-string">'post'</span>)
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span>(<span class="hljs-params">data</span>) </span>{ <span class="hljs-comment">// 注册接口</span>
  <span class="hljs-keyword">return</span> request(<span class="hljs-string">'/api/register'</span>, data, <span class="hljs-string">'post'</span>)
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">systemMessage</span>(<span class="hljs-params">data</span>) </span>{ <span class="hljs-comment">// 获取院管理员信息</span>
    <span class="hljs-keyword">return</span> request(<span class="hljs-string">'/api/account/msg'</span>, data, <span class="hljs-string">'get'</span>)
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changePassword</span>(<span class="hljs-params">data</span>) </span>{ <span class="hljs-comment">// 获取院管理员信息</span>
    <span class="hljs-keyword">return</span> request(<span class="hljs-string">'/api/account/password/change'</span>, data, <span class="hljs-string">'post'</span>)
}
</code></pre>
<p>在action中的调用</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">changePasswd</span>(<span class="hljs-params">{ commit },data</span>)</span>{
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
           changePassword(data).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {
               <span class="hljs-keyword">if</span> (res.code === <span class="hljs-number">1</span>){
                   resolve(res.msg)
                   commit(<span class="hljs-string">'NULL'</span>)
               } <span class="hljs-keyword">else</span> {
                   reject(res.msg)
               }
           }).catch(<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>{
               reject(error)
           })
       })</code></pre>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习笔记05-vue-router</title>
    <url>/2020/05/05/vue/vue-router/</url>
    <content><![CDATA[<h1>vue学习笔记05-vue-router</h1>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/forest-166733_1280.jpg" alt=""></p>
<hr>
<h1></h1>
<h2 id="什么是路由？">什么是路由？</h2>
<p>说起路由你想起了什么？路由是一个网络工程里面的术语。<br>
<code>路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动. --- 维基百科</code></p>
<p>在生活中, 我们有没有听说过路由的概念呢? 当然了, 路由器嘛.路由器是做什么的? 你有想过吗?路由器提供了两种机制: <code>路</code></p>
<p><code>由和转送</code>。<code>路由是决定数据包从来源到目的地的路径。转送将输入端的数据转移到合适的输出端.</code></p>
<p>路由中有一个非常重要的概念叫路由表。路由表本质上就是一个映射表, 决定了数据包的指向。</p>
<h2 id="后端路由阶段">后端路由阶段</h2>
<p>早期的网站开发整个HTML页面是由服务器来渲染的.服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示.</p>
<p>但是, 一个网站, 这么多页面服务器如何处理呢?一个页面有自己对应的网址, 也就是URL.</p>
<p>URL会发送到服务器, <code>服务器会通过正则对该URL进行匹配,</code> 并且最后交给一个Controller进行处理.<br>
Controller进行各种处理, 最终生成HTML或者数据, 返回给前端.这就完成了一个IO操作.</p>
<p>上面的这种操作, 就是后端路由。</p>
<p>当我们页面中需要请求不同的路径内容时, 交给服务器来进行处理, 服务器渲染好整个页面, 并且将页面返回给客户顿.<br>
这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化.<br>
<code>后端路由的缺点:</code><br>
一种情况是<code>整个页面的模块由后端人员来编写和维护的</code>.<br>
另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码。而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.</p>
<h2 id="前后端分离阶段">前后端分离阶段</h2>
<p>随着Ajax的出现, 有了前后端分离的开发模式。后端只提供API来返回数据, 前端通过Ajax获取数据, 并且可以通过JavaScript将数据渲染到页面中。这样做最大的优点就是前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上。<code>并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可</code>.<br>
目前很多的网站依然采用这种模式开发.</p>
<h2 id="单页面富应用阶段">单页面富应用阶段</h2>
<p>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由。也就是前端来维护一套路由规则.<br>
前端路由的核心是什么呢？改变URL，但是页面不进行整体的刷新。如何实现呢？</p>
<h2 id="前端路由规则">前端路由规则</h2>
<h3 id="URL的hash">URL的hash</h3>
<p>URL的hash也就是锚点(#), 本质上是改变window.location的href属性。我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新。</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923220342432.png" alt="image-20200923220342432" style="zoom:80%;">
<h3 id="HTML5的history模式">HTML5的history模式</h3>
<p>history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面.</p>
<h4 id="history-pushState">history.pushState()</h4>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923220441761.png" alt="image-20200923220441761" style="zoom:80%;">
<h4 id="history-replaceState">history.replaceState()</h4>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923220523487.png" alt="image-20200923220523487" style="zoom:80%;">
<h4 id="history-go">history.go()</h4>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923220546868.png" alt="image-20200923220546868" style="zoom:80%;">
<p><code>补充说明：上面只演示了三个方法。因为 history.back() 等价于 history.go(-1)。history.forward() 则等价于 history.go(1)这三个接口等同于浏览器界面的前进后退。</code></p>
<h2 id="认识vue-router">认识vue-router</h2>
<p>目前前端流行的三大框架, 都有自己的路由实现:</p>
<ul>
<li>Angular的ngRouter</li>
<li>React的ReactRouter</li>
<li>Vue的vue-router</li>
</ul>
<p>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。</p>
<p>我们可以访问其官方网站对其进行学习: <a class="link" href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/<i class="fas fa-external-link-alt"></i></a></p>
<p>vue-router是基于路由和组件的。路由用于设定访问路径, 将路径和组件映射起来。在vue-router的单页面应用中, 页面的路径的改变就是组件的切换。</p>
<h3 id="安装和使用vue-router">安装和使用vue-router</h3>
<p>因为我们已经学习了webpack, 后续开发中我们主要是通过工程化的方式进行开发的.<br>
所以在后续, 我们直接使用npm来安装路由即可.</p>
<ol>
<li>
<p>安装vue-router<br>
<code>npm install vue-router --save</code></p>
</li>
<li>
<p>在模块化工程中使用它(因为是一个插件, 所以可以通过Vue.use()来安装路由功能)</p>
<ol>
<li>
<p>导入路由对象，并且调用 Vue.use(VueRouter)</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923221159303.png" alt="image-20200923221159303"></p>
</li>
<li>
<p>创建路由实例，并且传入路由映射配置</p>
</li>
<li>
<p>在Vue实例中挂载创建的路由实例</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923221213842.png" alt="image-20200923221213842"></p>
</li>
</ol>
</li>
<li>
<p>使用vue-router的步骤:</p>
<ol>
<li>
<p>创建路由组件</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923221233833.png" alt="image-20200923221233833"></p>
</li>
<li>
<p>配置路由映射: 组件和路径映射关系</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923221308596.png" alt="image-20200923221308596"></p>
</li>
<li>
<p>使用路由: 通过<router-link>和<router-view></router-view></router-link></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923221318561.png" alt="image-20200923221318561"></p>
</li>
</ol>
</li>
</ol>
<p><code>&lt;router-link&gt;: 该标签是一个vue-router中已经内置的组件, 它会被渲染成一个&lt;a&gt;标签.</code><br>
<code>&lt;router-view&gt;: 该标签会根据当前的路径, 动态渲染出不同的组件.</code><br>
<code>网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和&lt;router-view&gt;处于同一个等级.</code><br>
<code>在路由切换时, 切换的是&lt;router-view&gt;挂载的组件, 其他内容不会发生改变.</code></p>
<p>最终效果如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923221359788.png" alt="image-20200923221359788"></p>
<h3 id="细节配置">细节配置</h3>
<h4 id="路由的默认路径">路由的默认路径</h4>
<p>我们这里还有一个不太好的实现。默认情况下, 进入网站的首页, 我们希望<router-view>渲染首页的内容.</router-view></p>
<p>但是我们的实现中, 默认没有显示首页组件, 必须让用户点击才可以.如何可以让路径默认跳到到首页, 并且<router-view>渲染首页组件呢?非常简单, 我们只需要配置多配置一个映射就可以了。</router-view></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923221540662.png" alt="image-20200923221540662"></p>
<p>配置解析：<code>我们在routes中又配置了一个映射。path配置的是根路径: /</code><br>
<code>redirect是重定向, 也就是我们将根路径重定向到/home的路径下, 这样就可以得到我们想要的结果了.</code></p>
<h4 id="HTML5的History模式">HTML5的History模式</h4>
<p>我们前面说过改变路径的方式有两种:</p>
<ul>
<li>URL的hash</li>
<li>HTML5的history</li>
</ul>
<p>默认情况下, 路径的改变使用的URL的hash。如果希望使用HTML5的history模式, 非常简单, 进行如下配置即可:</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923221701111.png" alt="image-20200923221701111"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923221706520.png" alt="image-20200923221706520"></p>
<h4 id="router-link补充">router-link补充</h4>
<p>在前面的<router-link>中, 我们只是使用了一个属性: to, 用于指定跳转的路径.<br>
<router-link>还有一些其他属性:</router-link></router-link></p>
<ul>
<li>tag: tag可以指定<router-link>之后渲染成什么组件, 比如上面的代码会被渲染成一个</router-link></li><li>元素, 而不是<a></a></li><a>
<li>replace: replace不会留下history记录, <code>所以指定replace的情况下, 后退键返回不能返回到上一个页面中</code></li>
<li>active-class: 当<router-link>对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active 的 class, 设置active-class可以修改默认的名称。在进行高亮显示的导航菜单或者底部tabbar时, 会使用到该类。但是通常不会修改类的属性, 会直接使用默认的router-link-active即可.</router-link></li>
</a></ul><a>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923221930141.png" alt="image-20200923221930141"></p>
<h5 id="修改linkActiveClass">修改linkActiveClass</h5>
<p>该class具体的名称也可以通过router实例的属性进行修改</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923222013970.png" alt="image-20200923222013970"></p>
<h4 id="路由代码跳转">路由代码跳转</h4>
<p>有时候, 页面的跳转可能需要执行对应的JavaScript代码, 这个时候, 就可以使用第二种跳转方式了<br>
比如, 我们将代码修改如下:</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923222228304.png" alt="image-20200923222228304"></p>
<h3 id="动态路由">动态路由</h3>
<p>在某些情况下，一个页面的path路径可能是不确定的，比如我们进入用户界面时，希望是如下的路径：</p>
<p><code>/user/aaaa或/user/bbbb</code></p>
<p>除了有前面的/user之外，后面还跟上了用户的ID</p>
<p>这种path和Component的匹配关系，<code>我们称之为动态路由(也是路由传递数据的一种方式)。</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923222338914.png" alt="image-20200923222338914"></p>
<h3 id="路由懒加载">路由懒加载</h3>
<p>官方给出了解释：<code>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。</code><br>
<code>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</code><br>
官方在说什么呢?<br>
首先, 我们知道路由中通常会定义很多不同的页面。这个页面最后被打包在哪里呢? 一般情况下, 是放在一个js文件中.</p>
<p>但是, 页面这么多放在一个js文件中, 必然会造成这个页面非常的大。</p>
<p>如果我们一次性从服务器请求下来这个页面, 可能需要花费一定的时间, 甚至用户的电脑上还出现了短暂空白的情况.</p>
<p>如何避免这种情况呢? 使用路由懒加载就可以了.</p>
<p>路由懒加载做了什么?</p>
<p>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块。只有在这个路由被访问到的时候, 才加载对应的组件。</p>
<h4 id="懒加载的实现">懒加载的实现</h4>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923222609010.png" alt="image-20200923222609010"></p>
<h4 id="懒加载的方式">懒加载的方式</h4>
<ol>
<li>
<p>结合Vue的异步组件和Webpack的代码分析.</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Home = <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> { <span class="hljs-built_in">require</span>.ensure([<span class="hljs-string">'../components/Home.vue'</span>], <span class="hljs-function">() =&gt;</span> { resolve(<span class="hljs-built_in">require</span>(<span class="hljs-string">'../components/Home.vue'</span>)) })};
</code></pre>
</li>
<li>
<p>AMD写法</p>
</li>
</ol>
   <pre><code class="hljs js"><span class="hljs-keyword">const</span> About = <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">'../components/About.vue'</span>], resolve);
</code></pre>
<ol start="3">
<li>
<p>在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割.</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> Home = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../components/Home.vue'</span>)
</code></pre>
</li>
</ol>
<h3 id="路由嵌套">路由嵌套</h3>
<h4 id="认识嵌套路由">认识嵌套路由</h4>
<p>嵌套路由是一个很常见的功能。比如在home页面中, 我们希望通过/home/news和/home/message访问一些内容.</p>
<p>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件。路径和组件的关系如下:</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923222909623.png" alt="image-20200923222909623"></p>
<p>实现嵌套路由有两个步骤:</p>
<ol>
<li>创建对应的子组件, 并且在路由映射中配置对应的子路由.</li>
<li>在组件内部使用<router-view>标签.</router-view></li>
</ol>
<h4 id="嵌套路由的实现">嵌套路由的实现</h4>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223014241.png" alt="image-20200923223014241"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223026910.png" alt="image-20200923223026910"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223036217.png" alt="image-20200923223036217"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223046378.png" alt="image-20200923223046378"></p>
<h4 id="嵌套默认路径">嵌套默认路径</h4>
<p>嵌套路由也可以配置默认的路径, 配置方式如下:</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223136320.png" alt="image-20200923223136320"></p>
<h3 id="路由传递参数">路由传递参数</h3>
<p>为了演示传递参数, 我们这里再创建一个组件, 并且将其配置好</p>
<ol>
<li>创建新的组件Profile.vue</li>
<li>配置路由映射</li>
<li>添加跳转的<router-link></router-link></li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223252508.png" alt="image-20200923223252508"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223303292.png" alt="image-20200923223303292"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223310568.png" alt="image-20200923223310568"></p>
<h4 id="传递参数的方式">传递参数的方式</h4>
<p>传递参数主要有两种类型: params和query</p>
<ul>
<li>
<p>params的类型：配置路由格式: /router/:id。</p>
<p>传递的方式: 在path后面跟上对应的值</p>
<p>传递后形成的路径: /router/123, /router/abc</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223510447.png" alt="image-20200923223510447"></p>
<p>获取参数通过$route对象获取的。在使用了 vue-router 的应用中，路由对象会被注入每个组件中，赋值为 this.$route ，并且当路由切换时，路由对象会被更新。通过$route获取传递的信息如下:</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223541240.png" alt="image-20200923223541240"></p>
</li>
<li>
<p>query的类型：配置路由格式: /router, 也就是普通配置</p>
<p>传递的方式: 对象中使用query的key作为传递方式</p>
<p>传递后形成的路径: /router?id=123, /router?id=abc</p>
</li>
</ul>
<p>注意：<code>$route和$router是有区别的</code></p>
<p>$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法</p>
<p>$route为当前router跳转对象里面可以获取name、path、query、params等</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200923223639810.png" alt="image-20200923223639810"></p>
<h3 id="导航守卫">导航守卫</h3>
<p>我们来考虑一个需求: <code>在一个SPA应用中, 如何改变网页的标题呢?</code></p>
<p>网页标题是通过<title>来显示的, 但是SPA只有一个固定的HTML, 切换不同的页面时, 标题并不会改变.&lt;/p&gt;
&lt;p&gt;但是我们可以通过JavaScript来修改&lt;title&gt;的内容.window.document.title = ‘新的标题’.&lt;/p&gt;
&lt;p&gt;那么在Vue项目中, 在哪里修改? 什么时候修改比较合适呢?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;普通的修改方式：我们比较容易想到的修改标题的位置是每一个路由对应的组件.vue文件中.&lt;/code&gt;&lt;br&gt;
&lt;code&gt;通过mounted声明周期函数, 执行对应的代码进行修改即可.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是当页面比较多时, 这种方式不容易维护(因为需要在多个页面执行类似的代码).&lt;br&gt;
有没有更好的办法呢? 使用导航守卫即可。&lt;/p&gt;
&lt;p&gt;什么是导航守卫?&lt;br&gt;
vue-router 提供的导航守卫&lt;code&gt;主要用来监听监听路由的进入和离开的.&lt;/code&gt;&lt;br&gt;
vue-router 提供了&lt;code&gt;beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发.&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="导航守卫的使用"&gt;导航守卫的使用&lt;/h4&gt;
&lt;p&gt;我们可以利用beforeEach来完成标题的修改.&lt;/p&gt;
&lt;p&gt;首先, 我们可以在钩子当中定义一些标题, 可以利用meta来定义&lt;/p&gt;
&lt;p&gt;其次, 利用导航守卫,修改我们的标题.&lt;/p&gt;
&lt;p&gt;导航钩子的三个参数解析:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;to: 即将要进入的目标的路由对象.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;from: 当前导航即将要离开的路由对象.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;next: 调用该方法后, 才能进入下一个钩子.&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.sky123.top/img/image-20200923223934004.png"
                      alt="image-20200923223934004"
                &gt;&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.sky123.top/img/image-20200923223940612.png"
                      alt="image-20200923223940612"
                &gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="导航守卫的补充"&gt;导航守卫的补充&lt;/h4&gt;
&lt;p&gt;补充一：如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数.&lt;br&gt;
补充二：上面我们使用的导航守卫, 被称之为全局守卫.&lt;/p&gt;
&lt;p&gt;更多内容, 可以查看官网进行学习:&lt;br&gt;
&lt;a class="link"   href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB" &gt;https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#路由独享的守卫&lt;i class="fas fa-external-link-alt"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="keep-alive"&gt;keep-alive&lt;/h3&gt;
&lt;p&gt;keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。&lt;br&gt;
它们有两个非常重要的属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;include - 字符串或正则表达，只有匹配的组件会被缓存&lt;/li&gt;
&lt;li&gt;exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img.sky123.top/img/image-20200923224116134.png"
                      alt="image-20200923224116134"
                &gt;&lt;/p&gt;
&lt;p&gt;通过create声明周期函数来验证&lt;/p&gt;
</title></p></a>]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习笔记04-前端模块化和vueCli的使用</title>
    <url>/2020/05/05/vue/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8CVueCLI%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1>vue学习笔记04-前端模块化和vueCli的使用</h1>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/sunset-675847_1280.jpg" alt=""></p>
<hr>
<h1>前端模块化</h1>
<h2 id="为什么需要模块化？">为什么需要模块化？</h2>
<h3 id="js原生功能带来的各种问题">js原生功能带来的各种问题</h3>
<p>在网页开发的早期，js制作作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的。那个时候的代码是怎么写的呢？直接将代码写在 <code>&lt;script&gt;</code> 标签中即可。随着ajax异步请求的出现，慢慢形成了前后端的分离<br>
客户端需要完成的事情越来越多，代码量也是与日俱增。为了应对代码量的剧增，我们通常会将代码组织在多个js文件中，进行维护。但是这种维护方式，依然不能避免一些灾难性的问题。</p>
<ol>
<li>比如<code>全局变量同名</code>问题：看下边的例子。<code>小明后来发现代码不能正常运行，去检查自己的变量，发现确实true</code><br>
<code>最后杯具发生了，小明加班到2点还是没有找到问题出在哪里(所以，某些加班真的是无意义的)</code></li>
<li>另外，<code>这种代码的编写方式对js文件的依赖顺序几乎是强制性的</code>。但是当js文件过多，比如有几十个的时候，弄清楚它们的顺序是一件比较同时的事情。且即使你弄清楚顺序了，也不能避免上面出现的这种尴尬问题的发生。</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808122843314.png" alt="image-20200808122843314"></p>
<h3 id="匿名函数的解决方案">匿名函数的解决方案</h3>
<p>我们可以使用匿名函数来解决方面的重名问题。在aaa.js文件中，我们使用匿名函数</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123048497.png" alt="image-20200808123048497"></p>
<p>但是如果我们希望在main.js文件中，用到flag，应该如何处理呢？显然，另外一个文件中不容易使用，因为flag是一个局部变量。</p>
<h3 id="模块化的解决方案">模块化的解决方案</h3>
<p>我们可以使用将需要暴露到外面的变量，使用一个模块作为出口，什么意思呢？来看下对应的代码：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123210671.png" alt="image-20200808123210671">非常简单，在匿名函数内部，定义一个对象。</p>
<p>给对象添加各种需要暴露到外面的属性和方法(不需要暴露的直接定义即可)。</p>
<blockquote>
<p>最后将这个对象返回，并且在外面使用了一个MoudleA接受。接下来，我们在man.js中怎么使用呢？我们只需要使用属于自己模块的属性和方法即可。<br>
这就是模块最基础的封装，事实上模块的封装还有很多高级的话题：但是我们这里就是要认识一下为什么需要模块，以及模块的原始雏形。幸运的是，前端模块化开发已经有了很多既有的规范，以及对应的实现方案。</p>
</blockquote>
<p><code>常见的模块化规范：</code><br>
<code>CommonJS、AMD、CMD，也有ES6的Modules</code></p>
<h2 id="CommonJS">CommonJS</h2>
<p><code>模块化有两个核心：导出和导入</code><br>
CommonJS的导出：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123345858.png" alt="image-20200808123345858"></p>
<p>CommonJS的导入</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123350759.png" alt="image-20200808123350759"></p>
<h2 id="ES6的Modules">ES6的Modules</h2>
<h3 id="export基本使用">export基本使用</h3>
<p>export指令用于导出变量，比如下面的代码：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123448500.png" alt="image-20200808123448500"></p>
<p>上面的代码还有另外一种写法：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123453884.png" alt="image-20200808123453884"></p>
<p>上面我们主要是输出变量，<code>也可以输出函数或者输出类</code><br>
上面的代码也可以写成这种形式：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123558628.png" alt="image-20200808123558628"></p>
<p>某些情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且<code>让导入者可以自己来命名</code><br>
这个时候就可以使用export default</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123623210.png" alt="image-20200808123623210"></p>
<p>我们来到main.js中，这样使用就可以了<br>
这里的myFunc是我自己命名的，你可以根据需要命名它对应的名字</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123636533.png" alt="image-20200808123636533"></p>
<p>另外，需要注意：<code>export default在同一个模块中，不允许同时存在多个。</code></p>
<h3 id="import使用">import使用</h3>
<p>我们使用export指令导出了模块对外提供的接口，下面我们就可以通过import命令来加载对应的这个模块了<br>
首先，<code>我们需要在HTML代码中引入两个js文件，并且类型需要设置为module</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123756542.png" alt="image-20200808123756542"></p>
<p>import 指令用于导入模块中的内容，比如 main.js 的代码</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123803004.png" alt="image-20200808123803004"></p>
<p><code>如果我们希望某个模块中所有的信息都导入，一个个导入显然有些麻烦：通过*可以导入模块中所有的export变量 但是通常情况下我们需要给*起一个别名，方便后续的使用</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200808123807955.png" alt="image-20200808123807955"></p>
<h1>Vue CLI相关</h1>
<p>如果你只是简单写几个Vue的Demo程序, 那么你不需要Vue CLI。</p>
<p>如果你在开发大型项目, 那么你需要, 并且必然需要使用Vue CLI。</p>
<p>使用Vue.js开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情。</p>
<p>如果每个项目都要手动完成这些工作，那无以效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情。</p>
<p>CLI是什么意思?<br>
<code>CLI是Command-Line Interface,</code> 翻译为命令行界面, 但是俗称脚手架。Vue CLI是一个官方发布 vue.js 项目脚手架</p>
<p>使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置</p>
<h2 id="Vue-CLI使用前提-Node">Vue CLI使用前提 - Node</h2>
<h3 id="安装NodeJS">安装NodeJS</h3>
<p>可以直接在官方网站中下载安装.<br>
网址: <a class="link" href="http://nodejs.cn/download/">http://nodejs.cn/download/<i class="fas fa-external-link-alt"></i></a><br>
检测安装的版本</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916164951331.png" alt="image-20200916164951331"></p>
<p>默认情况下自动安装Node和NPM</p>
<p>Node环境要求8.9以上或者更高版本</p>
<p>什么是NPM呢?<br>
<code>NPM的全称是Node Package Manager。是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。后续我们会经常使用NPM来安装一些开发过程中依赖包.</code></p>
<h3 id="cnpm安装">cnpm安装</h3>
<p>由于国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>
<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>
<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<p>这样就可以使用 cnpm 命令来安装模块了：</p>
<p><code>cnpm install [name]</code></p>
<h2 id="Vue-CLI使用前提-Webpack">Vue CLI使用前提 - Webpack</h2>
<p>Vue.js官方脚手架工具就使用了webpack模板。对所有的资源会压缩等优化操作。它在开发过程中提供了一套完整的功能，能够使得我们开发过程中变得高效。Webpack的全局安装</p>
<p><code>npm install webpack -g</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916165156206.png" alt="image-20200916165156206"></p>
<h2 id="Vue-CLI的使用">Vue CLI的使用</h2>
<p>安装Vue脚手架<br>
<code>npm install -g @vue/cli</code></p>
<p>注意：上面安装的是Vue CLI3的版本，如果需要想按照Vue CLI2的方式初始化项目时不可以的。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916165258454.png" alt="image-20200916165258454"></p>
<p>Vue CLI2初始化项目<br>
<code>vue init webpack my-project</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916165316533.png" alt="image-20200916165316533"></p>
<p>Vue CLI3初始化项目<br>
<code>vue create my-project</code></p>
<h2 id="VueCLI4的使用和配置">VueCLI4的使用和配置</h2>
<p>一般喜欢用 test、preview、production分别表示测试，预览，生产三种环境。修改 package.json 文件如下</p>
<pre><code class="hljs javascript"><span class="hljs-string">"scripts"</span>: {

    <span class="hljs-string">"serve"</span>: <span class="hljs-string">"vue-cli-service serve"</span>,

    <span class="hljs-string">"test"</span>: <span class="hljs-string">"vue-cli-service build --mode test"</span>,           <span class="hljs-comment">//测试</span>

    <span class="hljs-string">"preview"</span>: <span class="hljs-string">"vue-cli-service build --mode preview"</span>,     <span class="hljs-comment">//预览</span>

    <span class="hljs-string">"build"</span>: <span class="hljs-string">"vue-cli-service build --mode production"</span>,    <span class="hljs-comment">//生产</span>

    <span class="hljs-string">"lint"</span>: <span class="hljs-string">"vue-cli-service lint"</span>

},</code></pre>
<p><code>在项目根目录下新建 .env.test、.env.preview、 .env.production 文件，分别对应三个环境的配置文件，注意，名字要与 --mode 后面的名字分别对应</code></p>
<p>.env.test 代码如下</p>
<pre><code class="hljs javascript">NODE_ENV=<span class="hljs-string">"test"</span>
VUE_APP_BASE_URL=<span class="hljs-string">"测试环境域名"</span></code></pre>
<p>.env.pre 代码如下</p>
<pre><code class="hljs javascript">NODE_ENV=<span class="hljs-string">"preview"</span>
VUE_APP_BASE_URL=<span class="hljs-string">"预览环境域名"</span></code></pre>
<p>.env.prod 代码如下</p>
<pre><code class="hljs javascript">NODE_ENV=<span class="hljs-string">"production"</span>
VUE_APP_BASE_URL=<span class="hljs-string">"生产环境域名"</span></code></pre>
<p>ok，这样环境就配置好了，分别用以下命令来打包不同环境的包就可以了</p>
<pre><code class="hljs javascript">npm run test    <span class="hljs-comment">//测试</span>
npm run pre     <span class="hljs-comment">//预发布</span>
npm run prod    <span class="hljs-comment">//生产</span></code></pre>
<p>另外需要说明一点的是，本地环境会默认从 .env.development 文件中读取配置。所以记得有需要记得新建一个然后存放配置。我的 .env.development 代码如下</p>
<pre><code class="hljs javascript">NODE_ENV=<span class="hljs-string">"development"</span>
VUE_APP_BASE_URL=<span class="hljs-string">"本地环境域名"</span></code></pre>
<p>从 vue-cli3.0 开始 build 和 config 目录就取消了，如果需要修改配置，可以在项目的根目录新建一个 vue.config.js 文件来覆盖项目的配置，因为项目的配置比较多，这里就不分别介绍了，可以 <a class="link" href="https://cli.vuejs.org/zh/config/#vue-config-js">访问官方文档<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>PowerDesigner安装教程（含下载+汉化+破解）</title>
    <url>/2021/03/10/%E8%BD%AF%E4%BB%B6/powerDesigner/</url>
    <content><![CDATA[<p>文章转自：<a class="link" href="https://www.fujieace.com/software/powerdesigner.html">https://www.fujieace.com/software/powerdesigner.html<i class="fas fa-external-link-alt"></i></a></p>
<p>软件版本：Sybase PowerDesigner 16.5</p>
<h2 id="准备工作：">准备工作：</h2>
<p>下载下面三个文件：</p>
<p>1、安装文件 链接: <a class="link" href="https://pan.baidu.com/s/1fxmBlcee4qEqxM4djSzvWA">https://pan.baidu.com/s/1fxmBlcee4qEqxM4djSzvWA<i class="fas fa-external-link-alt"></i></a> 密码: 1234</p>
<p>2、破解文件 链接: <a class="link" href="https://pan.baidu.com/s/1jadOumXVh6iC6XeXqwPGQw">https://pan.baidu.com/s/1jadOumXVh6iC6XeXqwPGQw<i class="fas fa-external-link-alt"></i></a> 密码: 1234</p>
<p>3、汉化文件 链接: <a class="link" href="https://pan.baidu.com/s/19yeyWfAPMJ_WeJy8SDVu5Q">https://pan.baidu.com/s/19yeyWfAPMJ_WeJy8SDVu5Q<i class="fas fa-external-link-alt"></i></a> 密码: 1234</p>
<h2 id="PowerDesigner安装图文教程：">PowerDesigner安装图文教程：</h2>
<p>1、解压PowerDesigner安装文件，并双击PowerDesigner.exe；</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/1-2.png" alt=""></p>
<p>2、欢迎来到PowerDesigner安装界面，点击 Next</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/3-3.png" alt=""></p>
<p>3、一定要选择Trial，再点击Next，不要选择其它，这一步如果选择错，后面破解是不行的。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/3-3.png" alt=""></p>
<p>4、选择Hong Kong，点击I AGREE，再点击Next；</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/4-1.png" alt=""></p>
<p>5、选择一个安装目录，默认是安装在C盘。再点击Next；</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/5-1.png" alt=""></p>
<p>6、点击General和Notaion，再点击Next；</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/7.png" alt=""></p>
<p>走到这一 步，如果你电脑上已经安装了“Eclipse”软件，请不要打勾此插件选项。否则：就会出现，让你选择“Eclipse”软件的安装路径。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/159.png" alt=""></p>
<p>7、直接点击Next；进入正在安装界面</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/160.png" alt=""></p>
<p>9、点击Finish（安装完成）</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/9-1.png" alt=""></p>
<h2 id="PowerDesigner破解步骤：">PowerDesigner破解步骤：</h2>
<p>1、将PowerDesigner破解文件解压，然后，你能看到一个“pdflm16.dll”文件；</p>
<p>2、将“pdflm16.dll”复制并覆盖到你软件安装的目录中，一定要是此软件的安装根目录；例如：我这里就直接复制到 E:\powerdesigner 即可！</p>
<h2 id="PowerDesigner汉化步骤：">PowerDesigner汉化步骤：</h2>
<p>1、将PowerDesigner汉化文件解压，然后你能看到很多文件；</p>
<p>2、Ctrl+A（全选）所有文件，复制并覆盖到你软件安装的目录中；</p>
<p>3、如果点击PdShell16.exe不能正常启动，请点击pdlegacyshell16.exe启动；</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/856.png" alt=""></p>
]]></content>
      <tags>
        <tag>软件</tag>
        <tag>powerDesigner</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/2021/05/04/docker/Docker02%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="帮助命令：">帮助命令：</h3>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">显示版本</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker version

Client: Docker Engine - Community
 Version:           20.10.6
 API version:       1.41
 Go version:        go1.13.15
 Git commit:        370c289
 Built:             Fri Apr  9 22:45:33 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.6
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.13.15
  Git commit:       8728dd2
  Built:            Fri Apr  9 22:43:57 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.4
  GitCommit:        05f951a3781f4f2c1911b05e61c160e9c30eaa8e
 runc:
  Version:          1.0.0-rc93
  GitCommit:        12644e614e25b05da6fd08a38ffa0cfe1903fdec
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0

<span class="hljs-meta">#</span><span class="bash">显示Docker的系统信息</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker info

Client:
 Context:    default
 Debug Mode: false
 Plugins:
  app: Docker App (Docker Inc., v0.9.1-beta3)
  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)
  scan: Docker Scan (Docker Inc.)

Server:
 Containers: 1
  Running: 0
  Paused: 0
  Stopped: 1
 Images: 1
 Server Version: 20.10.6
 Storage Driver: overlay2
  Backing Filesystem: extfs
  Supports d_type: true
  Native Overlay Diff: false
  userxattr: false
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Cgroup Version: 1
 Plugins:
  Volume: local
  Network: bridge host ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
 Swarm: inactive
 Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 05f951a3781f4f2c1911b05e61c160e9c30eaa8e
 runc version: 12644e614e25b05da6fd08a38ffa0cfe1903fdec
 init version: de40ad0
 Security Options:
  seccomp
   Profile: default
 Kernel Version: 3.10.0-514.26.2.el7.x86_64
 Operating System: CentOS Linux 7 (Core)
 OSType: linux
 Architecture: x86_64
 CPUs: 1
 Total Memory: 1.796GiB
 Name: izwz91mv6i3x6k12jjqh60z
 ID: KA6F:5IVG:6OGX:WPVP:I74K:PAUV:EI5L:SGYK:3GRQ:E3DA:FVTQ:X4BM
 Docker Root Dir: /var/lib/docker
 Debug Mode: false
 Registry: https://index.docker.io/v1/
 Labels:
 Experimental: false
 Insecure Registries:
  127.0.0.0/8
 Registry Mirrors:
  https://bjyjzfeq.mirror.aliyuncs.com/
 Live Restore Enabled: false

<span class="hljs-meta">#</span><span class="bash">帮助信息</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker --help

Commands:
  attach     #当前shell下 attach连接指定运行镜像
  build      #通过dokcerfile 定制镜像 
  commit     #提交当前容器为新的镜像
  cp         #从容器中拷贝指定文件或目录到宿主机
  create     #创建一个新的容器 ，同 run ，但不会启动容器
  diff       #查看docker 容器变化
  events     #从docker服务器获取容器实时事件
  exec       #在已存在的容器上运行命令
  export     #导出容器的内容流作为一个 tar 归档文件（对应 import）
  history    #展示镜像的形成历史
  images     #列出系统当前所有镜像
  import     #从 tar 包中的内容创建一个新的文件系统映像（对应 export）
  info       #查看系统相关信息
  inspect    #查看容器详细信息
  kill       #kill 指定的 docker 容器
  load       #从一个 tar包中加载一个镜像（对应save）
  login      #注册或登陆一个docker 源服务器
  logout     #登出当前源服务器
  logs       #输出当前容器的日志内容
  pause      #暂停容器
  port       #查看映射端口对应的容器内部源端口
  ps         #列出容器列表
  pull       #从docker镜像源服务器拉取指定镜像或库镜像
  push       #推送指定镜像或者库镜像到 docker 源服务器
  rename     #
  restart    #重启运行的容器
  rm         #移除一个或多个容器
  rmi        #移除一个或多个镜像
  run        #创建一个新的容器并运行一个命令
  save       #保存一个镜像为一个 tar (对应load)
  search     #在docker hub中搜索镜像
  start      #启动容器
  stop       #停止容器
  tag        #给源镜像打标签
  top        #查看容器中运行的进程消息
  unpause    #取消暂停容器
  version    #查看容器版本号
  wait       #获取容器停止时的退出状态值</code></pre>
<h3 id="镜像命令：">镜像命令：</h3>
<h4 id="docker-images">docker images</h4>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 主机上的所有本地镜像</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker images help
<span class="hljs-meta">#</span><span class="bash">解释</span>
REPOSITORY：镜像的仓库源   
TAG：镜像的标签
IMAGE ID：镜像的ID   
CREATED：创建时间   
SIZE：大小
<span class="hljs-meta">#</span><span class="bash">可选项</span>
-a   --all #列出所有镜像
-q   --quiet #只列出镜像的ID
[root@izwz91mv6i3x6k12jjqh60z ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
hello-world   latest    d1165f221234   7 weeks ago   13.3kB


</code></pre>
<h4 id="docker-search">docker search</h4>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">搜索镜像</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker search mysql

NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql                             MySQL is a widely used, open-source relation…   10777     [OK]       
mariadb                           MariaDB Server is a high performing open sou…   4058      [OK] 
......

<span class="hljs-meta">#</span><span class="bash">搜索镜像的 star&gt;3000 的镜像</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker search mysql --filter=stars=3000
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql     MySQL is a widely used, open-source relation…   10777     [OK]       
mariadb   MariaDB Server is a high performing open sou…   4058      [OK]</code></pre>
<h4 id="docker-pull">docker pull</h4>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载镜像 [:tag]</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker pull mysql
Using default tag: latest  # 不写tag 默认就是 latest
latest: Pulling from library/mysql
f7ec5a41d630: Pull complete #分层下载， docker image的核心，联合文件系统
9444bb562699: Pull complete 
6a4207b96940: Pull complete 
181cefd361ce: Pull complete 
8a2090759d8a: Pull complete 
15f235e0d7ee: Pull complete 
d870539cd9db: Pull complete 
493aaa84617a: Pull complete 
bfc0e534fc78: Pull complete 
fae20d253f9d: Pull complete 
9350664305b3: Pull complete 
e47da95a5aab: Pull complete 
Digest: sha256:04ee7141256e83797ea4a84a4d31b1f1bc10111c8d1bc1879d52729ccd19e20a #文件签名
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest #存放的镜像的文件真实地址

<span class="hljs-meta">#</span><span class="bash">等价写法</span>
docker pull docker.io/library/mysql:latest

<span class="hljs-meta">#</span><span class="bash">指定版本下载</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker pull mysql:5.7
5.7: Pulling from library/mysql
f7ec5a41d630: Already exists 
9444bb562699: Already exists 
6a4207b96940: Already exists 
181cefd361ce: Already exists 
8a2090759d8a: Already exists 
15f235e0d7ee: Already exists 
d870539cd9db: Already exists 
cb7af63cbefa: Pull complete 
151f1721bdbf: Pull complete 
fcd19c3dd488: Pull complete 
415af2aa5ddc: Pull complete 
Digest: sha256:a655529fdfcbaf0ef28984d68a3e21778e061c886ff458b677391924f62fb457
Status: Downloaded newer image for mysql:5.7
docker.io/library/mysql:5.7

[root@izwz91mv6i3x6k12jjqh60z ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
mysql         5.7       87eca374c0ed   8 days ago    447MB
mysql         latest    0627ec6901db   8 days ago    556MB
hello-world   latest    d1165f221234   7 weeks ago   13.3kB
</code></pre>
<h4 id="docker-rmi">docker rmi</h4>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">删除镜像</span>
<span class="hljs-meta">#</span><span class="bash"> docker rmi 镜像ID [镜像ID,...]   删除没有运行容器的镜像</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker rmi 0627ec6901db
Untagged: mysql:latest
Untagged: mysql@sha256:04ee7141256e83797ea4a84a4d31b1f1bc10111c8d1bc1879d52729ccd19e20a
Deleted: sha256:0627ec6901db4b2aed6ca7ab35e43e19838ba079fffe8fe1be66b6feaad694de
Deleted: sha256:94d5db550d62032ddc8ad8d4cfef8bac06fe7d35757deb2f8638d0fdc1e89217
Deleted: sha256:5fbbb0e9bfb8f2a4d665cc60aaf4876191c057898db276d2d030a0d6123afc8e
Deleted: sha256:124a9d262ebecea284b6438b0a04766b076bd3f89cb0f29a8a475f26bf93911f
Deleted: sha256:5aa37b6c8e31197ab2f357c09755bcb83228ff0fb69c2009a12b6eddb087e884
Deleted: sha256:d0b1d5665c308823bbc5b8986d405e5202ade6994dfa00d8ff576eff372dd045

<span class="hljs-meta">#</span><span class="bash"> docker rmi -f 镜像ID [镜像ID,...]  删除连带删除容器的镜像</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker rmi -f d1165f221234
Untagged: hello-world:latest
Untagged: hello-world@sha256:f2266cbfc127c960fd30e76b7c792dc23b588c0db76233517e1891a4e357d519
Deleted: sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726

<span class="hljs-meta">#</span><span class="bash">docker rmi -f $(docker images -aq)  删除所有容器和镜像</span>

[root@izwz91mv6i3x6k12jjqh60z ~]# docker images
REPOSITORY   TAG       IMAGE ID   CREATED   SIZE
</code></pre>
<h3 id="容器命令：">容器命令：</h3>
<p>前置环境，下载一个  <code>centos</code> 镜像</p>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z ~]# docker pull centos
Using default tag: latest
latest: Pulling from library/centos
7a0437f04f83: Pull complete 
Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1
Status: Downloaded newer image for centos:latest
docker.io/library/centos:latest</code></pre>
<h4 id="新建并运行容器：">新建并运行容器：</h4>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z ~]# docker run --help

Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

  -d                       		 以后台方式运行，并打印容器ID
  --name=“string”                容器名字用于区分容器，
  -p							 指定容器的端口（设置主机和容器的端口映射）
  		-p ip:主机端口:容器端口（访问公网主机的端口可以访问到容器内容的端口）
  		-p 主机端口:容器端口
  		-p 容器端口
  -P                    		 随机指定端口
  -it       					 使用交互方式运行，进入容器内查看内容

[root@izwz91mv6i3x6k12jjqh60z ~]# docker run -it centos /bin/bash
<span class="hljs-meta">#</span><span class="bash">容器内的centos ,发现很多命令并不完善</span>
[root@e77313cc0ef1 /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
<span class="hljs-meta">#</span><span class="bash">从容器中退出到主机</span>
[root@e77313cc0ef1 /]# exit
exit
<span class="hljs-meta">#</span><span class="bash">主机的centos</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# ls
docker-client  docker-client-latest  docker-common  docker-engine  docker-latest  docker-latest-logrotate  docker-logrotate
</code></pre>
<h4 id="列出所有运行的容器：">列出所有运行的容器：</h4>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

-q 只显示容器编号
-a 列出当前正在运行的容器+带出历史运行过的容器
-n=? 显示最近创建的容器的个数

[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps -a
CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                     PORTS     NAMES
e77313cc0ef1   centos         "/bin/bash"   3 minutes ago   Exited (0) 2 minutes ago             romantic_elgamal
17d31c5f5553   centos         "/bin/bash"   9 minutes ago   Exited (0) 9 minutes ago             os1
19d5eac5de11   d1165f221234   "/hello"      3 hours ago     Exited (0) 3 hours ago               naughty_williams

[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps -n=2
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                      PORTS     NAMES
e77313cc0ef1   centos    "/bin/bash"   11 minutes ago   Exited (0) 9 minutes ago              romantic_elgamal
17d31c5f5553   centos    "/bin/bash"   16 minutes ago   Exited (0) 16 minutes ago             os1
</code></pre>
<h4 id="退出容器：">退出容器：</h4>
<pre><code class="hljs shell">exit #直接容器停止并退出
Ctrl + P + Q #容器不停止而退出

[root@izwz91mv6i3x6k12jjqh60z ~]# docker run -it centos /bin/bash
<span class="hljs-meta">#</span><span class="bash">进入容器后按住快捷键</span>
[root@f3a97eadb092 /]# 
<span class="hljs-meta">#</span><span class="bash">发现返回了主机</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# 
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
f3a97eadb092   centos    "/bin/bash"   28 seconds ago   Up 27 seconds             thirsty_pasteur
</code></pre>
<h4 id="删除容器：">删除容器：</h4>
<pre><code class="hljs shell">docker rm [-f] 容器ID #删除指定的容器，rm -f 表示强制删除正在运行的容器
docker rm -f $(docker ps -aq) #删除所有的容器
docker ps -a -q|xargs docker rm #删除所有容器</code></pre>
<h4 id="启动和停止容器：">启动和停止容器：</h4>
<pre><code class="hljs shell">docker start 容器ID  #启动容器
docker restart 容器ID #重启容器
docker stop 容器ID #停止正在运行的容器
docker kill 容器ID #强制停止当前运行的容器

[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
f3a97eadb092   centos    "/bin/bash"   28 seconds ago   Up 27 seconds             thirsty_pasteur
[root@izwz91mv6i3x6k12jjqh60z ~]# docker stop f3a97eadb092
f3a97eadb092
[root@izwz91mv6i3x6k12jjqh60z ~]# docker start f3a97eadb092
f3a97eadb092
[root@izwz91mv6i3x6k12jjqh60z ~]# docker restart f3a97eadb092
f3a97eadb092
[root@izwz91mv6i3x6k12jjqh60z ~]# docker kill  f3a97eadb092
f3a97eadb092
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps -a
CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                       PORTS     NAMES
f3a97eadb092   centos         "/bin/bash"   12 minutes ago   Exited (137) 5 seconds ago             thirsty_pasteur
e77313cc0ef1   centos         "/bin/bash"   25 minutes ago   Exited (0) 23 minutes ago              romantic_elgamal
17d31c5f5553   centos         "/bin/bash"   30 minutes ago   Exited (0) 30 minutes ago              os1
19d5eac5de11   d1165f221234   "/hello"      4 hours ago      Exited (0) 4 hours ago                 naughty_williams
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
[root@izwz91mv6i3x6k12jjqh60z ~]# docker start f3a97eadb092
f3a97eadb092
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS         PORTS     NAMES
f3a97eadb092   centos    "/bin/bash"   12 minutes ago   Up 2 seconds             thirsty_pasteur</code></pre>
<h4 id="后台启动容器：">后台启动容器：</h4>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z ~]# docker run -d centos
ddb941029e1fd47abfbd83968afc2103b2685d3ee0cf3f7ec32cd6f6fee96aca
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

<span class="hljs-meta">#</span><span class="bash">常见问题：-d 运行之后，docker ps 发现它并没有运行</span>
<span class="hljs-meta">#</span><span class="bash">原因：docker 容器使用后台运行，就必须要有一个前台进程，docker 发现没有应用，就会自动停止</span>
<span class="hljs-meta">#</span><span class="bash">nginx 容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了。</span></code></pre>
<h4 id="查看日志：">查看日志：</h4>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z ~]# docker logs --help

Usage:  docker logs [OPTIONS] CONTAINER

Fetch the logs of a container

Options:
      --details        Show extra details provided to logs
  -f, --follow         Follow log output
      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
  -n, --tail string    显示的日志的条数
  -t, --timestamps     Show timestamps
      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)


<span class="hljs-meta">#</span><span class="bash">自己写一段 shell 脚本</span>
docker run -d centos /bin/sh -c "while true;do echo ios;sleep 1;done"

[root@izwz91mv6i3x6k12jjqh60z ~]# docker run -d centos /bin/sh -c "while true;do echo ios;sleep 1;done"
018801a5cdcfc762fb5def6d8f1ff3a7ec4d136f6b2812717937ee43a5f6ff66
[root@izwz91mv6i3x6k12jjqh60z ~]# docker logs 018801a5cdcfc762fb5def6d8f1ff3a7ec4d136f6b2812717937ee43a5f6ff66
ios....
</code></pre>
<h4 id="查看容器进程的信息：">查看容器进程的信息：</h4>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z ~]# docker top 018801a5cdcf
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                9040                9015                0                   16:09               ?                   00:00:00            /bin/sh -c while true;do echo ios;sleep 1;done
root                9288                9040                0                   16:11               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1
</code></pre>
<h4 id="查看镜像中的元数据：">查看镜像中的元数据：</h4>
<pre><code class="hljs shell">[root@izwz91mv6i3x6k12jjqh60z ~]# docker inspect 018801a5cdcf 
[
    {
        "Id": "018801a5cdcfc762fb5def6d8f1ff3a7ec4d136f6b2812717937ee43a5f6ff66",
        "Created": "2021-04-28T08:09:10.127985045Z",
        "Path": "/bin/sh",
        "Args": [
            "-c",
            "while true;do echo ios;sleep 1;done"
        ],
        ......
    }
]</code></pre>
<h4 id="进入当前正在运行的容器：">进入当前正在运行的容器：</h4>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span>

<span class="hljs-meta">#</span><span class="bash">方法一：docker <span class="hljs-built_in">exec</span>进入容器后开启一个新的终端，可以在里面操作（常用）</span>
<span class="hljs-meta">#</span><span class="bash">查看正在运行的容器</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED        STATUS        PORTS     NAMES
018801a5cdcf   centos    "/bin/sh -c 'while t…"   21 hours ago   Up 21 hours             confident_mayer
f79cbdf9c012   centos    "/bin/bash"              21 hours ago   Up 21 hours             sweet_lehmann

<span class="hljs-meta">#</span><span class="bash">进入容器</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker exec -it 018801a5cdcf /bin/bash
[root@018801a5cdcf /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
<span class="hljs-meta">#</span><span class="bash">查看容器内的进程</span>
[root@018801a5cdcf /]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Apr28 ?        00:00:16 /bin/sh -c while true;do echo ios;sleep 1;done
root      9005     0  0 04:43 pts/0    00:00:00 /bin/bash
root      9042     1  0 04:43 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1
root      9043  9005  0 04:43 pts/0    00:00:00 ps -ef

<span class="hljs-meta">#</span><span class="bash">方法二：docker attach 进入容器正在执行的终端，不会执行新的进程</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker attach 018801a5cdcf
ios
ios
ios
ios
<span class="hljs-meta">#</span><span class="bash">发现正在执行脚本。。</span></code></pre>
<h4 id="拷贝文件到主机：">拷贝文件到主机：</h4>
<p>从容器中拷贝文件到主机上（拷贝目前是一个手动过程，未来使用 -v 卷技术可以实现自动拷贝）</p>
<pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看运行的容器</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED        STATUS        PORTS     NAMES
018801a5cdcf   centos    "/bin/sh -c 'while t…"   21 hours ago   Up 21 hours             confident_mayer
f79cbdf9c012   centos    "/bin/bash"              21 hours ago   Up 21 hours             sweet_lehmann

<span class="hljs-meta">#</span><span class="bash">查看主机文件</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# ls
docker-client  docker-client-latest  docker-common  docker-engine  docker-latest  docker-latest-logrotate  docker-logrotate

<span class="hljs-meta">#</span><span class="bash">进入容器，新建一个测试文件后退出</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker attach f79cbdf9c012
[root@f79cbdf9c012 /]# cd /home
[root@f79cbdf9c012 home]# ls
[root@f79cbdf9c012 home]# touch test.java
[root@f79cbdf9c012 home]# exit
exit

<span class="hljs-meta">#</span><span class="bash">再次查看，发现容器已经不再运行</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED        STATUS        PORTS     NAMES
018801a5cdcf   centos    "/bin/sh -c 'while t…"   21 hours ago   Up 21 hours             confident_mayer
[root@izwz91mv6i3x6k12jjqh60z ~]# docker ps -a
CONTAINER ID   IMAGE          COMMAND                  CREATED        STATUS                      PORTS     NAMES
018801a5cdcf   centos         "/bin/sh -c 'while t…"   21 hours ago   Up 21 hours                           confident_mayer
f79cbdf9c012   centos         "/bin/bash"              21 hours ago   Exited (0) 25 seconds ago 

<span class="hljs-meta">#</span><span class="bash">拷贝文件命令</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# docker cp f79cbdf9c012:/home/test.java /home

<span class="hljs-meta">#</span><span class="bash">查看是否拷贝成功</span>
[root@izwz91mv6i3x6k12jjqh60z ~]# cd /home
[root@izwz91mv6i3x6k12jjqh60z home]# ls
admin  test.java</code></pre>
<h4 id="小结">小结</h4>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20210221200910336.png" alt="image-20210221200910336"></p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript常用的21个数组方法</title>
    <url>/2020/07/01/javascript/Javascript%E5%B8%B8%E7%94%A8%E7%9A%8421%E4%B8%AA%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/dinosaur-5995333_1280.png" alt=""></p>
<hr>
<h2 id="Javascript常用的21个数组方法">Javascript常用的21个数组方法</h2>
<p>这七个数组方法</p>
<p><code>unshift();	  push()；  shift();</code></p>
<p><code>pop();	 sort();	reverse();	splice();</code>使用后数组是会被改变的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">对应版本</th>
<th style="text-align:center">功能</th>
<th style="text-align:center">原数组是否改变</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">concat()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">合并数组，并返回合并之后的数据</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">join()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">使用分隔符，将数组转为字符串并返回</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">pop()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">删除最后一位，并返回删除的数据</td>
<td style="text-align:center">y</td>
</tr>
<tr>
<td style="text-align:center">shift()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">删除第一位，并返回删除的数据</td>
<td style="text-align:center">y</td>
</tr>
<tr>
<td style="text-align:center">unshift()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">在第一位新增一或多个数据，返回长度</td>
<td style="text-align:center">y</td>
</tr>
<tr>
<td style="text-align:center">push()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">在最后一位新增一或多个数据，返回长度</td>
<td style="text-align:center">y</td>
</tr>
<tr>
<td style="text-align:center">reverse()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">反转数组，返回结果</td>
<td style="text-align:center">y</td>
</tr>
<tr>
<td style="text-align:center">slice()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">截取指定位置的数组，并返回</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">sort()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">排序（字符规则），返回结果</td>
<td style="text-align:center">y</td>
</tr>
<tr>
<td style="text-align:center">splice()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">删除指定位置，并替换，返回删除的数据</td>
<td style="text-align:center">y</td>
</tr>
<tr>
<td style="text-align:center">toString()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">直接转为字符串，并返回</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">valueOf()</td>
<td style="text-align:center">ES5-</td>
<td style="text-align:center">返回数组对象的原始值</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">indexOf()</td>
<td style="text-align:center">ES5</td>
<td style="text-align:center">查询并返回数据的索引</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">lastIndexOf()</td>
<td style="text-align:center">ES5</td>
<td style="text-align:center">反向查询并返回数据的索引</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">forEach()</td>
<td style="text-align:center">ES5</td>
<td style="text-align:center">参数为回调函数，会遍历数组所有的项，回调函数接受三个参数，分别为value，index，self；forEach没有返回值</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">map()</td>
<td style="text-align:center">ES5</td>
<td style="text-align:center">同forEach，同时回调函数返回数据，组成新数组由map返回</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">filter()</td>
<td style="text-align:center">ES5</td>
<td style="text-align:center">同forEach，同时回调函数返回布尔值，为true的数据组成新数组由filter返回</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">every()</td>
<td style="text-align:center">ES5</td>
<td style="text-align:center">同forEach，同时回调函数返回布尔值，全部为true，由every返回true</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">some()</td>
<td style="text-align:center">ES5</td>
<td style="text-align:center">同forEach，同时回调函数返回布尔值，只要由一个为true，由some返回true</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">reduce()</td>
<td style="text-align:center">ES5</td>
<td style="text-align:center">归并，同forEach，迭代数组的所有项，并构建一个最终值，由reduce返回</td>
<td style="text-align:center">n</td>
</tr>
<tr>
<td style="text-align:center">reduceRight()</td>
<td style="text-align:center">ES5</td>
<td style="text-align:center">反向归并，同forEach，迭代数组的所有项，并构建一个最终值，由reduceRight返回</td>
<td style="text-align:center">n</td>
</tr>
</tbody>
</table>
<h3 id="1：concat">1：concat()</h3>
<p>功能：合并数组，可以合并一个或多个数组，会返回合并数组之后的数据，不会改变原来的数组；</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str1 = [<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"hello"</span>];<span class="hljs-keyword">var</span> str2 = [<span class="hljs-string">"world"</span>];
<span class="hljs-built_in">console</span>.log(str1.concat(str2));　　　　　　　　<span class="hljs-comment">//[12, 2, "hello", "world"]</span>
<span class="hljs-built_in">console</span>.log(str1);　　　　　　　　　　　　　　　　<span class="hljs-comment">//[12,2,"hello"];</span></code></pre>
<h3 id="2：join">2：join()</h3>
<p>功能：将数组转为字符串并返回转化的字符串数据，不会改变原来的数组；</p>
<p>注意：()中用双引号包括自己想用的分隔符，默认为逗号，这里方便观察，我用了-</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str1 = [<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"hello"</span>];
<span class="hljs-keyword">var</span> str2 = [<span class="hljs-string">"world"</span>];
<span class="hljs-built_in">console</span>.log(str1.join(<span class="hljs-string">"-"</span>));　　　　　　　　<span class="hljs-comment">//12-2-hello</span>
<span class="hljs-built_in">console</span>.log(str1);　　　　　　　　　　　　　　<span class="hljs-comment">//[12, 2, "hello"]</span></code></pre>
<h3 id="3：pop">3：pop()</h3>
<p>功能：删除数组的最后一位，并且返回删除的数据，会改变原来的数组</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str1 = [<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"hello"</span>];
<span class="hljs-built_in">console</span>.log(str1.pop()　　　　　　　　<span class="hljs-comment">//hello</span>
<span class="hljs-built_in">console</span>.log(str1);　　　　　　　　　　<span class="hljs-comment">//[12, 2]</span></code></pre>
<h3 id="4：shift">4：shift()</h3>
<p>功能：删除数组的第一位数据，并且返回新数组的长度，会改变原来的数组</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str1 = [<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"hello"</span>];
<span class="hljs-built_in">console</span>.log(str1.shift());　　　　　　<span class="hljs-comment">//12</span>
<span class="hljs-built_in">console</span>.log(str1);　　　　　　　　　　　<span class="hljs-comment">//[2,"hello"]</span></code></pre>
<h3 id="5：unshift">5：unshift()</h3>
<p>功能：在数组的首位新增一个或多数据，并且返回新数组的长度，会改变原来的数组</p>
<p>注意：<code>unshift()</code>方法返回的数据是新数组的长度，它增加的数据可以是一个也可以是多个，可以理解为增加一连串的数据，</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str1 = [<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"hello"</span>];
<span class="hljs-keyword">var</span> str2 = [<span class="hljs-number">43</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"test"</span>];
<span class="hljs-built_in">console</span>.log(str1.unshift(<span class="hljs-string">"你好"</span>));　　　　　　　　　　　　　　<span class="hljs-comment">//4</span>
<span class="hljs-built_in">console</span>.log(str2.unshift(<span class="hljs-string">"hello"</span>,<span class="hljs-string">"world"</span>));　　　　　　　　<span class="hljs-comment">//5</span>
<span class="hljs-built_in">console</span>.log(str1);　　　　　　　　　　　　　　　　　　　　　　　<span class="hljs-comment">//["你好", 12, 2, "hello"]</span>
<span class="hljs-built_in">console</span>.log(str2);　　　　　　　　　　　　　　　　　　　　　　　<span class="hljs-comment">//["hello", "world", 43, 2, "test"]</span></code></pre>
<h3 id="6：push">6：push()</h3>
<p>功能：在数组的最后一位新增一个或多个数据，并且返回新数组的长度，会改变原来的数组</p>
<p>注意：push()方法返回的是数据是新数组的长度，它增加的数据可以是一个也可以是多个，可以理解为增加一连串的数据</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str1 = [<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"hello"</span>];
<span class="hljs-keyword">var</span> str2 = [<span class="hljs-number">43</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"test"</span>];
<span class="hljs-built_in">console</span>.log(str1.push(<span class="hljs-string">"你好"</span>));　　　　　　　　　　<span class="hljs-comment">//4</span>
<span class="hljs-built_in">console</span>.log(str2.push(<span class="hljs-string">"hello"</span>,<span class="hljs-string">"world"</span>));　　　　<span class="hljs-comment">//5</span>
<span class="hljs-built_in">console</span>.log(str1);　　　　　　　　　　　　　　　　　<span class="hljs-comment">//[12, 2, "hello","你好"]</span>
<span class="hljs-built_in">console</span>.log(str2);　　　　　　　　　　　　　　　　　<span class="hljs-comment">//[43, 2, "test","hello", "world"]</span></code></pre>
<h3 id="7：reverse">7：reverse()</h3>
<p>功能：将数组的数据进行反转，并且返回反转后的数组，会改变原数组</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str1 = [<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"hello"</span>];
<span class="hljs-built_in">console</span>.log(str1.reverse());　　　　　　<span class="hljs-comment">//["hello", 2, 12]</span>
<span class="hljs-built_in">console</span>.log(str1);　　　　　　　　　　　　<span class="hljs-comment">//["hello", 2, 12]</span></code></pre>
<h3 id="8：sort">8：sort()</h3>
<p>功能：对数组内的数据进行排序(默认为升序)，并且返回排过序的新数组，会改变原来的数组</p>
<p>注意：</p>
<ol>
<li>这里的排序是针对字符的排序，先使用数组的<code>toString()</code>方法转为字符串，再逐位比较，3是大于12的，因为首位3&gt;1，不要与<code>Number型</code>的数据排序混淆</li>
<li>str2数组中增加了三个字符，可以看到，比较的时候，<code>zoom</code>是最大的，因为首位的英文字母通过ASCII码可以转为相应的数值，再根据数值比较</li>
</ol>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str1 = [<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-number">43</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>];
<span class="hljs-keyword">var</span> str2 = [<span class="hljs-number">92</span>,<span class="hljs-number">2</span>,<span class="hljs-number">43</span>,<span class="hljs-string">"hello"</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>];
<span class="hljs-built_in">console</span>.log(str1.sort());<span class="hljs-comment">//[12, 2, 2, 43, 5, 5]</span>
<span class="hljs-built_in">console</span>.log(str1);<span class="hljs-comment">//[12, 2, 2, 43, 5, 5]</span>
<span class="hljs-built_in">console</span>.log(str2.sort());<span class="hljs-comment">//[2, 2, 43, 5, 5, 92, "abc", "hello", "zoom"]</span>
<span class="hljs-built_in">console</span>.log(str2);<span class="hljs-comment">//[2, 2, 43, 5, 5, 92, "abc", "hello", "zoom"]</span></code></pre>
<ol start="3">
<li>排序问题</li>
</ol>
<p>参数：<code>sort(callback)</code> 如果需要按照数值排序，需要传参。sort(callback)，callback为回调函数，该函数应该具有两个参数，比较这两个参数，然后返回一个用于说明这两个值的相对顺序的数字（a-b）。其返回值如下：</p>
<ul>
<li>若 a 小于 b，返回一个小于 0 的值。</li>
<li>若 a 等于 b，则返回 0。</li>
<li>若 a 大于 b，则返回一个大于 0 的值。</li>
</ul>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str3 = [<span class="hljs-number">92</span>,<span class="hljs-number">2</span>,<span class="hljs-number">43</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>];     
<span class="hljs-built_in">console</span>.log(str3.sort(fn));　　　　　　　　　　　　　　　　　<span class="hljs-comment">//[2, 2, 5, 5, 43, 92]</span>
<span class="hljs-built_in">console</span>.log(str3);　　　　　　　　　　　　　　　　　　　　　　<span class="hljs-comment">//[2, 2, 5, 5, 43, 92]</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">a,b</span>)</span>{
　　　　<span class="hljs-keyword">return</span> a-b;
 }</code></pre>
<h3 id="9：slice">9：slice()</h3>
<p>功能：截取指定位置的数组，并且返回截取的数组，不会改变原数组</p>
<p>参数：<code>slice(startIndex, endIndex)</code></p>
<p>注意：可从已有的数组中返回选定的元素。该方法接收两个参数<code>slice(start,end)</code>，strat为必选，表示从第几位开始；end为可选，表示到第几位结束(不包含end位)，省略表示到最后一位；start和end都可以为负数，负数时表示从最后一位开始算起，如-1表示最后一位。</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"T1"</span>,<span class="hljs-string">"J1"</span>,<span class="hljs-string">"L1"</span>,<span class="hljs-string">"L2"</span>,<span class="hljs-string">"M1"</span>];
    <span class="hljs-built_in">console</span>.log(arr.slice(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>));        <span class="hljs-comment">//["J1","L1"]</span>
    <span class="hljs-built_in">console</span>.log(arr.slice(<span class="hljs-number">1</span>));          <span class="hljs-comment">//["J1","L1","L2","M1"]</span>
    <span class="hljs-built_in">console</span>.log(arr.slice(-<span class="hljs-number">4</span>,-<span class="hljs-number">1</span>));      <span class="hljs-comment">//["J1","L1","L2"]</span>
    <span class="hljs-built_in">console</span>.log(arr.slice(-<span class="hljs-number">2</span>));         <span class="hljs-comment">//["Lily","M1"]</span>
    <span class="hljs-built_in">console</span>.log(arr.slice(<span class="hljs-number">1</span>,-<span class="hljs-number">2</span>));       <span class="hljs-comment">//["J1","L1"]</span>
    <span class="hljs-built_in">console</span>.log(arr);                   <span class="hljs-comment">//["T1","J1","L1","L2","M1"]</span></code></pre>
<h3 id="10：splice">10：splice()</h3>
<p>功能：向数组中添加，或从数组删除，或替换数组中的元素，然后返回被删除/替换的元素。</p>
<p>参数：<code>splice(start,num,data1,data2,...);</code> 所有参数全部可选。</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
<span class="hljs-built_in">console</span>.log(arr.splice(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>));<span class="hljs-comment">//[]</span>
<span class="hljs-built_in">console</span>.log(arr);<span class="hljs-comment">//["Tom", "Jack", "a", "b", "Lucy", "Lily", "May"]---原数组改变</span></code></pre>
<h3 id="11：toString">11：toString()</h3>
<p>功能：将数组转换成字符串，类似于没有参数的<code>join()</code>。该方法会在数据发生隐式类型转换时被自动调用，如果手动调用，就是直接转为字符串。不会改变原数组</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-built_in">console</span>.log(str.toString()); <span class="hljs-comment">//1,2,3</span>
<span class="hljs-built_in">console</span>.log(str);<span class="hljs-comment">//[1,2,3]</span></code></pre>
<h3 id="12：valueOf">12：valueOf()</h3>
<p>功能：返回数组的原始值（一般情况下其实就是数组自身），一般由js在后台调用，并不显式的出现在代码中</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-built_in">console</span>.log(str.valueOf()); <span class="hljs-comment">//[1,2,3]</span>
<span class="hljs-built_in">console</span>.log(str); <span class="hljs-comment">//[1,2,3]</span>
<span class="hljs-comment">//为了证明返回的是数组自身</span>
<span class="hljs-built_in">console</span>.log(str.valueOf() == str);<span class="hljs-comment">//true</span></code></pre>
<h3 id="13：IndexOf">13：IndexOf()</h3>
<p>功能：根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1，找到了指定的数据返回该数据的索引</p>
<p>参数：<code>indexOf(value, start)</code>;value为要查询的数据；start为可选，表示开始查询的位置，当start为负数时，从数组的尾部向前数；如果查询不到value的存在，则方法返回-1</p>
<p>注意：如果找到该数据，立即返回该数据的索引，不再往后继续查找</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str = [<span class="hljs-string">"h"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"o"</span>];
 <span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">"l"</span>));        <span class="hljs-comment">//2</span>
 <span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">"l"</span>,<span class="hljs-number">3</span>));      <span class="hljs-comment">//3</span>
 <span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">"l"</span>,<span class="hljs-number">4</span>));      <span class="hljs-comment">//-1</span>
 <span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">"l"</span>,-<span class="hljs-number">1</span>));     <span class="hljs-comment">//-1</span>
 <span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">"l"</span>,-<span class="hljs-number">3</span>));     <span class="hljs-comment">//2</span></code></pre>
<h3 id="14：lastIndexOf">14：lastIndexOf()</h3>
<p>功能：根据指定的数据，从左向右，查询在数组中出现的位置，如果不存在指定的数据，返回-1，找到了指定的数据返回该数据的索引</p>
<p>参数：<code>indexOf(value, start)</code>;value为要查询的数据；start为可选，表示开始查询的位置，当start为负数时，从数组的尾部向前数；如果查询不到value的存在，则方法返回-1</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> str = [<span class="hljs-string">"h"</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"l"</span>,<span class="hljs-string">"o"</span>];
<span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">"l"</span>));        <span class="hljs-comment">//2</span>
<span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">"l"</span>,<span class="hljs-number">3</span>));      <span class="hljs-comment">//3</span>
<span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">"l"</span>,<span class="hljs-number">4</span>));      <span class="hljs-comment">//-1</span>
<span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">"l"</span>,-<span class="hljs-number">1</span>));     <span class="hljs-comment">//-1</span>
<span class="hljs-built_in">console</span>.log(str.indexOf(<span class="hljs-string">"l"</span>,-<span class="hljs-number">3</span>));     <span class="hljs-comment">//2</span></code></pre>
<h3 id="15：forEach">15：forEach()</h3>
<p>功能：ES5新增的方法，用来遍历数组，没有返回值，</p>
<p>参数：<code>forEach(callback)</code>;callback默认有三个参数，分别为value(遍历到的数组的数据)，index(对应的索引)，self(数组自身)。</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
<span class="hljs-keyword">var</span> a = arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
     <span class="hljs-built_in">console</span>.log(value + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr === self));
})
<span class="hljs-comment">// 打印结果为：</span>
<span class="hljs-comment">// Tom--0--true</span>
<span class="hljs-comment">// Jack--1--true</span>
<span class="hljs-comment">// Lucy--2--true</span>
<span class="hljs-comment">// Lily--3--true</span>
<span class="hljs-comment">// May--4--true</span>
<span class="hljs-built_in">console</span>.log(a);     <span class="hljs-comment">//undefined---forEach没有返回值</span>
<span class="hljs-comment">//该方法为遍历方法，不会修改原数组</span></code></pre>
<h3 id="16：map">16：map()</h3>
<p>功能：</p>
<ol>
<li>同<code>forEach</code>功能；</li>
<li>map的回调函数会将执行结果返回，最后map将所有回调函数的返回值组成新数组返回。</li>
</ol>
<p>参数：<code>map(callback)</code>;callback默认有三个参数，分别为value，index，self。跟上面的forEach()的参数一样</p>
<pre><code class="hljs js"><span class="hljs-comment">//功能1：同forEach</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(value + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr === self))
    })
    <span class="hljs-comment">// 打印结果为：</span>
    <span class="hljs-comment">// Tom--0--true</span>
    <span class="hljs-comment">// Jack--1--true</span>
    <span class="hljs-comment">// Lucy--2--true</span>
    <span class="hljs-comment">// Lily--3--true</span>
    <span class="hljs-comment">// May--4--true</span>

    <span class="hljs-comment">//功能2：每次回调函数的返回值被map组成新数组返回</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"hi:"</span>+value;
    })
    <span class="hljs-built_in">console</span>.log(a);     <span class="hljs-comment">//["hi:Tom", "hi:Jack", "hi:Lucy", "hi:Lily", "hi:May"]</span>
    <span class="hljs-built_in">console</span>.log(arr);   <span class="hljs-comment">//["Tom", "Jack", "Lucy", "Lily", "May"]---原数组未改变</span></code></pre>
<h3 id="17：filter">17：filter()</h3>
<p>功能：1.同<code>forEach</code>功能；2.<code>filter</code>的回调函数需要返回布尔值，当为true时，将本次数组的数据返回给filter，最后filter将所有回调函数的返回值组成新数组返回（此功能可理解为“过滤”）。</p>
<p>参数：<code>filter(callback)</code>;callback默认有三个参数，分别为value，index，self。</p>
<pre><code class="hljs js"><span class="hljs-comment">//功能1：同forEach</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(value + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr === self))
    })
    <span class="hljs-comment">// 打印结果为：</span>
    <span class="hljs-comment">// Tom--0--true</span>
    <span class="hljs-comment">// Jack--1--true</span>
    <span class="hljs-comment">// Lucy--2--true</span>
    <span class="hljs-comment">// Lily--3--true</span>
    <span class="hljs-comment">// May--4--true</span>

    <span class="hljs-comment">//功能2：当回调函数的返回值为true时，本次的数组值返回给filter，被filter组成新数组返回</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-keyword">return</span> value.length &gt; <span class="hljs-number">3</span>;
    })
    <span class="hljs-built_in">console</span>.log(a);         <span class="hljs-comment">//["Jack", "Lucy", "Lily"]</span>
    <span class="hljs-built_in">console</span>.log(arr);       <span class="hljs-comment">//["Tom", "Jack", "Lucy", "Lily", "May"]---原数组未改变</span></code></pre>
<h3 id="18：every">18：every()</h3>
<p>功能：判断数组中每一项是否都满足条件，只有所有项都满足条件，才会返回true。</p>
<p>参数：<code>every()</code>接收一个回调函数作为参数，这个回调函数需要有返回值，<code>every(callback)</code>;callback默认有三个参数，分别为value，index，self。</p>
<p>功能1：当回调函数的返回值为true时，类似于<code>forEach</code>的功能，遍历所有；如果为false，那么停止执行，后面的数据不再遍历，停在第一个返回false的位置。</p>
<pre><code class="hljs js"><span class="hljs-comment">//demo1:</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(value + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr == self))
    })
    <span class="hljs-comment">// 打印结果为：</span>
    <span class="hljs-comment">// Tom--0--true</span>
    <span class="hljs-comment">//因为回调函数中没有return true，默认返回undefined，等同于返回false</span>

    <span class="hljs-comment">//demo2:</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(value + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr == self))
        <span class="hljs-keyword">return</span> value.length &lt; <span class="hljs-number">4</span>;
    })
    <span class="hljs-comment">// 打印结果为：</span>
    <span class="hljs-comment">// Tom--0--true</span>
    <span class="hljs-comment">// abc--1--true</span>
    <span class="hljs-comment">// Jack--2--true</span>
    <span class="hljs-comment">//因为当遍历到Jack时，回调函数到return返回false，此时Jack已经遍历，但是后面数据就不再被遍历了</span>

    <span class="hljs-comment">//demo3:</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(value + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr == self))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    })
    <span class="hljs-comment">// 打印结果为：</span>
    <span class="hljs-comment">// Tom--0--true</span>
    <span class="hljs-comment">// abc--1--true</span>
    <span class="hljs-comment">// Jack--2--true</span>
    <span class="hljs-comment">// Lucy--3--true</span>
    <span class="hljs-comment">// Lily--4--true</span>
    <span class="hljs-comment">// May--5--true</span>
    <span class="hljs-comment">//因为每个回调函数的返回值都是true，那么会遍历数组所有数据，等同于forEach功能</span></code></pre>
<p>功能2：当每个回调函数的返回值都为true时，every的返回值为true，只要有一个回调函数的返回值为false，every的返回值都为false</p>
<pre><code class="hljs js"><span class="hljs-comment">//demo1:</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-keyword">return</span> value.length &gt; <span class="hljs-number">3</span>;
    })
    <span class="hljs-built_in">console</span>.log(a);           <span class="hljs-comment">//false</span>

    <span class="hljs-comment">//demo2:</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-keyword">return</span> value.length &gt; <span class="hljs-number">2</span>;
    })
    <span class="hljs-built_in">console</span>.log(a);           <span class="hljs-comment">//true</span></code></pre>
<h3 id="19：some">19：some()</h3>
<p>功能：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</p>
<p>参数：<code>some()</code>接收一个回调函数作为参数，这个回调函数需要有返回值，<code>some(callback)</code>;callback默认有三个参数，分别为value，index，self。</p>
<p>功能1：因为要判断数组中的每一项，只要有一个回调函数返回true，some都会返回true，所以与every正好相反，当遇到一个回调函数的返回值为true时，可以确定结果，那么停止执行，后面都数据不再遍历，停在第一个返回true的位置；当回调函数的返回值为false时，需要继续向后执行，到最后才能确定结果，所以会遍历所有数据，实现类似于<code>forEach</code>的功能，遍历所有。</p>
<pre><code class="hljs js"><span class="hljs-comment">//demo1:</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(value + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr == self))
        <span class="hljs-keyword">return</span> value.length &gt; <span class="hljs-number">3</span>;
    })
    <span class="hljs-comment">// 打印结果为：</span>
    <span class="hljs-comment">// Tom--0--true</span>
    <span class="hljs-comment">// abc--1--true</span>
    <span class="hljs-comment">// Jack--2--true</span>

    <span class="hljs-comment">//demo2:</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(value + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr == self))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    })
    <span class="hljs-comment">// 打印结果为：</span>
    <span class="hljs-comment">// Tom--0--true</span>

    <span class="hljs-comment">//demo3:</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(value + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr == self))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    })
    <span class="hljs-comment">// 打印结果为：</span>
    <span class="hljs-comment">// Tom--0--true</span>
    <span class="hljs-comment">// abc--1--true</span>
    <span class="hljs-comment">// Jack--2--true</span>
    <span class="hljs-comment">// Lucy--3--true</span>
    <span class="hljs-comment">// Lily--4--true</span>
    <span class="hljs-comment">// May--5--true</span></code></pre>
<p>功能2：与every相反，只要有一个回调函数的返回值都为true，some的返回值为true，所有回调函数的返回值为false，some的返回值才为false</p>
<pre><code class="hljs js"><span class="hljs-comment">//demo1:</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-keyword">return</span> value.length &gt; <span class="hljs-number">3</span>;
    })
    <span class="hljs-built_in">console</span>.log(a);             <span class="hljs-comment">//true</span>

    <span class="hljs-comment">//demo2:</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Tom"</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"Jack"</span>,<span class="hljs-string">"Lucy"</span>,<span class="hljs-string">"Lily"</span>,<span class="hljs-string">"May"</span>];
    <span class="hljs-keyword">var</span> a = arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,self</span>)</span>{
        <span class="hljs-keyword">return</span> value.length &gt; <span class="hljs-number">4</span>;
    })
    <span class="hljs-built_in">console</span>.log(a);             <span class="hljs-comment">//false</span></code></pre>
<h3 id="20：reduce">20：reduce()</h3>
<p>功能：从数组的第一项开始，逐个遍历到最后，迭代数组的所有项，然后构建一个最终返回的值。</p>
<p>参数：<code>reduce()</code>接收一个或两个参数：第一个是回调函数，表示在数组的每一项上调用的函数；第二个参数（可选的）作为归并的初始值，被回调函数第一次执行时的第一个参数接收。 <code>reduce(callback,initial)</code>;callback默认有四个参数，分别为<code>prev，now，index，self</code>。  callback返回的任何值都会作为下一次执行的第一个参数。  如果initial参数被省略，那么第一次迭代发生在数组的第二项上，因此callback的第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<pre><code class="hljs js"><span class="hljs-comment">//demo1:不省略initial参数，回调函数没有返回值</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];
    arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev,now,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(prev + <span class="hljs-string">"--"</span> + now + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr == self))
    }, <span class="hljs-number">2019</span>)
    <span class="hljs-comment">// 打印结果为：</span>
    <span class="hljs-comment">// 2019--10--0--true</span>
    <span class="hljs-comment">// undefined--20--1--true</span>
    <span class="hljs-comment">// undefined--30--2--true</span>
    <span class="hljs-comment">// undefined--40--3--true</span>
    <span class="hljs-comment">// undefined--50--4--true</span>
    <span class="hljs-comment">// 此时回调函数没有return，所以从第二次开始，prev拿到的是undefined</span>

    <span class="hljs-comment">//demo2:省略initial参数，回调函数没有返回值</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];
    arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev,now,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(prev + <span class="hljs-string">"--"</span> + now + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr == self))
    })
    <span class="hljs-comment">// 打印结果为：第一次，回调函数的第一个参数是数组的第一项。第二个参数就是数组的第二项</span>
    <span class="hljs-comment">// 10--20--1--true</span>
    <span class="hljs-comment">// undefined--30--2--true</span>
    <span class="hljs-comment">// undefined--40--3--true</span>
    <span class="hljs-comment">// undefined--50--4--true</span>
    <span class="hljs-comment">// 此时回调函数没有return，所以从第二次开始，prev拿到的是undefined</span>

    <span class="hljs-comment">//demo3:不省略initial参数，回调函数有返回值</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];
    arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev,now,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(prev + <span class="hljs-string">"--"</span> + now + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr == self));
        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;
    }, <span class="hljs-number">2019</span>)
    <span class="hljs-comment">// 打印结果为：</span>
    <span class="hljs-comment">// 2019--10--0--true</span>
    <span class="hljs-comment">// hello--20--1--true</span>
    <span class="hljs-comment">// hello--30--2--true</span>
    <span class="hljs-comment">// hello--40--3--true</span>
    <span class="hljs-comment">// hello--50--4--true</span>
    <span class="hljs-comment">// 此时回调函数有return，所以从第二次开始，prev拿到的是回调函数return的值</span>

    <span class="hljs-comment">//demo4:省略initial参数，回调函数有返回值</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];
    arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev,now,index,self</span>)</span>{
        <span class="hljs-built_in">console</span>.log(prev + <span class="hljs-string">"--"</span> + now + <span class="hljs-string">"--"</span> + index + <span class="hljs-string">"--"</span> + (arr == self));
        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;
    })
    <span class="hljs-comment">// 打印结果为：第一次，回调函数的第一个参数是数组的第一项。第二个参数就是数组的第二项</span>
    <span class="hljs-comment">// 10--20--1--true</span>
    <span class="hljs-comment">// hello--30--2--true</span>
    <span class="hljs-comment">// hello--40--3--true</span>
    <span class="hljs-comment">// hello--50--4--true</span>
    <span class="hljs-comment">// 此时回调函数有return，所以从第二次开始，prev拿到的是回调函数return的值</span>

    <span class="hljs-comment">//demo5：使用reduce计算数组中所有数据的和</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];
    <span class="hljs-keyword">var</span> sum = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev,now,index,self</span>)</span>{
        <span class="hljs-keyword">return</span> prev + now;
    })
    <span class="hljs-built_in">console</span>.log(sum);      <span class="hljs-comment">//150</span>
    <span class="hljs-comment">// 回调函数的最后一次return的结果被返回到reduce方法的身上</span>

    <span class="hljs-comment">//demo6：使用reduce计算数组中所有数据的和</span>
    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>];
    <span class="hljs-keyword">var</span> sum = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev,now,index,self</span>)</span>{
        <span class="hljs-keyword">return</span> prev + now;
    }, <span class="hljs-number">8</span>)
    <span class="hljs-built_in">console</span>.log(sum);      <span class="hljs-comment">//158</span>
    <span class="hljs-comment">// 回调函数的最后一次return的结果被返回到reduce方法的身上</span>
    <span class="hljs-comment">// 因为reduce有第二个参数initial，在第一次执行时被计算，所以最终结果被加上8</span></code></pre>
<h3 id="21：reduceRight">21：reduceRight()</h3>
<p>功能：（与reduce类似）从数组的最后一项开始，向前逐个遍历到第一位，迭代数组的所有项，然后构建一个最终返回的值。</p>
<p>参数：<code>同reduce。 demo：同reduce</code></p>
]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>前端</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门03基于注解方式的IOC</title>
    <url>/2020/03/03/spring/Spring%E5%85%A5%E9%97%A803%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E7%9A%84IOC/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2014/09/07/22/17/forest-438432_1280.jpg" alt=""></p>
<hr>
<h1>Spring入门03基于注解方式的IOC</h1>
<h2 id="1-配置环境">1 配置环境</h2>
<p>在 bean.xml 中导入约束</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">注意：基于注解整合时，导入约束时需要多导入一个 context 名称空间下的约束。</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>
    
   <span class="hljs-comment">&lt;!-- 告知 spring 创建容器时要扫描的包 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.itheima"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
<h2 id="2-常用注解">2 常用注解</h2>
<h3 id="2-1-用于注入对象的">2.1 用于注入对象的</h3>
<pre><code class="hljs xml">&lt;！--相当于--&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">""</span>&gt;</span></code></pre>
<h4 id="Component-：">@Component  ：</h4>
<p>作用：把资源让 spring 来管理。相当于在 xml 中配置一个 bean。<br>
属性：value：指定 bean 的 id。<code>如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。</code></p>
<p>如果注解中有且只有一个属性要赋值时，且名称是 value， value 在赋值是可以不写。</p>
<p><code>下面三个注解都是针对 @Component 的衍生注解</code>，作用及属性都是一模一样的。只不过是提供了更加明确的语义化。</p>
<h4 id="Controller-：一般用于表现层的注解">@Controller ：一般用于表现层的注解</h4>
<h4 id="Service-：一般用于业务层的注解。">@Service ：一般用于业务层的注解。</h4>
<h4 id="Repository：-一般用于持久层的注解。">@Repository：  一般用于持久层的注解。</h4>
<h3 id="2-2-用于注入数据的">2.2 用于注入数据的</h3>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--相当于--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">""</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span></code></pre>
<h4 id="Autowired-：">@Autowired  ：</h4>
<p>自动按照类型注入。当使用注解注入属性时， <code>set 方法可以省略</code>。它只能注入其他 bean 类型。当有多个<br>
类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到<br>
就报错</p>
<pre><code class="hljs java"><span class="hljs-meta">@AutoWired(required=false)</span><span class="hljs-comment">//这样指定如果找不到组件，也不会报错，默认为 null</span></code></pre>
<p>作用位置：构造器，参数，方法，属性</p>
<pre><code class="hljs java"><span class="hljs-comment">//方法上</span>
<span class="hljs-comment">//Spring 创建当前对象，就会调用该方法，完成赋值</span>
<span class="hljs-comment">//方法使用的参数，自定义类型的值从 ioc 容器中获取</span>
<span class="hljs-meta">@Autowired</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCar</span><span class="hljs-params">(Car car)</span></span>{
    <span class="hljs-keyword">this</span>.car=car;
}

<span class="hljs-comment">//构造器上</span>
<span class="hljs-comment">//默认情况下，在ioc的容器会自动调用无参构造方法创建对象，在进行初始化赋值等操作</span>
<span class="hljs-comment">//构造器使用的参数，自定义类型的值从 ioc 容器中获取</span>
<span class="hljs-comment">//如果组件只有一个有参构造器，那么 @AutoWired 可以省略，还是可以自动注入</span>
<span class="hljs-meta">@AutoWired</span>
<span class="hljs-keyword">public</span> Boss（Car car）{
    <span class="hljs-keyword">this</span>.car=car;
}

<span class="hljs-comment">//参数上</span>
<span class="hljs-keyword">public</span> Boss（<span class="hljs-meta">@AutoWired</span> Car car）{
    <span class="hljs-keyword">this</span>.car=car;
}


<span class="hljs-comment">//@Bean标注的方法创建对象的时候，方法参数默认从容器中获取,</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Color <span class="hljs-title">color</span><span class="hljs-params">(Car car)</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Color();
}</code></pre>
<h4 id="Qualifier-：">@Qualifier  ：</h4>
<p>作用：在自动按照类型注入的基础之上，明确指定按照 Bean 的 id 注入。它在给字段注入时不能独立使用，必须和<code>@Autowired </code>一起使用</p>
<p>但是给方法参数注入时，可以独立使用。<br>
属性：value：指定 bean 的 id。</p>
<h4 id="Resource">@Resource  :</h4>
<p>作用：直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。属于java 规范的注解，不是spring规范的注解，所以不会支持spring的注解。<br>
属性：name：指定 bean 的 id。</p>
<h4 id="Value">@Value  :</h4>
<p>作用：注入基本数据类型和 String 类型数据的<br>
属性：value：用于指定值 ，可以作用于参数上，可以使用${}取出配置文件中的值</p>
<pre><code class="hljs java"><span class="hljs-meta">@Bean(value = "dataSource")</span><span class="hljs-comment">// &lt;bean id="dataSource"</span>
    <span class="hljs-meta">@Lazy(false)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">newDataSource</span><span class="hljs-params">(<span class="hljs-meta">@Value("${jdbcDriver}")</span> String driverClass,<span class="hljs-meta">@Value("${jdbcUrl}")</span> String jdbcUrl,</span></span>
<span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Value("${jdbcUser}")</span> String username, <span class="hljs-meta">@Value("${jdbcPassword}")</span> String password)</span> </span>{

        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();
        dataSource.setUrl(jdbcUrl);
        dataSource.setDriverClassName(driverClass);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        <span class="hljs-comment">// 配置其他东西自行使用set方法设置</span>
        <span class="hljs-keyword">return</span> dataSource;
    }</code></pre>
<h4 id="Inject">@Inject</h4>
<p>使用前需要导入依赖 javax.inject，和 <code>@AutoWired</code> 的功能一样，但没有其他属性。属于java 规范的注解，不是spring规范的注解，所以不会支持spring的注解。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependncy</span>&gt;</span>
</code></pre>
<h4 id="使用底层组件的方法">使用底层组件的方法</h4>
<p>自定义的组件想要使用Spring底层的一些组件（ApplicationContext，BeanFactory,…），自定义组件需实现<code>XXXAware</code>，创建对象时，会调用接口的方法注入相关的组件，（<code>XXXAware</code>的功能是通过 <code>XXXProcessor</code> 的后置处理器来返回我们需要的组件）</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/spring/image-20200619222247286.png" alt="image-20200619222247286" style="zoom: 80%;">
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hnust.domain;
<span class="hljs-keyword">import</span> org.springframework.beans.BeansException;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanNameAware;
<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;
<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContextAware;
<span class="hljs-keyword">import</span> org.springframework.context.EmbeddedValueResolverAware;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> org.springframework.util.StringValueResolver;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span>, <span class="hljs-title">BeanNameAware</span>, <span class="hljs-title">EmbeddedValueResolverAware</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String name)</span> </span>{
        System.out.println(<span class="hljs-string">"当前bean的名字："</span>+name);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        <span class="hljs-comment">//获取ioc容器</span>
        System.out.println(applicationContext);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver resolver)</span> </span>{
        <span class="hljs-comment">//用于解析字符串的组件</span>
        String str=resolver.resolveStringValue(<span class="hljs-string">"你好${os.name}"</span>);
        System.out.println(str);
    }
}java
</code></pre>
<h3 id="2-3-用于改变作用范围的：">2.3 用于改变作用范围的：</h3>
<pre><code class="hljs xml">&lt;！--相当于--&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">""</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">""</span>&gt;</span></code></pre>
<h4 id="Scope">@Scope</h4>
<p>作用：指定 bean 的作用范围。<br>
属性：value：指定范围的值。<br>
取值：<code> singleton</code> <code> prototype</code> <code>request </code> <code>session</code> <code>globalsession </code></p>
<h4 id="Lazy">@Lazy</h4>
<p>作用：容器启动时不创建对象，第一次使用（获取）Bean创建对象，并初始化。注意要和注入组件的注解一起用。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Bean("person")</span>
<span class="hljs-meta">@Lazy</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Persion <span class="hljs-title">getPersion</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();
}</code></pre>
<h3 id="2-4-和生命周期相关的">2.4 和生命周期相关的</h3>
<p>bean的生命周期：创建------初始化------销毁</p>
<ul>
<li>创建：可以使用构造方法
<ul>
<li>容器创建时单例对象被创建</li>
<li>使用（获取）时多例对象被创建</li>
</ul>
</li>
<li>初始化：对象创建完成，并赋值好，调用初始化方法</li>
<li>销毁：
<ul>
<li>容器关闭时，销毁单实例</li>
<li>容器关闭时，不会管理多实例，即不会调用销毁方法</li>
</ul>
</li>
</ul>
<h4 id="使用注解管理生命周期的几种方法：">使用注解管理生命周期的几种方法：</h4>
<ol>
<li>
<p>通过 @Bean 的<code>init-method</code>和 <code>destroy-method</code> 属性（在对象的方法中选择）</p>
</li>
<li>
<p>通过让 Bean 实现  <code>InitializingBean</code>(定义初始化逻辑)  和  <code>DisposableBean</code> (定义销毁逻辑)</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> domain;

<span class="hljs-keyword">import</span> org.springframework.beans.factory.DisposableBean;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.InitializingBean;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">DisposableBean</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        System.out.println(<span class="hljs-string">"销毁方法"</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        System.out.println(<span class="hljs-string">"初始化方法"</span>);
    }
}
</code></pre>
</li>
<li>
<p>使用以下的注解</p>
</li>
</ol>
<pre><code class="hljs xml">&lt;！--相当于--&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">""</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">""</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">""</span>&gt;</span></code></pre>
<h4 id="PostConstruct">@PostConstruct</h4>
<p>作用：用于指定初始化方法。直接标注在方法上，在对象创建并赋值之后调用</p>
<h4 id="PreDestroy">@PreDestroy</h4>
<p>作用：用于指定销毁方法。  直接标注在方法上，在对象销毁之前调用</p>
<ol start="4">
<li>
<p>使用<code>BeanPostProcessor</code>后置处理器（该处理器可用于识别注入数据的注解）</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> config;

<span class="hljs-keyword">import</span> org.springframework.beans.BeansException;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-meta">@Component</span><span class="hljs-comment">//将后置处理器加入容器中，所有的组件初始化前后都会经过它</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * </span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bean 创建的实例</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName 创建的实例的名字</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 直接返回 bean</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> BeansException</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        System.out.println(<span class="hljs-string">"创建完成之后，初始化之前调用"</span>);
        <span class="hljs-keyword">return</span> bean;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        System.out.println(<span class="hljs-string">"初始化之后调用，销毁之前"</span>);
        <span class="hljs-keyword">return</span> bean;
    }
}
</code></pre>
</li>
</ol>
<h3 id="2-5-和配置相关">2.5 和配置相关</h3>
<h4 id="Configuration">@Configuration</h4>
<p>作用：用于指定当前类是一个 Spring 配置类， 当创建容器时会从该类上加载注解。</p>
<p>属性：value:用于指定配置类的字节码</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* spring 的配置类，相当于 bean.xml 文件</span>
<span class="hljs-comment">* <span class="hljs-doctag">@author</span> </span>
<span class="hljs-comment">* <span class="hljs-doctag">@Company</span> </span>
<span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span> </span>{
}

<span class="hljs-comment">//注意：我们已经把配置文件用类来代替了， 但是如何配置创建容器时要扫描的包呢？请看下一个注解。</span></code></pre>
<h4 id="ComponentScan">@ComponentScan</h4>
<p>作用：用于指定 spring 在初始化容器时要扫描注解的包。 作用和在 spring 的 xml 配置文件中的：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.itheima"</span>/&gt;</span></code></pre>
<p>是一样的。<br>
属性：basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。</p>
<p><code>excludeFilters</code>：按照哪些规则（type属性）排除哪些组件（classes属性）</p>
<p><code>includeFilters</code>：扫描的时候只要哪些组件，注意加入 （ useDefaultFilters = false ）</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* spring 的配置类，相当于 bean.xml 文件</span>
<span class="hljs-comment">* <span class="hljs-doctag">@author</span> 黑马程序员</span>
<span class="hljs-comment">* <span class="hljs-doctag">@Company</span> http://www.ithiema.com</span>
<span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = {"dao","service"},excludeFilters = {</span>
<span class="hljs-meta">        @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {Service.class}),//指定注解</span>
<span class="hljs-meta">    @ComponentScan.Filter(type= FilterType.ASIGNABLE_TYPE,classes = {UserServiceImpl.class})，//指定类型</span>
<span class="hljs-meta">    @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {MyFilter.class})  //指定自定义类型  </span>
<span class="hljs-meta">})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span> </span>{
}
<span class="hljs-comment">//注意：我们已经配置好了要扫描的包，但是数据源和 JdbcTemplate 对象如何从配置文件中移除呢？请看下一个注解。</span></code></pre>
<p>自定义类型过滤类，根据  <code>excludeFilters </code>（true为排除，false为包含），<code>includeFilters </code>反之</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> config;

<span class="hljs-keyword">import</span> org.springframework.core.io.Resource;
<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotationMetadata;
<span class="hljs-keyword">import</span> org.springframework.core.type.ClassMetadata;
<span class="hljs-keyword">import</span> org.springframework.core.type.classreading.MetadataReader;
<span class="hljs-keyword">import</span> org.springframework.core.type.classreading.MetadataReaderFactory;
<span class="hljs-keyword">import</span> org.springframework.core.type.filter.TypeFilter;

<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">TypeFilter</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metadataReader  读取当前正在扫描的类的信息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metadataReaderFactory 可以获取到其他类的信息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-comment">//获取当前类注解的信息</span>
        AnnotationMetadata annotationMetadata=metadataReader.getAnnotationMetadata();
        <span class="hljs-comment">//获取当前正在扫描的类信息</span>
        ClassMetadata classMetadata=metadataReader.getClassMetadata();
        <span class="hljs-comment">//获取当前类资源信息（类路径）</span>
        Resource resource=metadataReader.getResource();
        
        System.out.println(classMetadata.getClassName());
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
}
</code></pre>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = {"dao","service"},includeFilters = {</span>
<span class="hljs-meta">        @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {Service.class})</span>
<span class="hljs-meta">},useDefaultFilters=false)</span></code></pre>
<h4 id="Bean">@Bean</h4>
<p>作用：该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。默认方法名是其 id</p>
<p>属性：name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 连接数据库的配置类</span>
<span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcConfig</span> </span>{
    
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个数据源，并存入 spring 容器中</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Bean(name="dataSource")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">try</span> {
ComboPooledDataSource ds = <span class="hljs-keyword">new</span> ComboPooledDataSource();
ds.setUser(<span class="hljs-string">"root"</span>);
ds.setPassword(<span class="hljs-string">"1234"</span>);
ds.setDriverClass(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);
ds.setJdbcUrl(<span class="hljs-string">"jdbc:mysql:///spring_day02"</span>);
<span class="hljs-keyword">return</span> ds;
} <span class="hljs-keyword">catch</span> (Exception e) {
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
}
}
    
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个 DBAssit，并且也存入 spring 容器中</span>
<span class="hljs-comment">* <span class="hljs-doctag">@param</span> dataSource</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Bean(name="dbAssit")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> DBAssit <span class="hljs-title">createDBAssit</span><span class="hljs-params">(DataSource dataSource)</span> </span>{
<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DBAssit(dataSource);
}
}
<span class="hljs-comment">//注意:</span>
<span class="hljs-comment">/*我们已经把数据源和 DBAssit 从配置文件中移除了，此时可以删除 bean.xml 了。</span>
<span class="hljs-comment">但是由于没有了配置文件，创建数据源的配置又都写死在类中了。*/</span></code></pre>
<h4 id="Conditional">@Conditional</h4>
<p>作用：根据条件决定是否加载注解的组件进入容器，注意要和注入组件的注解一起用。放在类上，表示该类所有注册bean的方法都会有该条件。</p>
<p>属性：判断条件（类实现了 <code>Conditional</code>接口）</p>
<pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@Conditional({MyCondition.class})</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">now</span><span class="hljs-params">()</span></span>{
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date();
   }</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> config;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactory;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Condition;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.ConditionContext;
<span class="hljs-keyword">import</span> org.springframework.core.env.Environment;
<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 判断条件能使用的上下文环境</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metadata 注释信息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true则加载，false则不加载</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{
        <span class="hljs-comment">//获取Ioc使用的 BeanFactory</span>
        BeanFactory beanFactory=context.getBeanFactory();
        <span class="hljs-comment">//获取类加载器</span>
        ClassLoader classLoader = context.getClassLoader();
        <span class="hljs-comment">//获取当前环境信息</span>
        Environment environment = context.getEnvironment();
        <span class="hljs-comment">//获取到 bean 定义的注册类</span>
        BeanDefinitionRegistry registry = context.getRegistry();

        String property = environment.getProperty(<span class="hljs-string">"os.name"</span>);
        System.out.println(property);
        <span class="hljs-keyword">assert</span> property != <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">//return property.contains("Windows");//根据环境来判断</span>
        <span class="hljs-keyword">return</span> registry.containsBeanDefinition(<span class="hljs-string">"accountDaoImpl"</span>);<span class="hljs-comment">//根据是否包含某个id的组件来判断</span>
    }
}
</code></pre>
<h4 id="PropertySource">@PropertySource</h4>
<p>作用：用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到</p>
<p>properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。</p>
<p>属性：value[]：用于指定多个 properties 文件位置。如果是在类路径下，需要写上 classpath:</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 连接数据库的配置类</span>
<span class="hljs-comment">* <span class="hljs-doctag">@author</span> 黑马程序员</span>
<span class="hljs-comment">* <span class="hljs-doctag">@Company</span> http://www.ithiema.com</span>
<span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@PropertySource("classpath:jdbc.properties")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcConfig</span> </span>{
<span class="hljs-meta">@Value("${jdbc.driver}")</span>
<span class="hljs-keyword">private</span> String driver;
<span class="hljs-meta">@Value("${jdbc.url}")</span>
<span class="hljs-keyword">private</span> String url;
<span class="hljs-meta">@Value("${jdbc.username}")</span>
<span class="hljs-keyword">private</span> String username;
<span class="hljs-meta">@Value("${jdbc.password}")</span>
<span class="hljs-keyword">private</span> String password;
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个数据源，并存入 spring 容器中</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Bean(name="dataSource")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">try</span> {
ComboPooledDataSource ds = <span class="hljs-keyword">new</span> ComboPooledDataSource();
ds.setDriverClass(driver);
ds.setJdbcUrl(url);
ds.setUser(username);
ds.setPassword(password);
<span class="hljs-keyword">return</span> ds;
} <span class="hljs-keyword">catch</span> (Exception e) {
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
}
}
}</code></pre>
<p>配置文件中的值默认加到了环境中</p>
<pre><code class="hljs java">ConfigurableEnvironment environment=(ConfigurableEnvironment) ac.getEnvironment();
String property=environment.getProperty(<span class="hljs-string">"jdbc.url"</span>);</code></pre>
<h4 id="Import">@Import</h4>
<p>作用：用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。 当然，写上也没问<br>
题。<br>
属性：value[]：用于指定其他配置类的字节码。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = "com.itheima.spring")</span>
<span class="hljs-meta">@Import({ JdbcConfig.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span> </span>{
}


<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@PropertySource("classpath:jdbc.properties")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcConfig</span></span>{
}</code></pre>
<p>除了直接指定类的字节码外，也可以配置导入类（实现<code> ImportSelector</code>接口）来导入</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import({MyImportSelector.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>{
}</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> config;

<span class="hljs-keyword">import</span> org.springframework.context.annotation.ImportSelector;
<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotationMetadata;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * </span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> importingClassMetadata 当前标注 <span class="hljs-doctag">@Import</span> 注解的类的所有信息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 就是要导入到容器容器中的全类名，可以返回空数组，但不要返回null</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]{<span class="hljs-string">"com.hnust.XXXX"</span>};
<span class="hljs-comment">//        return new String[0];</span>
    }
}
</code></pre>
<p>配置注册类（实现<code>ImportBeanDefinitionRegistrar</code> 接口）</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import({MyImportBeanRegistrer.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>{
}</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> config;

<span class="hljs-keyword">import</span> dao.impl.AccountDaoImpl;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.support.RootBeanDefinition;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.ImportBeanDefinitionRegistrar;
<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotationMetadata;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportBeanRegistrer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> importingClassMetadata 当前类的注解信息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry BeanDefinitionRegistry 注册类，可以用于组件的注册，手动的注册组件</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>{
        <span class="hljs-comment">//如果容器中没有该组件，就手动注册该组件    </span>
        <span class="hljs-keyword">if</span>(!registry.containsBeanDefinition(<span class="hljs-string">"now"</span>)){
            <span class="hljs-comment">//指定 Bean 的类型</span>
                RootBeanDefinition rootBeanDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition(AccountDaoImpl.class)
                    <span class="hljs-comment">//注册一个Bean</span>
                registry.registerBeanDefinition(<span class="hljs-string">"now"</span>,rootBeanDefinition);
            }
    }
}
</code></pre>
<h4 id="Primary">@Primary</h4>
<p>和注入对象的注解一起用，用该注解的组件，其他组件要用到该类型的组件时，会优先使用它，但注意优先级比 @Qualifier 低。</p>
<h4 id="Profile">@Profile</h4>
<p>作用：指定组件在哪个环境下才能注册到容器中，加了环境标识的bean ，只有环境被激活的时候才会加载到容器中，没有标注  @Profile 的组件在任何环境下都能加载。</p>
<p>Profile：Spring 为我们提供的可以根据当前环境（开发环境，测试环境，生产环境），动态的激活和切换一系列组件的功能</p>
<p>作用位置：@Bean方法上，类上</p>
<p>环境的激活：</p>
<ol>
<li>
<p><code>-Dspring.profiles.active=test,dev,pro</code>（虚拟机参数配置,可以配置多个）</p>
</li>
<li>
<p>代码实现：注意此时舍弃原来的有参构造创建容器的方法</p>
<pre><code class="hljs java">AnnotationConfigApplicationContext acac=<span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();
acac.getEnvironment().setActiveProfiles(<span class="hljs-string">"test"</span>,<span class="hljs-string">"dev"</span>);
acac.register(ApplicationContext.class);
acac.refresh();</code></pre>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-meta">@Profile("test")</span>
<span class="hljs-meta">@Configuration</span><span class="hljs-comment">//只有指定环境激活时，整个配置类才能生效</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">SqlConfig</span><span class="hljs-params">()</span></span>{
   
    <span class="hljs-meta">@Profile("test")</span>
    <span class="hljs-meta">@Bean("testDataSource")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">XXXtest</span><span class="hljs-params">()</span></span>{
        ........
        <span class="hljs-keyword">return</span> dataSource;
    }

    <span class="hljs-meta">@Profile("dev")</span>
    <span class="hljs-meta">@Bean("developDataSource")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">XXXdevelop</span><span class="hljs-params">()</span></span>{
        ........
        <span class="hljs-keyword">return</span> dataSource;
    }

    <span class="hljs-meta">@Profile("pro")</span>
    <span class="hljs-meta">@Bean("productDataSource")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">XXXproduct</span><span class="hljs-params">()</span></span>{
        ........
        <span class="hljs-keyword">return</span> dataSource;
    }
}</code></pre>
<h3 id="2-6-使用注解给容器中注册组件的几种方法：">2.6 使用注解给容器中注册组件的几种方法：</h3>
<ol>
<li>
<p>包扫描+组件注解（<code>@Controller/@Service/@Respority/@Component</code>）</p>
</li>
<li>
<p>@Bean 导入第三方包里面的组件</p>
</li>
<li>
<p>@Import 快速给容器中导入组件：</p>
<ol>
<li>@Import（要导入的组件.class）: id 默认是全类名</li>
<li>importSelector：导入需要的组件的全类名</li>
<li>ImportBeanDefinitionRegistrar：手动注册组件</li>
</ol>
</li>
<li>
<p>使用 FactoryBean 对象：</p>
</li>
<li>
<pre><code class="language-java">@Bean
    public PersonFactoryBean personFactoryBean(){
        return new PersonFactoryBean();
    }
<pre><code class="hljs java">
```java
<span class="hljs-keyword">package</span> config;

<span class="hljs-keyword">import</span> domain.Person;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.FactoryBean;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Person</span>&gt; </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回的对象是容器中注册的组件</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();
    }

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回组件的类型</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Class&lt;Person&gt; <span class="hljs-title">getObjectType</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Person.class;
    }

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否为单例</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}
</code></pre>

<pre><code class="hljs java">        Object bean1=ac2.getBean(<span class="hljs-string">"personFactoryBean"</span>);
        Object bean2=ac2.getBean(<span class="hljs-string">"&amp;personFactoryBean"</span>);
        System.out.println(bean1);
        System.out.println(bean2);
<span class="hljs-comment">//获取的时候直接用 id 是获取到组件对象</span>
<span class="hljs-comment">// 用 &amp;+id 是获取到工厂对象</span></code></pre>


</code></pre>
</li>
</ol>
<p>获取容器时需要使用 <code>AnnotationApplicationContext</code>(有@Configuration 注解的类.class)</p>
<pre><code class="hljs java">ApplicationContext ac =<span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration.class);</code></pre>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>{
       String[] names=ac.getBeanDefinitionNames();
       <span class="hljs-keyword">for</span>(String name:names){
           System.out.println(name);
       }
   }</code></pre>
<p>测试结果</p>
<pre><code class="hljs java"><span class="hljs-comment">//使用注解后容器中自动就有的对象</span>
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalRequiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
    
<span class="hljs-comment">//配置对象</span>
springConfig

<span class="hljs-comment">//自己注入的对象    </span>
accountDaoImpl 
accountServiceImpl
now</code></pre>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot02原理分析和文件配置</title>
    <url>/2020/04/02/springboot/SpringBoot02%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%92%8C%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2015/07/13/14/40/paris-843229_1280.jpg" alt=""></p>
<hr>
<h1>SpringBoot02原理分析和文件配置</h1>
<h2 id="1-起步依赖原理分析">1 起步依赖原理分析</h2>
<h3 id="1-1-分析spring-boot-starter-parent">1.1 分析spring-boot-starter-parent</h3>
<p>按住Ctrl点击pom.xml中的<code>spring-boot-starter-parent</code>，跳转到了<code>spring-boot-starter-parent</code>的<code>pom.xml</code>，xml配置如下（只摘抄了部分重点配置）：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre>
<p>按住Ctrl点击<code>pom.xml</code>中的<code>spring-boot-starter-dependencies</code>，跳转到了<code>spring-boot-starter-dependencies</code>的<code>pom.xml</code>，xml配置如下（只摘抄了部分重点配置）：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">activemq.version</span>&gt;</span>5.15.3<span class="hljs-tag">&lt;/<span class="hljs-name">activemq.version</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">antlr2.version</span>&gt;</span>2.7.7<span class="hljs-tag">&lt;/<span class="hljs-name">antlr2.version</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">appengine-sdk.version</span>&gt;</span>1.9.63<span class="hljs-tag">&lt;/<span class="hljs-name">appengine-sdk.version</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">artemis.version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">artemis.version</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">aspectj.version</span>&gt;</span>1.8.13<span class="hljs-tag">&lt;/<span class="hljs-name">aspectj.version</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">assertj.version</span>&gt;</span>3.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">assertj.version</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">atomikos.version</span>&gt;</span>4.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">atomikos.version</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">bitronix.version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">bitronix.version</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">build-helper-maven-plugin.version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">build-helper-maven-plugin.version</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">byte-buddy.version</span>&gt;</span>1.7.11<span class="hljs-tag">&lt;/<span class="hljs-name">byte-buddy.version</span>&gt;</span>
  	... ... ...
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
      	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
      	... ... ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jetbrains.kotlin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kotlin-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${kotlin.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      		<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jooq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jooq-codegen-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>${jooq.version}<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      		<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
        		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      		<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
          	... ... ...
    	<span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
  	<span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre>
<p>从上面的<code>spring-boot-starter-dependencies</code>的<code>pom.xml</code>中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以我们的SpringBoot工程继承<code>spring-boot-starter-parent</code>后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。</p>
<h3 id="1-2-分析spring-boot-starter-web">1.2 分析spring-boot-starter-web</h3>
<p>按住Ctrl点击<code>pom.xml</code>中的<code>spring-boot-starter-web</code>，跳转到了<code>spring-boot-starter-web</code>的<code>pom.xml</code>，xml配置如下（只摘抄了部分重点配置）：</p>
<pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span>
<span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starters<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
  	<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
  	<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Boot Web Starter<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
  
  	<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.9.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
      		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>
    	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
  	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre>
<p>从上面的spring-boot-starter-web的pom.xml中我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。</p>
<h2 id="2-自动配置原理解析">2 自动配置原理解析</h2>
<p>按住Ctrl点击查看启动类<code>MySpringBootApplication</code>上的注解<code>@SpringBootApplication</code></p>
<pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpringBootApplication</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        SpringApplication.run(MySpringBootApplication.class);
    }
}</code></pre>
<p>注解<code>@SpringBootApplication</code>的源码</p>
<pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Inherited</span>
<span class="hljs-meta">@SpringBootConfiguration</span>
<span class="hljs-meta">@EnableAutoConfiguration</span>
<span class="hljs-meta">@ComponentScan(excludeFilters = {</span>
<span class="hljs-meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span>
<span class="hljs-meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication {

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">	 * Exclude specific auto-configuration classes such that they will never be applied.</span>
<span class="hljs-comment">	 * <span class="hljs-doctag">@return</span> the classes to exclude</span>
<span class="hljs-comment">	 */</span>
    <span class="hljs-meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span>
    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> {};

    ... ... ...

}</code></pre>
<p>其中，</p>
<p><code>@SpringBootConfiguration</code>：等同与<code>@Configuration</code>，既标注该类是Spring的一个配置类</p>
<p><code>@EnableAutoConfiguration</code>：SpringBoot自动配置功能开启</p>
<p>按住Ctrl点击查看注解<code>@EnableAutoConfiguration</code></p>
<pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Documented</span>
<span class="hljs-meta">@Inherited</span>
<span class="hljs-meta">@AutoConfigurationPackage</span>
<span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration {
    ... ... ...
}</code></pre>
<p>其中，<code>@Import(AutoConfigurationImportSelector.class)</code> 导入了<code>AutoConfigurationImportSelector</code>类</p>
<p>按住Ctrl点击查看<code>AutoConfigurationImportSelector</code>源码</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) {
        ... ... ...
        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,
                                                                   attributes);
        configurations = removeDuplicates(configurations);
        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);
        checkExcludedClasses(configurations, exclusions);
        configurations.removeAll(exclusions);
        configurations = filter(configurations, autoConfigurationMetadata);
        fireAutoConfigurationImportEvents(configurations, exclusions);
        <span class="hljs-keyword">return</span> StringUtils.toStringArray(configurations);
}


<span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata,</span></span>
<span class="hljs-function"><span class="hljs-params">			AnnotationAttributes attributes)</span> </span>{
        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(
                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
        
        <span class="hljs-keyword">return</span> configurations;
}
</code></pre>
<p>其中，<code>SpringFactoriesLoader.loadFactoryNames</code> 方法的作用就是从<code>META-INF/spring.factories</code>文件中读取指定类对应的类名称列表</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/11.png" alt=""></p>
<p>spring.factories 文件中有关自动配置的配置信息如下：</p>
<pre><code class="hljs stylus">... ... ...

org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.reactive</span><span class="hljs-selector-class">.function</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.WebClientAutoConfiguration</span>,\
org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.DispatcherServletAutoConfiguration</span>,\
org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.ServletWebServerFactoryAutoConfiguration</span>,\
org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.error</span><span class="hljs-selector-class">.ErrorMvcAutoConfiguration</span>,\
org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.HttpEncodingAutoConfiguration</span>,\
org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.MultipartAutoConfiguration</span>,\

... ... ...</code></pre>
<p>上面配置文件存在大量的以<code>Configuration</code>为结尾的类名称，这些类就是存有自动配置信息的类，而<code>SpringApplication</code>在获取这些类名后再加载</p>
<p>我们以<code>ServletWebServerFactoryAutoConfiguration</code>为例来分析源码：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span>
<span class="hljs-meta">@ConditionalOnClass(ServletRequest.class)</span>
<span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span>
<span class="hljs-meta">@EnableConfigurationProperties(ServerProperties.class)</span>
<span class="hljs-meta">@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span>
<span class="hljs-meta">		ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span>
<span class="hljs-meta">		ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span>
<span class="hljs-meta">		ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletWebServerFactoryAutoConfiguration</span> </span>{
    ... ... ...
}
</code></pre>
<p>其中，</p>
<p><code>@EnableConfigurationProperties(ServerProperties.class)</code> 代表加载<code>ServerProperties</code>服务器配置属性类</p>
<p>进入ServerProperties.class源码如下：</p>
<pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = "server", ignoreUnknownFields = true)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerProperties</span> </span>{

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">	 * Server HTTP port.</span>
<span class="hljs-comment">	 */</span>
    <span class="hljs-keyword">private</span> Integer port;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">	 * Network address to which the server should bind.</span>
<span class="hljs-comment">	 */</span>
    <span class="hljs-keyword">private</span> InetAddress address;
  
  	... ... ...
  
}</code></pre>
<p>其中，</p>
<p><code>prefix = "server" </code>表示SpringBoot配置文件中的前缀，SpringBoot会将配置文件中以server开始的属性映射到该类的字段中。映射关系如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="http://img.sky123.top/springboot/12.png" alt=""></p>
<h2 id="3-SpringBoot配置文件类型">3 SpringBoot配置文件类型</h2>
<h3 id="3-1-SpringBoot配置文件类型和作用">3.1 SpringBoot配置文件类型和作用</h3>
<p>SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用<code>application.properties</code>或者<code>application.yml（application.yaml）</code>进行配置。</p>
<p>SpringBoot默认会从Resources目录下加载<code>application.properties</code>或<code>application.yml（application.yaml）</code>文件</p>
<p>其中，<code>application.properties</code>文件是键值对类型的文件，之前一直在使用，所以此处不在对properties文件的格式进行阐述。除了properties文件外，SpringBoot还可以使用yml文件进行配置，下面对yml文件进行讲解。</p>
<h3 id="3-2-application-yml配置文件">3.2 application.yml配置文件</h3>
<h4 id="yml配置文件简介">yml配置文件简介</h4>
<blockquote>
<p>YML文件格式是YAML (YAML Aint Markup Language)编写的文件格式，YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。</p>
</blockquote>
<p>YML文件的扩展名可以使用.yml或者.yaml。</p>
<h4 id="yml配置文件的语法">yml配置文件的语法</h4>
<h5 id="配置普通数据">配置普通数据</h5>
<ul>
<li>
<p>语法： key: value</p>
</li>
<li>
<p>示例代码：</p>
</li>
</ul>
<pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">haohao</span></code></pre>
<ul>
<li>注意：value之前有一个空格</li>
</ul>
<h5 id="配置对象数据">配置对象数据</h5>
<ul>
<li>
<p>语法：</p>
<p>​	key:</p>
<p>​		key1: value1</p>
<p>​		key2: value2</p>
<p>​	或者：</p>
<p>​	key: {key1: value1,key2: value2}</p>
</li>
<li>
<p>示例代码：</p>
</li>
</ul>
<pre><code class="hljs yaml"><span class="hljs-attr">person:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">haohao</span>
  <span class="hljs-attr">age:</span> <span class="hljs-number">31</span>
  <span class="hljs-attr">addr:</span> <span class="hljs-string">beijing</span>

<span class="hljs-comment">#或者</span>

<span class="hljs-attr">person:</span> {<span class="hljs-attr">name:</span> <span class="hljs-string">haohao</span>,<span class="hljs-attr">age:</span> <span class="hljs-number">31</span>,<span class="hljs-attr">addr:</span> <span class="hljs-string">beijing</span>}</code></pre>
<ul>
<li>注意：key1前面的空格个数不限定，在yml语法中，相同缩进代表同一个级别</li>
</ul>
<h5 id="配置Map数据">配置Map数据</h5>
<p>同上面的对象写法</p>
<h5 id="配置数组（List、Set）数据">配置数组（List、Set）数据</h5>
<ul>
<li>
<p>语法：</p>
<p>​	key:</p>
<p>​		- value1</p>
<p>​		- value2</p>
<p>或者：</p>
<p>​	key: [value1,value2]</p>
</li>
<li>
<p>示例代码：</p>
</li>
</ul>
<pre><code class="hljs yaml"><span class="hljs-attr">city:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">beijing</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">tianjin</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">shanghai</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">chongqing</span>
  
<span class="hljs-comment">#或者</span>

<span class="hljs-attr">city:</span> [<span class="hljs-string">beijing</span>,<span class="hljs-string">tianjin</span>,<span class="hljs-string">shanghai</span>,<span class="hljs-string">chongqing</span>]

<span class="hljs-comment">#集合中的元素是对象形式</span>
<span class="hljs-attr">student:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span>
    <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>
    <span class="hljs-attr">score:</span> <span class="hljs-number">100</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">lisi</span>
    <span class="hljs-attr">age:</span> <span class="hljs-number">28</span>
    <span class="hljs-attr">score:</span> <span class="hljs-number">88</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wangwu</span>
    <span class="hljs-attr">age:</span> <span class="hljs-number">38</span>
    <span class="hljs-attr">score:</span> <span class="hljs-number">90</span></code></pre>
<ul>
<li>注意：value1与之间的 - 之间存在一个空格</li>
</ul>
<h3 id="3-3-SpringBoot配置信息的查询">3.3 SpringBoot配置信息的查询</h3>
<p>上面提及过，SpringBoot的配置文件，主要的目的就是对配置信息进行修改的，但在配置时的key从哪里去查询呢？我们可以查阅SpringBoot的官方文档</p>
<p>文档URL：<a class="link" href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties">https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties<i class="fas fa-external-link-alt"></i></a></p>
<p>常用的配置摘抄如下：</p>
<pre><code class="hljs properties"><span class="hljs-comment"># QUARTZ SCHEDULER (QuartzProperties)</span>
<span class="hljs-meta">spring.quartz.jdbc.initialize-schema</span>=<span class="hljs-string">embedded # Database schema initialization mode.</span>
<span class="hljs-meta">spring.quartz.jdbc.schema</span>=<span class="hljs-string">classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span>
<span class="hljs-meta">spring.quartz.job-store-type</span>=<span class="hljs-string">memory # Quartz job store type.</span>
<span class="hljs-meta">spring.quartz.properties.*</span>= <span class="hljs-string"># Additional Quartz Scheduler properties.</span>

<span class="hljs-comment"># ----------------------------------------</span>
<span class="hljs-comment"># WEB PROPERTIES</span>
<span class="hljs-comment"># ----------------------------------------</span>

<span class="hljs-comment"># EMBEDDED SERVER CONFIGURATION (ServerProperties)</span>
<span class="hljs-meta">server.port</span>=<span class="hljs-string">8080 # Server HTTP port.</span>
<span class="hljs-meta">server.servlet.context-path</span>= <span class="hljs-string"># Context path of the application.</span>
<span class="hljs-meta">server.servlet.path</span>=<span class="hljs-string">/ # Path of the main dispatcher servlet.</span>

<span class="hljs-comment"># HTTP encoding (HttpEncodingProperties)</span>
<span class="hljs-meta">spring.http.encoding.charset</span>=<span class="hljs-string">UTF-8 # Charset of HTTP requests and responses. Added to the "Content-Type" header if not set explicitly.</span>

<span class="hljs-comment"># JACKSON (JacksonProperties)</span>
<span class="hljs-meta">spring.jackson.date-format</span>= <span class="hljs-string"># Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.</span>

<span class="hljs-comment"># SPRING MVC (WebMvcProperties)</span>
<span class="hljs-meta">spring.mvc.servlet.load-on-startup</span>=<span class="hljs-string">-1 # Load on startup priority of the dispatcher servlet.</span>
<span class="hljs-meta">spring.mvc.static-path-pattern</span>=<span class="hljs-string">/** # Path pattern used for static resources.</span>
<span class="hljs-meta">spring.mvc.view.prefix</span>= <span class="hljs-string"># Spring MVC view prefix.</span>
<span class="hljs-meta">spring.mvc.view.suffix</span>= <span class="hljs-string"># Spring MVC view suffix.</span>

<span class="hljs-comment"># DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)</span>
<span class="hljs-meta">spring.datasource.driver-class-name</span>= <span class="hljs-string"># Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span>
<span class="hljs-meta">spring.datasource.password</span>= <span class="hljs-string"># Login password of the database.</span>
<span class="hljs-meta">spring.datasource.url</span>= <span class="hljs-string"># JDBC URL of the database.</span>
<span class="hljs-meta">spring.datasource.username</span>= <span class="hljs-string"># Login username of the database.</span>

<span class="hljs-comment"># JEST (Elasticsearch HTTP client) (JestProperties)</span>
<span class="hljs-meta">spring.elasticsearch.jest.password</span>= <span class="hljs-string"># Login password.</span>
<span class="hljs-meta">spring.elasticsearch.jest.proxy.host</span>= <span class="hljs-string"># Proxy host the HTTP client should use.</span>
<span class="hljs-meta">spring.elasticsearch.jest.proxy.port</span>= <span class="hljs-string"># Proxy port the HTTP client should use.</span>
<span class="hljs-meta">spring.elasticsearch.jest.read-timeout</span>=<span class="hljs-string">3s # Read timeout.</span>
<span class="hljs-meta">spring.elasticsearch.jest.username</span>= <span class="hljs-string"># Login username.</span>
</code></pre>
<p>我们可以通过配置<code>application.poperties</code> 或者 <code>application.yml </code>来修改SpringBoot的默认配置</p>
<p>例如：</p>
<p>application.properties文件</p>
<pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8888</span>
<span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">demo</span></code></pre>
<p>application.yml文件</p>
<pre><code class="hljs yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8888</span>
  <span class="hljs-attr">servlet:</span>
    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/demo</span></code></pre>
<h2 id="4-配置文件与配置类的属性映射方式">4 配置文件与配置类的属性映射方式</h2>
<h3 id="4-1-使用注解-Value映射">4.1 使用注解@Value映射</h3>
<p>我们可以通过@Value注解将配置文件中的值映射到一个Spring管理的Bean的字段上</p>
<p>例如：</p>
<p><code>application.properties</code>配置如下：</p>
<pre><code class="hljs properties"><span class="hljs-attr">person</span>:<span class="hljs-string"></span>
  <span class="hljs-attr">name</span>: <span class="hljs-string">zhangsan</span>
  <span class="hljs-attr">age</span>: <span class="hljs-string">18</span></code></pre>
<p>或者，<code>application.yml</code>配置如下：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">person:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span>
  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span></code></pre>
<p>实体Bean代码如下：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickStartController</span> </span>{

    <span class="hljs-meta">@Value("${person.name}")</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@Value("${person.age}")</span>
    <span class="hljs-keyword">private</span> Integer age;


    <span class="hljs-meta">@RequestMapping("/quick")</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">quick</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"springboot 访问成功! name="</span>+name+<span class="hljs-string">",age="</span>+age;
    }

}</code></pre>
<p>浏览器访问地址：<a class="link" href="http://localhost:8080/quick">http://localhost:8080/quick<i class="fas fa-external-link-alt"></i></a> 结果如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="img%5C13.png" alt=""></p>
<h3 id="4-2-使用注解-ConfigurationProperties映射">4.2 使用注解@ConfigurationProperties映射</h3>
<p>通过注解<code>@ConfigurationProperties(prefix="配置文件中的key的前缀")</code>可以将配置文件中的配置自动与实体进行映射</p>
<p><code>application.properties</code>配置如下：</p>
<pre><code class="hljs properties"><span class="hljs-attr">person</span>:<span class="hljs-string"></span>
  <span class="hljs-attr">name</span>: <span class="hljs-string">zhangsan</span>
  <span class="hljs-attr">age</span>: <span class="hljs-string">18</span></code></pre>
<p>或者，<code>application.yml</code>配置如下：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">person:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span>
  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span></code></pre>
<p>实体Bean代码如下：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Controller</span>
<span class="hljs-meta">@ConfigurationProperties(prefix = "person")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickStartController</span> </span>{

    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;

    <span class="hljs-meta">@RequestMapping("/quick")</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">quick</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"springboot 访问成功! name="</span>+name+<span class="hljs-string">",age="</span>+age;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>{
        <span class="hljs-keyword">this</span>.age = age;
    }
}</code></pre>
<p>浏览器访问地址：<a class="link" href="http://localhost:8080/quick">http://localhost:8080/quick<i class="fas fa-external-link-alt"></i></a> 结果如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springboot/13.png" alt=""></p>
<p>注意：使用<code>@ConfigurationProperties</code>方式可以进行配置文件与实体字段的自动映射，但需要字段必须提供set方法才可以，而使用@Value注解修饰的字段不需要提供set方法</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC入门02常用注解和Restful和响应结果</title>
    <url>/2020/02/02/springmvc/SpringMVC%E5%85%A5%E9%97%A802%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%92%8CRestful%E5%92%8C%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.pixabay.com/photo/2020/10/20/08/49/sunrise-5669884_1280.jpg" alt=""></p>
<hr>
<h1>SpringMVC入门02常用注解和Restful和响应结果</h1>
<h2 id="1-常用注解">1. 常用注解</h2>
<h3 id="RequestParam">@RequestParam</h3>
<p>作用：把请求中指定名称的参数给控制器中的形参赋值。<br>
属性：<br>
value： 请求参数中的名称。<br>
required：请求参数中是否必须提供此参数。 默认值： true。表示必须提供，如果不提供将报错。</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/useRequestParam")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">useRequestParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam("name")</span>String username,</span></span>
<span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@RequestParam(value="age",required=false)</span>Integer age)</span></span>{
System.out.println(username+<span class="hljs-string">","</span>+age);
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}</code></pre>
<h3 id="RequestBody">@RequestBody</h3>
<p>作用：用于获取请求体内容。 直接使用得到是 key=value&amp;key=value…结构的数据。get 请求方式不适用。<br>
属性：<br>
required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false， get 请求得到是 null。</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/useRequestBody")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">useRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody(required=false)</span> String body)</span></span>{
System.out.println(body);
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}</code></pre>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springmvc01/image-20200601200649922.png" alt="image-20200601200649922" style="zoom:50%;">
<hr>
<h3 id="ResponseBody">@ResponseBody</h3>
<p>作用：该注解用于将 Controller 的方法返回的对象，通过 <code>HttpMessageConverter</code> 接口转换为指定格式的数据如： json,xml 等，通过 Response 响应给客户端  。</p>
<p>需求：使用<code>@ResponseBody</code> 注解实现将 controller 方法返回对象转换为 json 响应给客户端。<br>
前置知识点：Springmvc 默认用 <code>MappingJacksonHttpMessageConverter</code> 对 json 数据进行转换，需要加入jackson 的包。</p>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springmvc01/image-20200601211858975.png" alt="image-20200601211858975" style="zoom: 67%;">
<hr>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    javaBean对象和json字符串的转化依赖 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span></span>
<span class="hljs-tag"><span class="hljs-attr">src</span>=<span class="hljs-string">"${pageContext.request.contextPath}/js/jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span>
<span class="javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">$(<span class="hljs-string">"#testJson"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">$.ajax({</span>
<span class="javascript">type:<span class="hljs-string">"post"</span>,</span>
<span class="javascript">url:<span class="hljs-string">"${pageContext.request.contextPath}/testResponseJson"</span>,</span>
<span class="javascript">contentType:<span class="hljs-string">"application/json;charset=utf-8"</span>,</span>
<span class="javascript">data:<span class="hljs-string">'{"id":1,"name":"test","money":999.0}'</span>,</span>
<span class="javascript">dataType:<span class="hljs-string">"json"</span>,</span>
<span class="javascript">success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{</span>
alert(data);
}
});
});
})
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 测试异步请求 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"测试 ajax 请求 json 和响应 json"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"testJson"</span>/&gt;</span>
</code></pre>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 响应 json 数据的控制器</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Controller("jsonController")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonController</span> </span>{
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 测试响应 json 数据</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@RequestMapping("/testResponseJson")</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> <span class="hljs-function">Account <span class="hljs-title">testResponseJson</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Account account)</span> </span>{
System.out.println(<span class="hljs-string">"异步请求： "</span>+account);
<span class="hljs-keyword">return</span> account;
}
}</code></pre>
<h3 id="PathVaribale">@PathVaribale</h3>
<p>作用：用于绑定 url 中的占位符。 例如：请求 url 中 <code>/delete/{id}</code>， 这个{id}就是 url 占位符。url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。<br>
属性：<br>
value： 用于指定 url 中占位符名称。<br>
required：是否必须提供占位符。</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/usePathVariable/{id}")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">usePathVariable</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable("id")</span> Integer id)</span></span>{
System.out.println(id);
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}</code></pre>
<h3 id="RequestHeader">@RequestHeader</h3>
<p>作用：用于获取请求消息头。<br>
属性：<br>
value：提供消息头名称<br>
required：是否必须有此消息头<br>
注：在实际开发中一般不怎么用</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/useRequestHeader")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">useRequestHeader</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(value="Accept-Language",</span></span></span>
<span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">required=false)</span>String requestHeader)</span></span>{
System.out.println(requestHeader);
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}</code></pre>
<h3 id="CookieValue">@CookieValue</h3>
<p>作用：用于把指定 cookie 名称的值传入控制器方法参数。<br>
属性：<br>
value：指定 cookie 的名称。<br>
required：是否必须有此 cookie。</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/useCookieValue")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">useCookieValue</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(value="JSESSIONID",required=false)</span></span></span>
<span class="hljs-function"><span class="hljs-params">String cookieValue)</span></span>{
System.out.println(cookieValue);
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}</code></pre>
<h3 id="ModelAttribute">@ModelAttribute</h3>
<p>作用：该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。</p>
<ol>
<li>出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可<br>
以修饰有具体返回值的方法。</li>
<li>出现在参数上，获取指定的数据给参数赋值。</li>
</ol>
<p>属性：</p>
<p>value：用于获取数据的 key。 key 可以是 POJO 的属性名称，也可以是 map 结构的 key。</p>
<blockquote>
<p>应用场景：<br>
当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。</p>
</blockquote>
<p>例如：<br>
我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。</p>
<p>基于 Map 的应用场景示例 1： ModelAttribute 修饰方法带返回值</p>
<pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">showModel</span><span class="hljs-params">(String username)</span> </span>{
<span class="hljs-comment">//模拟去数据库查询</span>
User abc = findUserByName(username);
System.out.println(<span class="hljs-string">"执行了 showModel 方法"</span>+abc);
<span class="hljs-keyword">return</span> abc;
}
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 模拟修改用户方法</span>
<span class="hljs-comment">* <span class="hljs-doctag">@param</span> user</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@RequestMapping("/updateUser")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testModelAttribute</span><span class="hljs-params">(User user)</span> </span>{
System.out.println(<span class="hljs-string">"控制器中处理请求的方法：修改用户： "</span>+user);
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 模拟去数据库查询</span>
<span class="hljs-comment">* <span class="hljs-doctag">@param</span> username</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">findUserByName</span><span class="hljs-params">(String username)</span> </span>{
User user = <span class="hljs-keyword">new</span> User();
user.setUsername(username);
user.setAge(<span class="hljs-number">19</span>);
user.setPassword(<span class="hljs-string">"123456"</span>);
<span class="hljs-keyword">return</span> user;
}</code></pre>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springmvc01/image-20200601201956582.png" alt="image-20200601201956582"></p>
<hr>
<p>基于 Map 的应用场景示例 1： ModelAttribute 修饰方法不带返回值</p>
<pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showModel</span><span class="hljs-params">(String username,Map&lt;String,User&gt; map)</span> </span>{
<span class="hljs-comment">//模拟去数据库查询</span>
User user = findUserByName(username);
System.out.println(<span class="hljs-string">"执行了 showModel 方法"</span>+user);
map.put(<span class="hljs-string">"abc"</span>,user);
}
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 模拟修改用户方法</span>
<span class="hljs-comment">* <span class="hljs-doctag">@param</span> user</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@RequestMapping("/updateUser")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testModelAttribute</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute("abc")</span>User user)</span> </span>{
System.out.println(<span class="hljs-string">"控制器中处理请求的方法：修改用户： "</span>+user);
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 模拟去数据库查询</span>
<span class="hljs-comment">* <span class="hljs-doctag">@param</span> username</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> User <span class="hljs-title">findUserByName</span><span class="hljs-params">(String username)</span> </span>{
User user = <span class="hljs-keyword">new</span> User();
user.setUsername(username);传智播客——专注于 Java、 .Net 和 Php、网页平面设计工程师的培训
北京市昌平区建材城西路金燕龙办公楼一层 电话： <span class="hljs-number">400</span>-<span class="hljs-number">618</span>-<span class="hljs-number">9090</span>
user.setAge(<span class="hljs-number">19</span>);
user.setPassword(<span class="hljs-string">"123456"</span>);
<span class="hljs-keyword">return</span> user;
}</code></pre>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springmvc01/image-20200601202224983.png" alt="image-20200601202224983"></p>
<hr>
<h3 id="SessionAttribute">@SessionAttribute</h3>
<p>作用：用于多次执行控制器方法间的参数共享。<br>
属性：<br>
value：用于指定存入的属性名称<br>
type：用于指定存入的数据类型。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Controller("sessionAttributeController")</span>
<span class="hljs-meta">@RequestMapping("/springmvc")</span>
<span class="hljs-meta">@SessionAttributes(value ={"username","password"},types={Integer.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionAttributeController</span> </span>{
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 把数据存入 SessionAttribute</span>
<span class="hljs-comment">* <span class="hljs-doctag">@param</span> model</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">* Model 是 spring 提供的一个接口，该接口有一个实现类 ExtendedModelMap</span>
<span class="hljs-comment">* 该类继承了 ModelMap，而 ModelMap 就是 LinkedHashMap 子类</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@RequestMapping("/testPut")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testPut</span><span class="hljs-params">(Model model)</span></span>{
model.addAttribute(<span class="hljs-string">"username"</span>, <span class="hljs-string">"泰斯特"</span>);
model.addAttribute(<span class="hljs-string">"password"</span>,<span class="hljs-string">"123456"</span>);
model.addAttribute(<span class="hljs-string">"age"</span>, <span class="hljs-number">31</span>);
<span class="hljs-comment">//跳转之前将数据保存到 username、 password 和 age 中，因为注解@SessionAttribute 中有这几个参数</span>
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}
<span class="hljs-meta">@RequestMapping("/testGet")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testGet</span><span class="hljs-params">(ModelMap model)</span></span>{
System.out.println(model.get(<span class="hljs-string">"username"</span>)+<span class="hljs-string">";"</span>+model.get(<span class="hljs-string">"password"</span>)+<span class="hljs-string">";"</span>+model.get(<span class="hljs-string">"a</span>
<span class="hljs-string">ge"</span>));
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}
<span class="hljs-meta">@RequestMapping("/testClean")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">complete</span><span class="hljs-params">(SessionStatus sessionStatus)</span></span>{
sessionStatus.setComplete();
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}
}</code></pre>
<h2 id="2-REST-风格-URL">2. REST 风格 URL</h2>
<h3 id="2-1-什么是-rest：">2.1 什么是 rest：</h3>
<blockquote>
<p>REST（英文： Representational State Transfer，简称 REST）描述了一个架构样式的网络系统，<br>
比如 web 应用程序。它首次出现在 2000 年 Roy Fielding 的博士论文中，他是 HTTP 规范的主要编写者之<br>
一。在目前主流的三种 Web 服务交互方案中， REST 相比于 SOAP（Simple Object Access protocol，简单<br>
对象访问协议）以及 XML-RPC 更加简单明了，无论是对 URL 的处理还是对 Payload 的编码， REST 都倾向于用更<br>
加简单轻量的方法设计和实现。值得注意的是 REST 并没有一个明确的标准，而更像是一种设计的风格。<br>
它本身并没有什么实用性，其核心价值在于如何设计出符合 REST 风格的网络接口。</p>
</blockquote>
<h3 id="2-2-restful-的特性：">2.2 restful 的特性：</h3>
<p>资源（<code>Resources</code>） ： 网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。</p>
<p>表现层（<code>Representation</code>） ： 把资源具体呈现出来的形式，叫做它的表现层 （Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、 XML 格式、 JSON 格式表现，甚至可以采用二进制格式。</p>
<p>状态转化（<code>State Transfer</code>） ： 每 发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP 协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，<br>
必须通过某种手段， 让服务器端发生“ 状态转化” （State Transfer）。而这种转化是建立在表现层之上的，所以就是 “ 表现层状态转化” 。</p>
<p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词： GET 、 POST 、 PUT、DELETE。它们分别对应四种基本操作： GET 用来获取资源， POST 用来新建资源， PUT 用来更新资源， DELETE 用来删除资源。<br>
restful 的示例：</p>
<table>
<thead>
<tr>
<th>/account/1</th>
<th>HTTP GET ：</th>
<th>得到 id = 1 的 account</th>
</tr>
</thead>
<tbody>
<tr>
<td>/account/1</td>
<td>HTTP DELETE： 删除 id = 1 的 account</td>
<td></td>
</tr>
<tr>
<td>/account/1</td>
<td>HTTP PUT：</td>
<td>更新 id = 1 的 account</td>
</tr>
<tr>
<td>/account</td>
<td>HTTP POST：</td>
<td>新增 account</td>
</tr>
</tbody>
</table>
<h3 id="2-3-基于-HiddentHttpMethodFilter-的示例">2.3 基于 <code>HiddentHttpMethodFilter</code> 的示例</h3>
<p>作用：<br>
由于浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、 PUT 等 method 并不支持， Spring3.0 添加了一个过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、 POST、 PUT与 DELETE 请求。<br>
使用方法：<br>
第一步：在 web.xml 中配置该过滤器。<code>HiddentHttpMethodFilter</code><br>
第二步：请求方式必须使用 post 请求。<br>
第三步：按照要求提供_method 请求参数，该参数的取值就是我们需要的请求方式。</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"springmvc/testRestPOST"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>
用户名称： <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
<span class="hljs-comment">&lt;!-- &lt;input type="hidden" name="_method" value="POST"&gt; --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"保存"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value="/testRestPOST",method=RequestMethod.POST)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRestfulURLPOST</span><span class="hljs-params">(User user)</span></span>{
System.out.println(<span class="hljs-string">"rest post"</span>+user);
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}</code></pre>
<h2 id="3-响应数据和结果视图">3. 响应数据和结果视图</h2>
<h3 id="3-1-返回值分类">3.1 返回值分类</h3>
<h4 id="3-1-1-字符串">3.1.1 字符串</h4>
<p>controller 方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。</p>
<pre><code class="hljs java"><span class="hljs-comment">//指定逻辑视图名，经过视图解析器解析为 jsp 物理路径： /WEB-INF/pages/success.jsp</span>
<span class="hljs-meta">@RequestMapping("/testReturnString")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testReturnString</span><span class="hljs-params">()</span> </span>{
System.out.println(<span class="hljs-string">"AccountController 的 testReturnString 方法执行了。。。。 "</span>);
<span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;
}</code></pre>
<h4 id="3-1-2-void">3.1.2 void</h4>
<p>我们知道 Servlet 原始 API 可以作为控制器中方法的参数：</p>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testReturnVoid")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testReturnVoid</span><span class="hljs-params">(HttpServletRequest request,HttpServletResponse response)</span></span>
<span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>{
}</code></pre>
<p>在controller 方法形参上可以定义 request 和 response，使用 request 或 response 指定响应结果：</p>
<p>1、使用 request 转向页面，如下</p>
<pre><code class="hljs java">request.getRequestDispatcher(<span class="hljs-string">"/WEB-INF/pages/success.jsp"</span>).forward(request,response);</code></pre>
<p>2、也可以通过 response 页面重定向：</p>
<pre><code class="hljs java">response.sendRedirect(<span class="hljs-string">"testRetrunString"</span>);</code></pre>
<p>3、也可以通过 response 指定响应结果， 例如响应 json 数据：</p>
<pre><code class="hljs java">response.setCharacterEncoding(<span class="hljs-string">"utf-8"</span>);
response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);
response.getWriter().write(<span class="hljs-string">"json 串"</span>);</code></pre>
<h4 id="3-1-3-ModelAndView">3.1.3 ModelAndView</h4>
<p><code>ModelAndView</code> 是 SpringMVC 为我们提供的一个对象，该对象也可以用作控制器方法的返回值。<br>
该对象中有两个方法：</p>
<hr>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/springmvc01/image-20200601203858011.png" alt="image-20200601203858011" style="zoom: 67%;">
<hr>
<pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testReturnModelAndView")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">testReturnModelAndView</span><span class="hljs-params">()</span> </span>{
ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView();
mv.addObject(<span class="hljs-string">"username"</span>, <span class="hljs-string">"张三"</span>);
mv.setViewName(<span class="hljs-string">"success"</span>);
    <span class="hljs-keyword">return</span> mv;
}</code></pre>
<pre><code class="hljs jsp">&lt;%@ page language=<span class="hljs-string">"java"</span> contentType=<span class="hljs-string">"text/html; charset=UTF-8"</span>
pageEncoding=<span class="hljs-string">"UTF-8"</span>%&gt;
&lt;!DOCTYPE html PUBLIC <span class="hljs-string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>
<span class="hljs-string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=<span class="hljs-string">"Content-Type"</span> content=<span class="hljs-string">"text/html; charset=UTF-8"</span>&gt;
&lt;title&gt;执行成功&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
执行成功！
${requestScope.username}
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h3 id="3-2-转发和重定向">3.2 转发和重定向</h3>
<h4 id="3-2-1-forward-转发">3.2.1 forward 转发</h4>
<p>controller 方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成：</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 转发</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@RequestMapping("/testForward")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testForward</span><span class="hljs-params">()</span> </span>{
    System.out.println(<span class="hljs-string">"AccountController 的 testForward 方法执行了。。。。 "</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/WEB-INF/pages/success.jsp"</span>;
}</code></pre>
<p>需要注意的是，如果用了 formward： 则路径必须写成实际视图 url，不能写逻辑视图。<br>
它相当于<code> request.getRequestDispatcher("url").forward(request,response)</code>。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器方法。</p>
<h4 id="3-2-2-Redirect-重定向">3.2.2 Redirect 重定向</h4>
<p>contrller 方法提供了一个 String 类型返回值之后， 它需要在返回值里使用:redirect:</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 重定向</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@RequestMapping("/testRedirect")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testRedirect</span><span class="hljs-params">()</span> </span>{
System.out.println(<span class="hljs-string">"AccountController 的 testRedirect 方法执行了。。。。 "</span>);
<span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:testReturnModelAndView"</span>;
}</code></pre>
<p>它相当于<code>response.sendRedirect(url)</code> 。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不能写在 WEB-INF 目录中，否则无法找到</p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
        <tag>SpringMVC框架</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习笔记06-vuex</title>
    <url>/2020/05/05/vue/Vuex/</url>
    <content><![CDATA[<h1>vue学习笔记06-vuex</h1>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/tree-736875_1280.jpg" alt=""></p>
<hr>
<h2 id="Vuex是做什么的">Vuex是做什么的?</h2>
<p>官方解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。<br>
它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>
Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>
<h3 id="状态管理到底是什么？">状态管理到底是什么？</h3>
<p>状态管理模式、集中式存储管理这些名词听起来就非常高大上，让人捉摸不透。其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。<br>
<code>然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</code>那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？等等，如果是这样的话，为什么官方还要专门出一个插件Vuex呢？难道我们不能自己封装一个对象来管理吗？<br>
<code>当然可以，只是我们要先想想VueJS带给我们最大的便利是什么呢？没错，就是响应式。</code><br>
如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢？当然也可以，只是自己封装可能稍微麻烦一些。不用怀疑，Vuex就是为了提供这样一个在多个组件间共享状态的插件，用它就可以了。</p>
<h3 id="管理什么状态呢">管理什么状态呢?</h3>
<p>但是，有什么状态时需要我们在多个组件间共享的呢？如果你做过大型开放，你一定遇到过多个状态，在多个界面间的共</p>
<p>享问题。比如用户的登录状态、用户名称、头像、地理位置信息等等。比如商品的收藏、购物车中的物品等等。</p>
<p>这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的（待会儿我们就可以看到代码了，莫着急）。</p>
<p>OK，从理论上理解了状态管理之后，让我们从实际的代码再来看看状态管理。</p>
<p><code>毕竟，Talk is cheap, Show me the code.(来自Linus)我们先来看看但界面的状态管理吧.</code></p>
<h3 id="单界面的状态管理">单界面的状态管理</h3>
<p>我们知道，要在单个组件中进行状态管理是一件非常简单的事情。什么意思呢？我们来看下面的图片。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001101301530.png" alt="image-20201001101301530"></p>
<p>这图片中的三种东西，怎么理解呢？<br>
State：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性）<br>
View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？）<br>
Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</p>
<p>写点代码，加深理解：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001101328897.png" alt="image-20201001101328897"></p>
<p>看下右边的代码效果, 肯定会实现吧?</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001101338978.png" alt="image-20201001101338978"></p>
<p>在这个案例中，我们有木有状态需要管理呢？没错，就是个数counter。<br>
<code>counter需要某种方式被记录下来，也就是我们的State。</code></p>
<p>counter目前的值需要被显示在界面中，也就是我们的View部分。</p>
<p>界面发生某些操作时（我们这里是用户的点击，也可以是用户的input），<code>需要去更新状态，也就是我们的Actions</code></p>
<p>这不就是上面的流程图了吗？</p>
<h3 id="多界面状态管理">多界面状态管理</h3>
<p>Vue已经帮我们做好了单个界面的状态管理，但是如果是多个界面呢？</p>
<p><code>多个试图都依赖同一个状态（一个状态改了，多个界面需要进行更新）不同界面的Actions都想修改同一个状态（Home.vue需要修改，Profile.vue也需要修改这个状态）</code></p>
<p>也就是说对于某些状态(状态1/状态2/状态3)来说只属于我们某一个试图，但是也有一些状态(状态a/状态b/状态c)属于多个试图共同想要维护的<br>
状态1/状态2/状态3你放在自己的房间中，你自己管理自己用，没问题。<br>
但是状态a/状态b/状态c我们希望交给一个大管家来统一帮助我们管理！！！</p>
<p>没错，<code>Vuex就是为我们提供这个大管家的工具。</code></p>
<p><code>全局单例模式（大管家）</code><br>
我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。<br>
之后，你们每个 view，按照我规定好的规定，进行访问和修改等操作。<br>
这就是Vuex背后的基本思想。</p>
<h3 id="Vuex状态管理图例">Vuex状态管理图例</h3>
<p>一起在来看一副官方给出的图片</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001101635053.png" alt="image-20201001101635053"></p>
<h2 id="Vuex的基本使用">Vuex的基本使用</h2>
<p>我们还是实现一下之前简单的案例</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001101751123.png" alt="image-20201001101751123"></p>
<p>首先，我们需要在某个地方存放我们的Vuex代码：<br>
这里，我们先创建一个文件夹store，并且在其中创建一个index.js文件<br>
在index.js文件中写入如下代码：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001101815560.png" alt="image-20201001101815560"></p>
<p>其次，我们让所有的Vue组件都可以使用这个store对象。来到main.js文件，导入store对象，并且放在new Vue中</p>
<p>这样，<code>在其他Vue组件中，我们就可以通过this.$store的方式，获取到这个store对象了</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001101925409.png" alt="image-20201001101925409"></p>
<p>好的，这就是使用Vuex最简单的方式了。我们来对使用步骤，做一个简单的小节：</p>
<ol>
<li>
<p>提取出一个公共的store对象，用于保存在多个组件中共享的状态</p>
</li>
<li>
<p>将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</p>
</li>
<li>
<p>在其他组件中使用store对象中保存的状态即可。通过this.$store.state.属性的方式来访问状态</p>
<p>通过this.$store.commit(‘mutation中方法’)来修改状态</p>
<p>注意事项：<code>我们通过提交mutation的方式，而非直接改变store.state.count。</code><br>
这是因为Vuex可以更明确的追踪状态的变化，<code>所以不要直接改变store.state.count的值。</code></p>
</li>
</ol>
<h2 id="Vuex的核心概念">Vuex的核心概念</h2>
<p>Vuex有几个比较核心的概念:<br>
State<br>
Getters<br>
Mutation<br>
Action<br>
Module<br>
我们对它进行一一介绍.</p>
<h3 id="State单一状态树">State单一状态树</h3>
<p>Vuex提出使用单一状态树, 什么是单一状态树呢？英文名称是Single Source of Truth，也可以翻译成单一数据源。</p>
<p>但是，它是什么呢？我们来看一个生活中的例子。OK，我用一个生活中的例子做一个简单的类比。</p>
<p>我们知道，在国内我们有很多的信息需要被记录，比如上学时的个人档案，工作后的社保记录，公积金记录，结婚后的婚姻信息，以及其他相关的户口、医疗、文凭、房产记录等等（还有很多信息）。</p>
<p>这些信息被分散在很多地方进行管理，有一天你需要办某个业务时(比如入户某个城市)，你会发现你需要到各个对应的工作地点去打印、盖章各种资料信息，最后到一个地方提交证明你的信息无误。</p>
<p>这种保存信息的方案，不仅仅低效，而且不方便管理，以及日后的维护也是一个庞大的工作(需要大量的各个部门的人力来维护，当然国家目前已经在完善我们的这个系统了)。<br>
这个和我们在应用开发中比较类似：<br>
<code>如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难。所以Vuex也使用了单一状态树来管理应用层级的全部状态。</code><br>
单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。</p>
<h3 id="Getters基本使用">Getters基本使用</h3>
<p>有时候，我们需要从store中获取一些state变异后的状态，比如下面的Store中：<br>
获取学生年龄大于20的个数。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001102316623.png" alt="image-20201001102316623"></p>
<p>我们可以在Store中定义getters</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001102324808.png" alt="image-20201001102324808"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001102330021.png" alt="image-20201001102330021"></p>
<p>如果我们已经有了一个获取所有年龄大于20岁学生列表的getters, 那么代码可以这样来写</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001102350974.png" alt="image-20201001102350974"></p>
<p>getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.<br>
比如上面的案例中,我们希望根据ID获取用户的信息</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001102358424.png" alt="image-20201001102358424"></p>
<h3 id="Mutation状态更新">Mutation状态更新</h3>
<p><code>Vuex的store状态的更新唯一方式：提交Mutation</code></p>
<p>Mutation主要包括两部分：</p>
<p>字符串的事件类型（type）。一个回调函数（handler）,该回调函数的第一个参数就是state。<br>
mutation的定义方式：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001102908754.png" alt="image-20201001102908754"></p>
<p>通过mutation更新</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001102912834.png" alt="image-20201001102912834"></p>
<h4 id="Mutation传递参数">Mutation传递参数</h4>
<p>在通过mutation更新数据的时候, 有可能我们希望携带一些额外的参数。参数被称为是mutation的载荷(Payload)<br>
Mutation中的代码:</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001103024606.png" alt="image-20201001103024606"></p>
<p>但是如果参数不是一个呢?比如我们有很多参数需要传递.<br>
这个时候, 我们通常会以对象的形式传递, 也就是payload是一个对象。这个时候可以再从对象中取出相关的信息.</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001103043242.png" alt="image-20201001103043242"></p>
<h4 id="Mutation提交风格">Mutation提交风格</h4>
<p>上面的通过commit进行提交是一种普通的方式<br>
Vue还提供了另外一种风格, 它是一个包含type属性的对象</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001103154798.png" alt="image-20201001103154798"></p>
<p>Mutation中的处理方式是将整个commit的对象作为payload使用, 所以代码没有改变, 依然如下:</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001103202938.png" alt="image-20201001103202938"></p>
<h4 id="Mutation响应规则">Mutation响应规则</h4>
<p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新。这就要求我们必须遵守一些Vuex对应的规则:</p>
<p>提前在store中初始化好所需的属性。当给state中的对象添加新属性时, 使用下面的方式:</p>
<ol>
<li>使用Vue.set(obj, ‘newProp’, 123)</li>
<li>用新对象给旧对象重新赋值</li>
</ol>
<p>我们来看一个例子:当我们点击更新信息时, 界面并没有发生对应改变.</p>
<p>如何才能让它改变呢?查看下面代码的方式一和方式二。都可以让state中的属性是响应式的.</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001103428715.png" alt="image-20201001103428715"></p>
<h4 id="Mutation常量类型-–-概念">Mutation常量类型 – 概念</h4>
<p>我们来考虑下面的问题：在mutation中, 我们定义了很多事件类型(也就是其中的方法名称)。</p>
<p>当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多.</p>
<p>方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况.<br>
如何避免上述的问题呢?</p>
<p><code>在各种Flux实现中, 一种很常见的方案就是使用常量替代Mutation事件的类型.</code></p>
<p>我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然.<br>
具体怎么做呢?<br>
我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.<br>
定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称.</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001103801680.png" alt="image-20201001103801680"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001103819962.png" alt="image-20201001103819962"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001103825664.png" alt="image-20201001103825664"></p>
<h4 id="Mutation同步函数">Mutation同步函数</h4>
<p>通常情况下, Vuex要求我们Mutation中的方法必须是同步方法。主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照。但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成.<br>
比如我们之前的代码, 当执行更新时, devtools中会有如下信息: 图1</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001103926907.png" alt="image-20201001103926907"></p>
<p>但是, 如果Vuex中的代码, 我们使用了异步函数: 图2</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001103931794.png" alt="image-20201001103931794"></p>
<p>你会发现state中的info数据一直没有被改变, 因为他无法追踪到。<code>因此，通常情况下, 不要再mutation中进行异步的操作</code></p>
<h3 id="Action的基本定义">Action的基本定义</h3>
<p>我们强调, 不要再Mutation中进行异步操作。但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的. 这个时候怎么处理呢?</p>
<p><code>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.</code></p>
<p>Action的基本使用代码如下:<br>
context是什么?</p>
<p><code>context是和store对象具有相同方法和属性的对象.</code></p>
<p>也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取context.state等.</p>
<p>但是注意, 这里它们并不是同一个对象, 为什么呢? 我们后面学习Modules的时候,。</p>
<p>我们定义了actions, 然后又在actions中去进行commit, 这不是脱裤放屁吗?</p>
<p><code>事实上并不是这样, 如果在Vuex中有异步操作, 那么我们就可以在actions中完成了.</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001104150464.png" alt="image-20201001104150464"></p>
<h4 id="Action的分发">Action的分发</h4>
<p>在Vue组件中, 如果我们调用action中的方法, 那么就需要使用dispatch</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001104235614.png" alt="image-20201001104235614"></p>
<p>同样的, 也是支持传递payload</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001104241037.png" alt="image-20201001104241037"></p>
<h4 id="Action返回的Promise">Action返回的Promise</h4>
<p>前面我们学习ES6语法的时候说过, Promise经常用于异步操作。在Action中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject.<br>
OK, 我们来看下面的代码:</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001104354476.png" alt="image-20201001104354476"></p>
<h3 id="认识Module">认识Module</h3>
<p>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?<code>Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理。当应用变得非常复杂时,store对象就有可能变得相当臃肿。</code>为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutation、action、getters等</p>
<p>我们按照什么样的方式来组织模块呢?</p>
<p>我们来看左边的代码</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001104611130.png" alt="image-20201001104611130"></p>
<h4 id="Module局部状态">Module局部状态</h4>
<p>上面的代码中, 我们已经有了整体的组织结构, 下面我们来看看具体的局部模块中的代码如何书写.</p>
<p>我们在moduleA中添加state、mutations、getters</p>
<p>mutation和getters接收的第一个参数是局部状态对象</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001104707803.png" alt="image-20201001104707803"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001104728296.png" alt="image-20201001104728296"></p>
<p>注意：虽然, 我们的doubleCount和increment都是定义在对象内部的。但是在调用的时候, 依然是通过this.$store来直接调用的.</p>
<h4 id="Actions的写法">Actions的写法</h4>
<p>actions的写法呢? 接收一个context参数对象<br>
局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001110647431.png" alt="image-20201001110647431"></p>
<p>如果getters中也需要使用全局的状态, 可以接受更多的参数</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001110654980.png" alt="image-20201001110654980"></p>
<p>项目结构</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001110737846.png" alt="image-20201001110737846"></p>
<h4 id="常用的模块化开发结构">常用的模块化开发结构</h4>
<p>目录结构：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20201001105136797.png" alt="image-20201001105136797"></p>
<p>在 index.js中做如下定义：</p>
<pre><code class="hljs js"><span class="hljs-comment">// store的index.js文件</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>

Vue.use(Vuex)

<span class="hljs-keyword">const</span> modulesFiles = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">'./modules'</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.js$/</span>)

<span class="hljs-keyword">const</span> modules = modulesFiles.keys().reduce(<span class="hljs-function">(<span class="hljs-params">modules, modulePath</span>) =&gt;</span> {
    <span class="hljs-comment">// set './app.js' =&gt; 'app'</span>
    <span class="hljs-keyword">const</span> moduleName = modulePath.replace(<span class="hljs-regexp">/^\.\/(.*)\.\w+$/</span>, <span class="hljs-string">'$1'</span>)
    <span class="hljs-keyword">const</span> value = modulesFiles(modulePath)
    modules[moduleName] = value.default
    <span class="hljs-keyword">return</span> modules
}, {})


<span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store({
    modules
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store
</code></pre>
<p>在每个store文件中可以这样定义：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> state = <span class="hljs-function">() =&gt;</span> ({
  .......
})

<span class="hljs-keyword">const</span> getters = {
    ......
}

<span class="hljs-keyword">const</span> mutations = { <span class="hljs-comment">// mutations改变state中的数据</span>
  ......
}

<span class="hljs-keyword">const</span> actions = { <span class="hljs-comment">// 发送请求</span>
  ........
}


<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    namespaced: <span class="hljs-literal">true</span>,<span class="hljs-comment">//注意要开启这个</span>
    state,
    mutations,
    actions,
    getters
}
</code></pre>
<p>这样在组件中使用的时候可以这样：</p>
<pre><code class="hljs vue">&lt;template&gt;
  .......
&lt;/template&gt;

&lt;script&gt;

import { mapState } from 'vuex' //

export default {
  name: "login",
  methods: {
  },
  computed: 
    ...mapState({ // 这个是提取store中access.js的state的数据
      'loginState': 'login'
    })
  }
};
&lt;/script&gt;
&lt;style scoped&gt;
   ....
&lt;/style&gt;
</code></pre>]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习笔记01-vue的基本介绍和语法</title>
    <url>/2020/05/05/vue/Vue%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1>vue学习笔记01-vue的基本介绍和语法</h1>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/cat-5496162_1280.jpg" alt=""></p>
<hr>
<h1>ES6新特性</h1>
<h2 id="let块级作用域">let块级作用域</h2>
<p>不再使用 <code>var</code> 定义变量，而使用 <code>let</code>定义</p>
<blockquote>
<p>在ES5之前，由于 IF  和 FOR 是没有块级作用域的，所以在很多时候，是借助 function 的作用域来解决应用外部变量的问题，在ES6中，加入了 let  ，它在  IF  和 FOR 是有块级作用域的.</p>
</blockquote>
<ol>
<li>
<p>变量作用域：变量在什么范围内是可用的</p>
<ol>
<li>
<p><code>if（）{}</code>的块级是没有作用域的</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a=<span class="hljs-number">1</span>;
<span class="hljs-keyword">if</span>(a){
    <span class="hljs-built_in">console</span>.log(a);
}
<span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">//仍然会打印</span></code></pre>
</li>
<li>
<p><code>for（）{}</code>的块级没有作用域</p>
<pre><code class="hljs javascript">&lt;div id=<span class="hljs-string">"app"</span>&gt;
    &lt;button&gt;<span class="hljs-number">1</span>&lt;/button&gt;
    &lt;button&gt;<span class="hljs-number">2</span>&lt;/button&gt;
    &lt;button&gt;<span class="hljs-number">3</span>&lt;/button&gt;
    &lt;button&gt;<span class="hljs-number">4</span>&lt;/button&gt;
    &lt;button&gt;<span class="hljs-number">5</span>&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
    <span class="hljs-keyword">var</span> btns=<span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"button"</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;btns.length;i++){
        btns[i].addEventListener(<span class="hljs-string">"click"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(i+<span class="hljs-string">"按钮"</span>);<span class="hljs-comment">//只会打印 5按钮</span>
        });
    }
&lt;/script&gt;</code></pre>
</li>
<li>
<p><code>function(){}</code>块级是有作用域的</p>
</li>
</ol>
</li>
<li>
<p>没有块级作用域会导致的问题：变量访问没有限制</p>
</li>
</ol>
<h2 id="const常量赋值">const常量赋值</h2>
<ol>
<li>被 const 修饰的变量不能再次被赋值，称为常量，保证数据的安全性，在ES6中优先使用  const</li>
<li>在使用 const 时，必须进行赋值</li>
<li>常量的含义是指向的对象不能修改，但是<code>可以修改对象内部的属性</code>，</li>
</ol>
<h2 id="对象字面量的增强写法">对象字面量的增强写法</h2>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> age=<span class="hljs-number">16</span>;
<span class="hljs-keyword">let</span> name=<span class="hljs-string">"zhangsan"</span>;
<span class="hljs-keyword">const</span> obj= {
    age , <span class="hljs-comment">//这么写相当于 age:age; 把变量名做 key ,值 做 value</span>
    name,
    <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>{

    },<span class="hljs-comment">//常用这种写法</span>
    eat:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        
    }<span class="hljs-comment">//不推荐这种写法</span>
};
<span class="hljs-built_in">console</span>.log(obj);</code></pre>
<h1>认识Vue</h1>
<p>Vue (读音 /vjuː/，类似于 view)，不要读错。</p>
<p><code>Vue是一个渐进式的框架，什么是渐进式的呢？</code></p>
<p>渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。<br>
<code>Vue有很多特点和Web开发中常见的高级功能</code><br>
解耦视图和数据，可复用的组件，前端路由技术，状态管理，虚拟DOM</p>
<p><code>Vue的前景广阔</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200717092243649.png" alt="image-20200717092243649"></p>
<h1>Vue.js安装</h1>
<p>使用一个框架，我们第一步要做什么呢？安装下载它<br>
安装Vue的方式有很多：</p>
<h3 id="方式一：直接CDN引入">方式一：直接CDN引入</h3>
<p>你可以选择引入开发环境版本还是生产环境版本</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span> 
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 id="方式二：下载和引入">方式二：下载和引入</h3>
<p><strong>开发环境</strong> <a class="link" href="https://vuejs.org/js/vue.js">https://vuejs.org/js/vue.js<i class="fas fa-external-link-alt"></i></a><br>
<strong>生产环境</strong> <a class="link" href="https://vuejs.org/js/vue.min.js">https://vuejs.org/js/vue.min.js<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="方式三：NPM安装">方式三：NPM安装</h3>
<p>后续通过webpack和CLI的使用，我们使用该方式。</p>
<h1>Vue中的MVVM</h1>
<p>MVVM：维基百科解释：<a class="link" href="https://zh.wikipedia.org/wiki/MVVM">https://zh.wikipedia.org/wiki/MVVM<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM的视图模型是一个值转换器，这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。</p>
</blockquote>
<p>Vue中的MVVM：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200717093934052.png" alt="image-20200717093934052"></p>
<h3 id="View层：">View层：</h3>
<p>视图层：在我们前端开发中，通常就是DOM层。主要的作用是给用户展示各种信息。</p>
<h3 id="Model层：">Model层：</h3>
<p>数据层：数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。在我们计数器的案例中，就是后面抽取出来的obj，当然，里面的数据可能没有这么简单。</p>
<h3 id="VueModel层：">VueModel层：</h3>
<p>视图模型层：视图模型层是View和Model沟通的桥梁。一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中。另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。</p>
<h4 id="案例分析：">案例分析：</h4>
<p>View依然是我们的DOM<br>
Model就是我们我们抽离出来的obj<br>
ViewModel就是我们创建的Vue对象实例<br>
它们之间如何工作呢？<br>
<code>首先ViewModel通过Data Binding让obj中的数据实时的在DOM中显示。</code><br>
<code>其次ViewModel通过DOM Listener来监听DOM事件，并且通过methods中的操作，来改变obj中的数据。</code><br>
<code>有了Vue帮助我们完成VueModel层的任务，在后续的开发，我们就可以专注于数据的处理，以及DOM的编写工作了。</code></p>
<pre><code class="hljs html">。。
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>当前计数：{{sum}}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-comment">&lt;!--    &lt;button v-on:click="increment"&gt;+&lt;/button&gt;--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"increment"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"decrement"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
            sum: 0
        },
        methods:{
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.sum++;</span>
            },
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">decrement</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.sum--;</span>
            }
        }
    });
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
。。</code></pre>
<h1>Vue的生命周期</h1>
<p>生命周期：事物从诞生到消亡的整个过程</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200725201354383.png" alt="image-20200725201354383" style="zoom:150%;">
<h1>Vue基础语法</h1>
<h2 id="插值操作：">插值操作：</h2>
<h3 id="Mustache语法：">Mustache语法：</h3>
<p>不仅可以使用变量，也可以使用表达式</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{firstName+" "+lastName}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre>
<h3 id="v-once指令：">v-once指令：</h3>
<p>该指令后面不需要跟任何表达式(比如之前的v-for后面是由跟表达式的)<br>
该指令表示元素和组件(组件后面才会学习)只渲染一次，不会随着数据的改变而改变。</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{message}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-once</span>&gt;</span>{{message}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200725204551619.png" alt="image-20200725204551619"></p>
<h3 id="v-html指令：">v-html指令：</h3>
<p>某些情况下，我们从服务器请求到的数据本身就是一个HTML代码，如果我们直接通过<code>{{}}`来输出，会将HTML代码也一起输出。但是我们可能希望的是按照HTML格式进行解析，并且显示对应的内容。
如果我们希望解析出HTML展示，可以使用v-html指令。
该指令后面往往会跟上一个string类型，会将string的html解析出来并且进行渲染

![image-20200725205058025](https://img.sky123.top/img/image-20200725205058025.png)

### v-text指令：

v-text作用和Mustache比较相似：都是用于将数据显示在界面中
v-text通常情况下，接受一个string类型，但是不够灵活

![image-20200725205515022](https://img.sky123.top/img/image-20200725205515022.png)

### v-pre指令：

v-pre用于跳过这个元素和它子元素的编译过程，用于显示原本的Mustache语法。
比如下面的代码：
第一个h2元素中的内容会被编译解析出来对应的内容
第二个h2元素中会直接显示`{{message}}</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200725205500027.png" alt="image-20200725205500027"></p>
<h3 id="v-cloak指令：">v-cloak指令：</h3>
<p>在某些情况下，我们浏览器可能会直接显然出未编译的Mustache标签。<br>
cloak: 斗篷</p>
<p>在 vue 解析之前，div中有一个属性 v-cloak</p>
<p>在 vue 解析之后，div中没有一个属性 v-cloak</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200725205918844.png" alt="image-20200725205918844"></p>
<h2 id="绑定属性值：">绑定属性值：</h2>
<p>前面我们学习的指令主要作用是将值插入到我们模板的内容当中。但是，除了内容需要动态来决定外，某些属性我们也希望动态来绑定。<br>
比如动态绑定a元素的href属性，比如动态绑定img元素的src属性。这个时候，我们可以使用v-bind指令：</p>
<h3 id="v-bind指令：">v-bind指令：</h3>
<p>v-bind用于绑定一个或多个属性值，或者向另一个组件传递props值(这个学到组件时再介绍)<br>
在开发中，有哪些属性需要动态进行绑定呢？<br>
还是有很多的，比如图片的链接src、网站的链接href、动态绑定一些类、样式等等</p>
<blockquote>
<p>作用：动态绑定属性<br>
缩写：:<br>
预期：any (with argument) | Object (without argument)<br>
参数：attrOrProp (optional)</p>
</blockquote>
<p>比如通过Vue实例中的data绑定元素的src和href，代码如下：</p>
<p><code>在前面加上 v-bind：表示需要动态获取</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200725211020889.png" alt="image-20200725211020889"></p>
<h3 id="v-bind语法糖（简写方法）：">v-bind语法糖（简写方法）：</h3>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200725211238118.png" alt="image-20200725211238118" style="zoom:80%;">
<h3 id="v-bind绑定class">v-bind绑定class:</h3>
<p>很多时候，我们希望动态的来切换class，比如：<br>
当数据为某个状态时，字体显示红色。当数据另一个状态时，字体显示黑色。<br>
绑定class有两种方式：对象语法，数组语法</p>
<h4 id="绑定方式：对象语法">绑定方式：对象语法</h4>
<p>对象语法的含义是:class后面跟的是一个对象。<br>
对象语法有下面这些用法：<br>
用法一：直接通过{}绑定一个类</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{'active': isActive}"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
<span class="javascript">            isActive:<span class="hljs-literal">true</span>,<span class="hljs-comment">//根据boolen决定class属性值是否存在</span></span>
<span class="javascript">            isLine:<span class="hljs-literal">false</span></span>
        }
    })
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>用法二：也可以通过判断，传入多个值</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{'active': isActive, 'line': isLine}"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre>
<p>用法三：和普通的类同时存在，并不冲突<br>
注：如果isActive和isLine都为true，那么会有title/active/line三个类</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{'active': isActive, 'line': isLine}"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre>
<p>用法四：如果过于复杂，可以放在一个methods或者computed中<br>
注：classes是一个计算属性</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"classes"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"getClass()"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"btnClick"</span>&gt;</span>测试<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
<span class="javascript">            message: <span class="hljs-string">'Hello Vue!'</span>,</span>
<span class="javascript">            imgUrl:<span class="hljs-string">'https://cn.vuejs.org/images/logo.png'</span>,</span>
<span class="javascript">            isActive:<span class="hljs-literal">true</span>,</span>
<span class="javascript">            isLine:<span class="hljs-literal">false</span></span>
        },
        methods:{
<span class="javascript">            btnClick:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.isActive=!<span class="hljs-built_in">this</span>.isActive;</span>
            },
<span class="javascript">            getClass:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</span>
<span class="javascript">                <span class="hljs-keyword">return</span> {<span class="hljs-string">'active'</span>: <span class="hljs-built_in">this</span>.isActive, <span class="hljs-string">'line'</span>: <span class="hljs-built_in">this</span>.isLine};</span>
            }
        }
    })
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h4 id="绑定方式：数组语法：">绑定方式：数组语法：</h4>
<p>数组语法的含义是:class后面跟的是一个数组。<br>
数组语法有下面这些用法<br>
用法一：直接通过{}绑定一个类</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"['active']"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre>
<p>用法二：也可以传入多个值，如果去掉引号，则是变量</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">“[‘active’,</span> '<span class="hljs-attr">line</span>']"&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre>
<p>用法三：和普通的类同时存在，并不冲突<br>
注：会有title/active/line三个类</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">“[‘active’,</span> '<span class="hljs-attr">line</span>']"&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre>
<p>用法四：如果过于复杂，可以放在一个methods或者computed中<br>
注：classes是一个计算属性</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"classes"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre>
<h3 id="v-bind绑定style：">v-bind绑定style：</h3>
<p>我们可以利用 v-bind:style 来绑定一些CSS内联样式。<br>
在写CSS属性名的时候，比如 font-size<br>
我们可以使用驼峰式   fontSize 或短横线分隔 (记得用单引号括起来) ‘font-size’<br>
绑定class有两种方式：</p>
<h4 id="绑定方式一：对象语法：">绑定方式一：对象语法：</h4>
<pre><code class="hljs html">:style="{color: currentColor, fontSize: fontSize + 'px'}"</code></pre>
<p>style后面跟的是一个对象类型<br>
对象的key是CSS属性名称<br>
对象的value是具体赋的值，值可以来自于data中的属性</p>
<h4 id="绑定方式二：数组语法：">绑定方式二：数组语法：</h4>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>style后面跟的是一个数组类型，多个值以 ” ，“ 分割</p>
<h2 id="计算属性：">计算属性：</h2>
<p>我们知道，在模板中可以直接通过插值语法显示一些data中的数据。但是在某些情况，我们可能需要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示。比如我们有firstName和lastName两个变量，我们需要显示完整的名称。<br>
但是如果多个地方都需要显示完整的名称，我们就需要写多个<code>{{firstName}} {{lastName}}</code>。我们可以将上面的代码换成计算属性：OK，我们发现计算属性是写在实例的computed选项中的。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200726200213755.png" alt="image-20200726200213755"></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{fullMessage2() 调用方法}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  
    
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{fullMessage  调用计算属性}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
<span class="javascript">            message: <span class="hljs-string">'Hello Vue!'</span>,</span>
<span class="javascript">            message2:<span class="hljs-string">'kobe'</span></span>
        },
        computed:{
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">fullMessage</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-comment">//按照属性来命名</span></span>
<span class="javascript">                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message+<span class="hljs-built_in">this</span>.message2;</span>
            }
        },
        methods:{
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">fullMessage2</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message+<span class="hljs-built_in">this</span>.message2;</span>
            }
        }
    })
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="计算属性的复杂操作：">计算属性的复杂操作：</h3>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200726201218057.png" alt="image-20200726201218057" style="zoom: 80%;">
<pre><code class="hljs html">
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{fullPrice}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
<span class="javascript">            message: <span class="hljs-string">'Hello Vue!'</span>,</span>
            books:[
                {money: 100,count: 20},
                {money: 200,count: 30}
            ]
        },
        computed:{
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">fullPrice</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">                <span class="hljs-keyword">let</span> result=<span class="hljs-number">0</span>;</span>
<span class="javascript">                <span class="hljs-comment">//一般方法</span></span>
<span class="javascript">                <span class="hljs-comment">// for(let i=0;i&lt;this.books.length;i++){</span></span>
<span class="javascript">                <span class="hljs-comment">//     result+=this.books[i].money*this.books[i].count;</span></span>
<span class="javascript">                <span class="hljs-comment">// }</span></span>

<span class="javascript">                <span class="hljs-comment">//es6语法</span></span>
<span class="javascript">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> book <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.books){</span>
                    result+=book.money*book.count;
                }
                
<span class="javascript">                <span class="hljs-keyword">return</span> result;</span>
            }
        }
    })
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h3 id="计算属性的setter和getter：">计算属性的setter和getter：</h3>
<p>每个计算属性都包含一个getter和一个setter，在上面的例子中，我们只是使用getter来读取。<br>
在某些情况下，你也可以提供一个setter方法（不常用）。在需要写setter的时候，代码如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200726203043060.png" alt="image-20200726203043060"></p>
<h3 id="计算属性的缓存：">计算属性的缓存：</h3>
<p>我们可能会考虑这样的一个问题：<br>
methods和computed看起来都可以实现我们的功能，<br>
那么为什么还要多一个计算属性这个东西呢？<br>
原因：计算属性会进行缓存，如果多次使用时，计算属性只会调用一次。<br>
我们来看下面的代码：</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200726203607405.png" alt="image-20200726203607405" style="zoom: 200%;">
<h2 id="事件监听：">事件监听：</h2>
<p>在前端开发中，我们需要经常和用于交互。<br>
这个时候，我们就必须监听用户发生的时间，比如点击、拖拽、键盘事件等等<br>
在Vue中如何监听事件呢？使用v-on指令</p>
<blockquote>
<p>v-on介绍<br>
作用：绑定事件监听器<br>
缩写：@<br>
预期：Function | Inline Statement | Object<br>
参数：event</p>
</blockquote>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731115414373.png" alt=""></p>
<h3 id="v-on参数">v-on参数</h3>
<p>当通过 methods 中定义方法，以供@click调用时，需要注意参数问题：</p>
<ol>
<li>
<p>如果该方法不需要额外参数，那么方法后的()可以不添加。<br>
<code>但是注意：如果方法本身中有一个参数且方法后的()不添加。，那么会默认将原生事件event参数传递进第一个方法形参</code></p>
</li>
<li>
<p>如果需要同时传入某个参数，同时需要event时，可以通过 <code>$event</code>传入事件</p>
</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731120258562.png" alt="image-20200731120258562"></p>
<h3 id="v-on修饰符">v-on修饰符</h3>
<p>在某些情况下，我们拿到event的目的可能是进行一些事件处理。Vue提供了修饰符来帮助我们方便的处理一些事件：</p>
<ul>
<li>.stop - 调用 event.stopPropagation()。阻止事件冒泡</li>
<li>.prevent - 调用 event.preventDefault()。阻止表单自动提交</li>
<li>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调（即调用监听函数）。</li>
<li>.native - 监听组件根元素的原生事件。组件时使用</li>
<li>.once - 只触发一次回调。</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731120639118.png" alt="image-20200731120639118"></p>
<h2 id="条件判断：">条件判断：</h2>
<h3 id="v-if、v-else-if、v-else">v-if、v-else-if、v-else</h3>
<p><code>Vue的条件指令可以根据表达式的值在DOM中渲染或销毁元素或组件</code><br>
简单的案例演示：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731165442411.png" alt="image-20200731165442411"></p>
<p>v-if的原理：<br>
v-if后面的条件为false时，对应的元素以及其子元素不会渲染。<br>
也就是根本没有不会有对应的标签出现在DOM中。</p>
<h3 id="条件渲染案例">条件渲染案例</h3>
<p>我们来做一个简单的小案例：<br>
用户再登录时，可以切换使用用户账号登录还是邮箱地址登录。<br>
类似如下情景：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731165615614.png" alt="image-20200731165615614"></p>
<p><code>小问题：</code><br>
如果我们在有输入内容的情况下，切换了类型，我们会发现文字依然显示之前的输入的内容。但是按道理讲，我们应该切换到另外一个input元素中了。在另一个input元素中，我们并没有输入内容。<br>
为什么会出现这个问题呢？<br>
<code>问题解答：</code><br>
这是因为Vue在进行DOM渲染时，出于性能考虑，会尽可能的复用已经存在的元素，而不是重新创建新的元素。在上面的案例中，Vue内部会发现原来的input元素不再使用，直接作为else中的input来使用了。<br>
<code>解决方案：</code><br>
如果我们不希望Vue出现类似重复利用的问题，可以给对应的input添加key。并且我们需要保证key的不同。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731165907400.png" alt="image-20200731165907400"></p>
<h3 id="v-show">v-show</h3>
<p>v-show的用法和v-if非常相似，也用于决定一个元素是否渲染：<br>
v-if和v-show对比<br>
v-if和v-show都可以决定一个元素是否渲染，那么开发中我们如何选择呢？v-if当条件为false时，压根不会有对应的元素在DOM中。v-show当条件为false时，仅仅是将元素的display属性设置为none而已。<br>
开发中如何选择呢？<br>
当需要在显示与隐藏之间切片很频繁时，使用v-show。当只有一次切换时，通过使用v-if。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731170017796.png" alt="image-20200731170017796"></p>
<h2 id="循环遍历：">循环遍历：</h2>
<p>当我们有一组数据需要进行渲染时，我们就可以使用v-for来完成。v-for的语法类似于JavaScript中的for循环。<br>
格式如下：<code>item in items</code></p>
<p>我们来看一个简单的案例：<br>
如果在遍历的过程中不需要使用索引值<br>
<code>v-for="movie in movies"</code><br>
依次从movies中取出movie，并且在元素的内容中，我们可以使用Mustache语法，来使用movie<br>
如果在遍历的过程中，我们需要拿到元素在数组中的索引值呢？<br>
语法格式：<code>v-for=(item, index) in items</code></p>
<p>其中的index就代表了取出的item在原数组的索引值。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731170221651.png" alt="image-20200731170221651"></p>
<h3 id="v-for遍历对象">v-for遍历对象</h3>
<p>v-for可以用于遍历对象：比如某个对象中存储着你的个人信息，我们希望以列表的形式显示出来。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731170402540.png" alt="image-20200731170402540"></p>
<h3 id="组件的key属性">组件的key属性</h3>
<p>官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性。<br>
为什么需要这个key属性呢（了解）？<br>
这个其实和Vue的虚拟DOM的Diff算法有关系。这里我们借用React’s diff algorithm中的一张图来简单说明一下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731170637408.png" alt="image-20200731170637408"></p>
<p>当某一层有很多相同的节点时，也就是列表节点时，我们希望插入一个新的节点。我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的。即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？<br>
所以我们需要使用key来给每个节点做一个唯一标识。Diff算法就可以正确的识别此节点<br>
找到正确的位置区插入新的节点。<br>
<code>所以一句话，key的作用主要是为了高效的更新虚拟DOM。</code></p>
<h3 id="检测数组更新">检测数组更新</h3>
<p>因为Vue是响应式的，所以当数据发生变化时，Vue会自动检测数据变化，视图会发生对应的更新。<br>
<code>Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新。</code><br>
push()     pop()  shift()   unshift()   splice()  sort()   reverse()</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200731170738671.png" alt="image-20200731170738671"></p>
<h2 id="v-model：">v-model：</h2>
<p>Vue中使用v-model指令来实现表单元素和数据的双向绑定。（界面操作和数据改变，都会引起界面改变）</p>
<p>v-model其实是一个语法糖，它的背后本质上是包含两个操作：</p>
<ol>
<li>v-bind绑定一个value属性</li>
<li>v-on指令给当前元素绑定input事件。也就是说下面的代码：等同于下面的代码：</li>
<li>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200801210058016.png" alt="image-20200801210058016" style="zoom:80%;">
</li>
</ol>
<p><code>&lt;input type="text" v-model="message"&gt;</code></p>
<p>等同于<br>
<code>&lt;input type="text" v-bind:value="message" v-on:input="message = $event.target.value"&gt;</code></p>
<h3 id="text和textarea">text和textarea</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200801205920127.png" alt="image-20200801205920127"></p>
<h3 id="radio">radio</h3>
<p>当 v-model 绑定单选按钮时 ，可以给  gender 默认值，这样会默认选中某个单选按钮，可以不用加  name 属性，也能实现单选，只要它绑定的是相同的变量值。</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200801210143486.png" alt="image-20200801210143486" style="zoom:80%;">
<h3 id="checkbox">checkbox</h3>
<p>复选框分为两种情况：单个勾选框和多个勾选框<br>
<code>单个勾选框：v-model即为布尔值。此时input的value并不影响v-model的值。</code><br>
多个复选框：<br>
当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。<br>
当选中某一个时，就会将input的value添加到数组中。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200801210633540.png" alt="image-20200801210633540"></p>
<h3 id="select">select</h3>
<p>和checkbox一样，select也分单选和多选两种情况。</p>
<p><code>单选：只能选中一个值。v-model绑定的是一个值。</code></p>
<p>当我们选中option中的一个时，会将它对应的value赋值到mySelect中</p>
<p><code>多选：可以选中多个值。v-model绑定的是一个数组。</code></p>
<p>当选中多个值时，就会将选中的option对应的value添加到数组mySelects中</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200801210812558.png" alt="image-20200801210812558"></p>
<h3 id="lazy修饰符：">lazy修饰符：</h3>
<p>默认情况下，v-model默认是在input事件中同步输入框的数据的。也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。lazy修饰符可以让数据在失去焦点或者回车时才会更新：</p>
<h3 id="number修饰符：">number修饰符：</h3>
<p>默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。number修饰符可以让在输入框中输入的内容自动转成数字类型：</p>
<h3 id="trim修饰符：">trim修饰符：</h3>
<p>如果输入的内容首尾有很多空格，通常我们希望将其去除。trim修饰符可以过滤内容左右两边的空格</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200801210925199.png" alt="image-20200801210925199"></p>
<h2 id="数组的高阶函数：">数组的高阶函数：</h2>
<pre><code class="hljs js"> <span class="hljs-comment">//高阶函数，函数的参数还是一个函数</span>

 <span class="hljs-comment">//数组过滤器，遍历数组的每一个元素时调用参数的函数，</span>
 <span class="hljs-comment">//filter 参数的函数（回调函数），返回一个boolean ，true保留元素，false过滤元素</span>
<span class="hljs-keyword">let</span> newNums= nums.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>{
   <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">3</span>;
 });
 <span class="hljs-built_in">console</span>.log(newNums);

 <span class="hljs-comment">//数组遍历器，遍历数组的每一个元素时调用参数的函数，</span>
 <span class="hljs-comment">//map 参数的函数（回调函数），返回的值作为新数组的新元素 </span>
<span class="hljs-keyword">let</span> news2Nums= newNums.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>{
     <span class="hljs-keyword">return</span> n*<span class="hljs-number">2</span>;
 });
<span class="hljs-built_in">console</span>.log(news2Nums);

 <span class="hljs-comment">//数组汇总器，对数组中的内容进行汇总</span>
 <span class="hljs-comment">//pre参数，第一次初始化为 0,第二次，的值是回调函数的返回值</span>
<span class="hljs-keyword">let</span> sum=news2Nums.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pre,curr</span>) </span>{
     <span class="hljs-keyword">return</span> pre+curr;
},<span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(sum);

<span class="hljs-comment">//函数式编程</span>
<span class="hljs-keyword">let</span> result=nums.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>{
        <span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">3</span>;
   }).map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*n;
   }).reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pre,n</span>) </span>{
       <span class="hljs-keyword">return</span> pre+n;
   },<span class="hljs-number">0</span>);

   <span class="hljs-built_in">console</span>.log(result);</code></pre>
<h1>两个案例：</h1>
<h2 id="1-列表项的选中并改变颜色">1.列表项的选中并改变颜色</h2>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200801190628117.png" alt="image-20200801190628117" style="zoom:80%;">
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
        .active{
<span class="css">            <span class="hljs-attribute">color</span>:red;</span>
        }
    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{message}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(movie,index) in movies"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{active:true}"</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"index==colorIndex"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"change(index)"</span>&gt;</span>{{movie}}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{active:false}"</span> <span class="hljs-attr">v-else</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"change(index)"</span>&gt;</span>{{movie}}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
<span class="javascript">            message: <span class="hljs-string">'Hello Vue!'</span>,</span>
<span class="javascript">            movies:[<span class="hljs-string">'肖申克的救赎'</span>,<span class="hljs-string">'海贼王'</span>,<span class="hljs-string">'无名之辈'</span>,<span class="hljs-string">'后来'</span>,<span class="hljs-string">'归来'</span>,<span class="hljs-string">'无言以对'</span>],</span>
            colorIndex:0
        },
        methods:{
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">change</span>(<span class="hljs-params">index</span>)</span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.colorIndex = index;</span>
            }
        }

    })
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<h2 id="2-购物车案例">2.购物车案例</h2>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200801191453741.png" alt="image-20200801191453741"></p>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>购物车案例<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css/shopping.css"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"data"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>出版日期<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>价格<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>购买数量<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>  <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(s,index) in books"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{index+1}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{s.name}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{s.date}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>${{s.price.toFixed(2)}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"decrement(index)"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{s.num}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"increment(index)"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"deleteItem(index)"</span>&gt;</span>移除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
    总价：{{sum}}
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> app=<span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#data'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
<span class="javascript">            books:[{<span class="hljs-attr">name</span>:<span class="hljs-string">'&lt;&lt;算法导论&gt;&gt;'</span>,<span class="hljs-attr">date</span>:<span class="hljs-string">'2006-09'</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">29.00</span>,<span class="hljs-attr">num</span>:<span class="hljs-number">1</span>},</span>
<span class="javascript">                {<span class="hljs-attr">name</span>:<span class="hljs-string">'&lt;&lt;算法导论&gt;&gt;'</span>,<span class="hljs-attr">date</span>:<span class="hljs-string">'2006-09'</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">29.00</span>,<span class="hljs-attr">num</span>:<span class="hljs-number">1</span>},</span>
<span class="javascript">                {<span class="hljs-attr">name</span>:<span class="hljs-string">'&lt;&lt;算法导论&gt;&gt;'</span>,<span class="hljs-attr">date</span>:<span class="hljs-string">'2006-09'</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">29.00</span>,<span class="hljs-attr">num</span>:<span class="hljs-number">1</span>}</span>
            ]
        },
        computed:{
<span class="javascript">          <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">              <span class="hljs-keyword">let</span> result=<span class="hljs-number">0</span>;</span>
<span class="javascript">              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> book <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.books){</span>
                  result+=book.price*book.num;
              }
<span class="javascript">              <span class="hljs-keyword">return</span> result.toFixed(<span class="hljs-number">2</span>);</span>
          },

        },
        methods:{
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">index</span>)</span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.books[index].num++;</span>
            },
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">decrement</span>(<span class="hljs-params">index</span>)</span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.books[index].num--;</span>
            },
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">deleteItem</span>(<span class="hljs-params">index</span>)</span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.books.splice(index,<span class="hljs-number">1</span>);</span>
            }
        },
    });
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习笔记02-vue的插槽和组件化开发</title>
    <url>/2020/05/05/vue/Vue%E6%8F%92%E6%A7%BD%E5%92%8C%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
    <content><![CDATA[<h1>vue学习笔记02-vue的插槽和组件化开发</h1>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/red-lighthouse-6011477_1280.jpg" alt=""></p>
<hr>
<h1>组件化</h1>
<h2 id="组件概述">组件概述</h2>
<p>人面对复杂问题的处理方式：<br>
任何一个人处理信息的逻辑能力都是有限的。所以，当面对一个非常复杂的问题时，我们不太可能一次性搞定一大堆的内容。但是，我们人有一种天生的能力，就是将问题进行拆解。如果将一个复杂的问题，拆分成很多个可以处理的小问题，再将其放在整体当中，你会发现大的问题也会迎刃而解。<br>
组件化也是类似的思想：<br>
如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。<br>
<code>但如果，我们讲一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802191140360.png" alt="image-20200802191140360"></p>
<h2 id="Vue组件化思想">Vue组件化思想</h2>
<p>组件化是Vue.js中的重要思想。它提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。<br>
<code>任何的应用都会被抽象成一颗组件树。</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802191328402.png" alt="image-20200802191328402"></p>
<p>组件化思想的应用：<br>
有了组件化的思想，我们在之后的开发中就要充分的利用它。尽可能的将页面拆分成一个个小的、可复用的组件。这样让我们的代码更加方便组织和管理，并且扩展性也更强。<br>
<code>所以，组件是Vue开发中，非常重要的一个篇章，要认真学习。</code></p>
<h2 id="组件的使用步骤">组件的使用步骤</h2>
<ol>
<li>
<p>创建组件构造器</p>
</li>
<li>
<p>注册组件</p>
</li>
<li>
<p>使用组件。</p>
</li>
</ol>
<p>我们来看看通过代码如何注册组件</p>
<p>查看运行结果：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802192040617.png" alt="image-20200802192040617">和直接使用一个div看起来并没有什么区别。但是我们可以设想，如果很多地方都要显示这样的信息，我们是不是就可以直接使用<code>&lt;my-cpn&gt;&lt;/my-cpn&gt; </code>来完成呢？</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
<span class="hljs-comment">&lt;!--   3.使用组件  --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mycpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mycpn</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-comment">//1.创建组件构造器</span></span>
<span class="javascript">    <span class="hljs-comment">//模板就是在使用到组件的地方，要显示的HTML代码。</span></span>
<span class="javascript">    <span class="hljs-keyword">const</span> cpn= Vue.extend({</span>
        template:`
<span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span>
<span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>阿斯蒂芬<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span></span>
<span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span>
        `
    });
<span class="javascript">    <span class="hljs-comment">//2.注册组件</span></span>
<span class="javascript">    Vue.component(<span class="hljs-string">'mycpn'</span>,cpn);</span>

<span class="javascript">    <span class="hljs-comment">//0.首先需要先挂载</span></span>
<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
    });

<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<p>这里的步骤都代表什么含义呢？</p>
<ol>
<li>
<p>Vue.extend()：调用Vue.extend()创建的是一个组件构造器。<br>
通常在创建组件构造器时，传入template代表我们自定义组件的模板。该模板就是在使用到组件的地方，要显示的HTML代码。<code>事实上，这种写法在Vue2.x的文档中几乎已经看不到了，它会直接使用下面我们会讲到的语法糖，但是在很多资料还是会提到这种方式，而且这种方式是学习后面方式的基础</code></p>
</li>
<li>
<p>Vue.component()：调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。所以需要传递两个参数：<code>1、注册组件的标签名 2、组件构造器</code></p>
</li>
<li>
<p>组件必须挂载在某个Vue实例下，否则它不会生效。我们来看下面我使用了三次<my-cpn></my-cpn><br>
而第三次其实并没有生效：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802193836934.png" alt="image-20200802193836934"></p>
</li>
</ol>
<h3 id="注册组件语法糖">注册组件语法糖</h3>
<p>在上面注册组件的方式，可能会有些繁琐。Vue为了简化这个过程，提供了注册的语法糖。主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。语法糖注册全局组件和局部组件：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802221227261.png" alt="image-20200802221227261"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802221236027.png" alt="image-20200802221236027"></p>
<h2 id="全局组件和局部组件">全局组件和局部组件</h2>
<p>当我们通过调用 Vue.component() 注册组件时，组件的注册是全局的。这意味着该组件可以在任意Vue示例下使用。<br>
如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件。</p>
<p><code>总之，局部组件在父组件中定义，全局组件在任意位置定义。在开发中局部组件会更常用</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802220641657.png" alt="image-20200802220641657"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802220705844.png" alt="image-20200802220705844"></p>
<h2 id="父组件和子组件">父组件和子组件</h2>
<p>在前面我们看到了组件树：组件和组件之间存在层级关系。<br>
而其中一种非常重要的关系就是父子组件的关系。我们来看通过代码如何组成的这种层级关系：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802221031932.png" alt="image-20200802221031932"></p>
<p>父子组件错误用法：以子标签的形式在Vue实例中使用。因为当子组件注册到父组件的components时，Vue会编译好父组件的模块。该模板的内容已经决定了父组件将要渲染的HTML（相当于父组件中已经有了子组件中的内容了）<br>
<code>&lt;child-cpn&gt;&lt;/child-cpn&gt;</code>是只能在父组件中被识别的。类似这种用法，<code>&lt;child-cpn&gt;&lt;/child-cpn&gt;</code>是会被浏览器忽略的。</p>
<h2 id="模板的分离写法">模板的分离写法</h2>
<p>刚才，我们通过语法糖简化了Vue组件的注册过程，另外还有一个地方的写法比较麻烦，就是template模块写法。<br>
如果我们能将其中的HTML分离出来写，然后挂载到对应的组件上，必然结构会变得非常清晰。<br>
Vue提供了两种方案来定义HTML模块内容：</p>
<h3 id="使用-script-标签">使用&lt; script&gt;标签</h3>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802222630560.png" alt="image-20200802222630560"></p>
<h3 id="使用-template-标签">使用&lt; template&gt;标签</h3>
<p><code>开发中更常用</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802222637474.png" alt="image-20200802222637474"></p>
<h2 id="组件使用的简化写法">组件使用的简化写法</h2>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{message}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">cparent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cparent</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"parent"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>父组件内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">cchild</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cchild</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"child"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>子组件内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
    
<span class="javascript">    <span class="hljs-comment">//子组件</span></span>
<span class="javascript">    <span class="hljs-keyword">const</span> cchild=Vue.extend({</span>
<span class="javascript">        template:<span class="hljs-string">'#child'</span></span>
    });

<span class="javascript">    <span class="hljs-comment">//父组件</span></span>
<span class="javascript">    <span class="hljs-keyword">const</span> cparent=Vue.extend({</span>
<span class="javascript">        template:<span class="hljs-string">'#parent'</span>,</span>
        components:{
<span class="javascript">            cchild  <span class="hljs-comment">//注册子组件</span></span>
        }
    });

<span class="javascript"><span class="hljs-comment">//根组件</span></span>
<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
<span class="javascript">            message: <span class="hljs-string">'Hello Vue!'</span></span>
        },
        components:{
<span class="javascript">            cparent<span class="hljs-comment">//注册父组件</span></span>
        }
    })
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<h2 id="组件数据存放">组件数据存放</h2>
<h3 id="组件可以访问Vue实例数据吗">组件可以访问Vue实例数据吗?</h3>
<p>组件是一个单独功能模块的封装：这个模块有属于自己的HTML模板，也应该有属性自己的数据data。<br>
组件中的数据是保存在哪里呢？顶层的Vue实例中吗？我们先来测试一下，组件中能不能直接访问Vue实例中的data</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802222952579.png" alt="image-20200802222952579"></p>
<p><code>我们发现不能访问，而且即使可以访问，如果将所有的数据都放在Vue实例中，Vue实例就会变的非常臃肿。</code><br>
<code>结论：Vue组件应该有自己保存数据的地方。</code></p>
<h3 id="组件数据的存放">组件数据的存放</h3>
<p>组件自己的数据存放在哪里呢? 组件对象也有一个data属性(也可以有methods等属性，下面我们有用到)<br>
<code>只是这个data属性必须是一个函数 。而且这个函数返回一个对象，对象内部保存着数据</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802223120146.png" alt="image-20200802223120146"></p>
<h3 id="data为什么是一个函数呢">data为什么是一个函数呢?</h3>
<p>为什么data在组件中必须是一个函数呢?首先，如果不是一个函数，Vue直接就会报错。<br>
其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802223409787.png" alt="image-20200802223409787"></p>
<h2 id="父子组件的通信">父子组件的通信</h2>
<p>在开发中，往往一些数据确实需要从上层传递到下层：<br>
比如在一个页面中，我们从服务器请求到了很多的数据。其中一部分数据，并非是我们整个页面的大组件来展示的，而是需要下面的子组件进行展示。这个时候，并不会让子组件再次发送一个网络请求，而是直接让大组件(父组件)将数据传递给小组件(子组件)。如何进行父子组件间的通信呢？Vue官方提到</p>
<ul>
<li><code>通过props向子组件传递数据</code></li>
<li><code>通过事件向父组件发送消息</code></li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802223556251.png" alt="image-20200802223556251"></p>
<h3 id="通过props父组件向子组件传递数据">通过props父组件向子组件传递数据</h3>
<p>props基本用法<br>
在组件中，使用选项props来声明需要从父级接收到的数据。<br>
props的值有两种方式：</p>
<ol>
<li>
<p>字符串数组，数组中的字符串就是传递时的名称。</p>
</li>
<li>
<p>对象，对象可以设置传递时的类型，也可以设置默认值等。</p>
</li>
</ol>
<h4 id="props数组用法">props数组用法</h4>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802223714082.png" alt="image-20200802223714082"></p>
<h4 id="props对象用法">props对象用法</h4>
<p>当需要对props进行类型等验证时，就需要对象写法了。验证都支持哪些数据类型呢？<br>
<code>String，Number，Boolean，Array，Object，Date，Function，Symbol</code><br>
当我们有自定义构造函数时，验证也支持自定义的类型</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802223933078.png" alt="image-20200802223933078"></p>
<h3 id="通过事件子组件向父组件发送消息">通过事件子组件向父组件发送消息</h3>
<p>当子组件需要向父组件传递数据时，就要用到自定义事件了。<br>
我们之前学习的v-on不仅仅可以用于监听DOM事件，也可以用于组件间的自定义事件。<br>
自定义事件的流程：<br>
<code>在子组件中，通过 $emit() 来触发事件。</code><br>
<code>在父组件中，通过 v-on 来监听子组件事件。</code><br>
我们来看一个简单的例子：<br>
我们之前做过一个两个按钮+1和-1，点击后修改counter。<br>
我们整个操作的过程还是在子组件中完成，但是之后的展示交给父组件。<br>
这样，我们就需要将子组件中的counter，传给父组件的某个属性，比如total。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200802224200523.png" alt="image-20200802224200523"></p>
<h3 id="父子组件通信小案例">父子组件通信小案例</h3>
<ol>
<li>父组件 app 的存有 total，需要通过 props 传给 子组件 child</li>
<li>子组件点击增加减少按钮 ，通过触发函数中的<code>this.$emit('事件名')</code>触发事件，父组件通过<code>@事件名="函数名"</code>监听事件并触发函数，修改total 的值，从而改变传给 child 的值</li>
</ol>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{message}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">cchild</span> <span class="hljs-attr">:ctotal</span>=<span class="hljs-string">"total"</span> @<span class="hljs-attr">decrement</span>=<span class="hljs-string">"decrement"</span> @<span class="hljs-attr">increment</span>=<span class="hljs-string">"increment"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cchild</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"child"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>数量：{{ctotal}}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"cincrement"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"cdecrement"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">const</span> cchild=Vue.extend({</span>
<span class="javascript">        template:<span class="hljs-string">'#child'</span>,</span>
<span class="javascript">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">            <span class="hljs-keyword">return</span>{}</span>
        },
        props:{
           ctotal:{
<span class="javascript">               <span class="hljs-keyword">default</span>:<span class="hljs-number">0</span>,</span>
<span class="javascript">               type:<span class="hljs-built_in">Number</span></span>
           }
        },
        methods:{
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">cincrement</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">'increment'</span>);</span>
<span class="javascript">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"子组件触发增加"</span>);</span>
            },
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">cdecrement</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">'decrement'</span>);</span>
<span class="javascript">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"子组件触发减少"</span>);</span>
            }
        }

    });


<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
<span class="javascript">            message: <span class="hljs-string">'Hello Vue!'</span>,</span>
            total: 0
        },
        components:{
            cchild
        },
        methods:{
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">decrement</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.total--;</span>
            },
<span class="javascript">            <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">                <span class="hljs-built_in">this</span>.total++;</span>
            }
        }
    })
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<h1>插槽(2.5版本及之前适用)</h1>
<h2 id="为什么使用插槽？">为什么使用插槽？</h2>
<p>slot翻译为插槽：在生活中很多地方都有插槽，电脑的USB插槽，插板当中的电源插槽。<code>插槽的目的是让我们原来的设备具备更多的扩展性。</code><br>
组件的插槽：<code>组件的插槽也是为了让我们封装的组件更加具有扩展性。让使用者可以决定组件内部的一些内容到底展示什么。</code><br>
例如：移动网站中的导航栏。移动开发中，几乎每个页面都有导航栏。导航栏我们必然会封装成一个插件，比如nav-bar组件。一旦有了这个组件，我们就可以在多个页面中复用了。但是，每个页面的导航是一样的吗？No，我以京东M站为例。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200807224051986.png" alt="image-20200807224051986"></p>
<h2 id="如何去封装这类的组件呢？">如何去封装这类的组件呢？</h2>
<p>它们也很多区别，但是也有很多共性。如果，我们每一个单独去封装一个组件，显然不合适：比如每个页面都返回，这部分内容我们就要重复去封装。<br>
但是，如果我们封装成一个，好像也不合理：有些左侧是菜单，有些是返回，有些中间是搜索，有些是文字，等等。<br>
如何封装合适呢？抽取共性，保留不同。<br>
<code>最好的封装方式就是将共性抽取到组件中，将不同暴露为插槽。一旦我们预留了插槽，就可以让使用者根据自己的需求，决定插槽中插入什么内容。是搜索框，还是文字，还是菜单。由调用者自己来决定。</code></p>
<p>这就是为什么我们要学习组件中的插槽slot的原因。</p>
<h2 id="slot的基本使用">slot的基本使用</h2>
<p>在子组件中，使用特殊的元素 <code>&lt;slot&gt;</code> 就可以为子组件开启一个插槽。该插槽插入什么内容取决于父组件如何使用。<br>
我们通过一个简单的例子，来给子组件定义一个插槽：<br>
<code>&lt;slot&gt;</code> 中的内容表示，如果没有在该组件中插入任何其他内容，就默认显示该内容有了这个插槽后，父组件如何使用呢？</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200807224414352.png" alt="image-20200807224414352"></p>
<h2 id="具名插槽slot">具名插槽slot</h2>
<p>当子组件的功能复杂时，子组件的插槽可能并非是一个。比如我们封装一个导航栏的子组件，可能就需要三个插槽，分别代表左边、中间、右边。那么，外面在给插槽插入内容时，如何区分插入的是哪一个呢？<br>
这个时候，我们就需要给插槽起一个名字。如何使用具名插槽呢？非常简单，只要给slot元素一个name属性即可<br>
<code>&lt;slot name='myslot'&gt;&lt;/slot&gt;</code></p>
<p>我们来给出一个案例：这里我们先不对导航组件做非常复杂的封装，先了解具名插槽的用法。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200807224630406.png" alt="image-20200807224630406"></p>
<h2 id="编译作用域">编译作用域</h2>
<p><code>总结一句话：在父组件中使用父组件的数据，在子组件中使用子组件的数据</code></p>
<p>在真正学习插槽之前，我们需要先理解一个概念：编译作用域。</p>
<p>官方对于编译的作用域解析比较简单，我们自己来通过一个例子来理解这个概念：<br>
我们来考虑下面的代码是否最终是可以渲染出来的：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200807224729470.png" alt="image-20200807224729470"></p>
<p><code>&lt;my-cpn v-show="isShow"&gt;&lt;/my-cpn&gt;</code>中，我们使用了isShow属性。isShow属性包含在组件中，也包含在Vue实例中。答案：最终可以渲染出来，也就是使用的是Vue实例的属性。<br>
为什么呢？<br>
官方给出了一条准则：<code>父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。</code><br>
而我们在使用<code>&lt;my-cpn v-show="isShow"&gt;&lt;/my-cpn&gt;</code>的时候，整个组件的使用过程是相当于在父组件中出现的。<br>
那么他的作用域就是父组件，使用的属性也是属于父组件的属性。因此，isShow使用的是Vue实例中的属性，而不是子组件的属性。</p>
<h2 id="作用域插槽">作用域插槽</h2>
<p><code>一句话总结：父组件替换插槽的标签，但是内容由子组件来提供。</code><br>
我们先提一个需求：子组件中包括一组数据，比如：pLanguages: [‘JavaScript’, ‘Python’, ‘Swift’, ‘Go’, ‘C++’]<br>
需要在多个界面进行展示：<br>
某些界面是以水平方向一一展示的，某些界面是以列表形式展示的，某些界面直接展示一个数组<br>
内容在子组件，希望父组件告诉我们如何展示，怎么办呢？<br>
利用slot作用域插槽就可以了<br>
我们来看看子组件的定义：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200807225026778.png" alt="image-20200807225026778"></p>
<p><code>在父组件使用我们的子组件时，从子组件中拿到数据：我们通过&lt;template slot-scope="slotProps"&gt;获取到slotProps属性在通过slotProps.data就可以获取到刚才我们传入的data了</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200807225106536.png" alt="image-20200807225106536"></p>
<h2 id="案例总结">案例总结</h2>
<pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">cchild</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cchild</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">cchild</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"title"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>水平展示<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">"child"</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"data"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{child.data.join('----')}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">cchild</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cchild"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>默认显示<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"data"</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">"info"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"i in info"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{{i}}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
<span class="javascript">            message: <span class="hljs-string">'Hello Vue!'</span></span>
        },
        components: {
            cchild:{
<span class="javascript">                template:<span class="hljs-string">'#cchild'</span>,</span>
<span class="javascript">                <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>{</span>
<span class="javascript">                    <span class="hljs-keyword">return</span>{</span>
<span class="javascript">                        info:[<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'4'</span>,<span class="hljs-string">'5'</span>]</span>
                    }
                }
            }
        }
    })
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200807230101154.png" alt="image-20200807230101154" style="zoom:50%;">
<h1>插槽 (2.6版本)</h1>
<blockquote>
<p>该页面假设你已经阅读过了<a class="link" href="https://cn.vuejs.org/v2/guide/components.html">组件基础<i class="fas fa-external-link-alt"></i></a>。如果你还对组件不太了解，推荐你先阅读它。</p>
</blockquote>
<blockquote>
<p>在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 <code>v-slot</code> 指令)。它取代了 <code>slot</code> 和 <code>slot-scope</code> 这两个目前已被废弃但未被移除且仍在<a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95">文档中<i class="fas fa-external-link-alt"></i></a>的 attribute。新语法的由来可查阅这份 <a class="link" href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md">RFC<i class="fas fa-external-link-alt"></i></a>。</p>
</blockquote>
<h2 id="插槽内容"><a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E6%8F%92%E6%A7%BD%E5%86%85%E5%AE%B9">插槽内容<i class="fas fa-external-link-alt"></i></a></h2>
<p><code>总结一句话：插槽的内容可以是 字符串，一个或多个标签，一个或多个组件</code></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">cslot</span>&gt;</span>。。。。<span class="hljs-tag">&lt;/<span class="hljs-name">cslot</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cslot"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>插槽内容如下：<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>
<span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue({</span>
<span class="javascript">        el: <span class="hljs-string">'#app'</span>,<span class="hljs-comment">//用于挂载要管理的元素</span></span>
<span class="javascript">        data: {<span class="hljs-comment">//定义一些数据</span></span>
<span class="javascript">            message: <span class="hljs-string">'Hello Vue!'</span></span>
        },
        components:{
            cslot:{
<span class="javascript">                template:<span class="hljs-string">'#cslot'</span></span>
            }
        }
    })
<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>
<h2 id="具名插槽"><a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD">具名插槽<i class="fas fa-external-link-alt"></i></a></h2>
<blockquote>
<p>自 2.6.0 起有所更新。已废弃的使用 <code>slot</code> attribute 的语法在<a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95">这里<i class="fas fa-external-link-alt"></i></a>。</p>
</blockquote>
<p>有时我们需要多个插槽。例如对于一个带有如下模板的 <code>&lt;base-layout&gt;</code> 组件：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 我们希望把页头放这里 --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"header"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"footer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<p>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p>
<p>在向具名插槽提供内容的时候，我们可以在一个 <code>元素上使用</code>v-slot<code>指令，并以</code>v-slot` 的参数的形式提供其名称：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span></code></pre>
<p>现在 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;&lt;/template&gt;</code>中的内容都会被视为默认插槽的内容。</p>
<p>然而，如果你希望更明确一些，仍然可以在一个 <code>&lt;template&gt;&lt;/template&gt;</code> 中包裹默认插槽的内容：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span></code></pre>
<p>任何一种写法都会渲染出：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre>
<h2 id="作用域插槽-2"><a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">作用域插槽<i class="fas fa-external-link-alt"></i></a></h2>
<blockquote>
<p>自 2.6.0 起有所更新。已废弃的使用 <code>slot-scope</code> attribute 的语法在<a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95">这里<i class="fas fa-external-link-alt"></i></a>。</p>
</blockquote>
<p>有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 <code>&lt;current-user&gt;</code> 组件：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>{{ user.lastName }}<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
<p>我们可能想换掉备用内容，用名而非姓来显示。如下：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span>
  {{ user.firstName }}
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<p>然而上述代码不会正常工作，因为只有 <code>&lt;current-user&gt;</code> 组件可以访问到 <code>user</code> 而我们提供的内容是在父级渲染的。</p>
<p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p>
<p><code>多个用逗号隔开</code></p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">"user,username"</span>&gt;</span>
    {{ user.lastName }}
  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre>
<p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>&gt;</span>
    {{ slotProps.user.firstName }}
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 <code>slotProps</code>，但你也可以使用任意你喜欢的名字。</p>
<h3 id="独占默认插槽的缩写语法"><a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95">独占默认插槽的缩写语法<i class="fas fa-external-link-alt"></i></a></h3>
<p>在上述情况下，当被提供的内容<em>只有</em>默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 <code>v-slot</code> 直接用在组件上：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>&gt;</span>
  {{ slotProps.user.firstName }}
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<p>这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"slotProps"</span>&gt;</span>
  {{ slotProps.user.firstName }}
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<p>注意默认插槽的缩写语法<strong>不能</strong>和具名插槽混用，因为它会导致作用域不明确：</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 无效，会导致警告 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"slotProps"</span>&gt;</span>
  {{ slotProps.user.firstName }}
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:other</span>=<span class="hljs-string">"otherSlotProps"</span>&gt;</span>
    slotProps is NOT available here
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<p>只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt; </code>的语法：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>&gt;</span>
    {{ slotProps.user.firstName }}
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:other</span>=<span class="hljs-string">"otherSlotProps"</span>&gt;</span>
    ...
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<h3 id="解构插槽-Prop"><a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E8%A7%A3%E6%9E%84%E6%8F%92%E6%A7%BD-Prop">解构插槽 Prop<i class="fas fa-external-link-alt"></i></a></h3>
<p>作用域插槽的内部工作原理是将你的插槽内容包括在一个传入单个参数的函数里：</p>
<pre><code class="hljs html">function (slotProps) {
  // 插槽内容
}</code></pre>
<p>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。所以在支持的环境下 (<a class="link" href="https://cn.vuejs.org/v2/guide/single-file-components.html">单文件组件<i class="fas fa-external-link-alt"></i></a>或<a class="link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9">现代浏览器<i class="fas fa-external-link-alt"></i></a>)，你也可以使用 <a class="link" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%A3%E6%9E%84%E5%AF%B9%E8%B1%A1">ES2015 解构<i class="fas fa-external-link-alt"></i></a>来传入具体的插槽 prop，如下：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"{ user }"</span>&gt;</span>
  {{ user.firstName }}
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<p>这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 <code>user</code> 重命名为 <code>person</code>：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"{ user: person }"</span>&gt;</span>
  {{ person.firstName }}
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">"{ user = { firstName: 'Guest' } }"</span>&gt;</span>
  {{ user.firstName }}
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<h2 id="动态插槽名"><a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%8A%A8%E6%80%81%E6%8F%92%E6%A7%BD%E5%90%8D">动态插槽名<i class="fas fa-external-link-alt"></i></a></h2>
<blockquote>
<p>2.6.0 新增</p>
</blockquote>
<p><a class="link" href="https://cn.vuejs.org/v2/guide/syntax.html#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0">动态指令参数<i class="fas fa-external-link-alt"></i></a>也可以用在 <code>v-slot</code> 上，来定义动态的插槽名：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">dynamicSlotName</span>]&gt;</span>
    ...
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span></code></pre>
<h2 id="具名插槽的缩写"><a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99">具名插槽的缩写<i class="fas fa-external-link-alt"></i></a></h2>
<blockquote>
<p>2.6.0 新增</p>
</blockquote>
<p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here's some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span></code></pre>
<p>然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p>
<pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这样会触发一个警告 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> #=<span class="hljs-string">"{ user }"</span>&gt;</span>
  {{ user.firstName }}
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<p>如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">"{ user }"</span>&gt;</span>
  {{ user.firstName }}
<span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre>
<h2 id="其它示例"><a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%85%B6%E5%AE%83%E7%A4%BA%E4%BE%8B">其它示例<i class="fas fa-external-link-alt"></i></a></h2>
<p>**插槽 prop 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的内容。**这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。</p>
<p>例如，我们要实现一个 <code>&lt;todo-list&gt;</code> 组件，它是一个列表且包含布局和过滤逻辑：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  &lt;li
    v-for="todo in filteredTodos"
    v-bind:key="todo.id"
  &gt;
    {{ todo.text }}
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
<p>我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 <code>todo</code> 作为一个插槽 prop 进行绑定：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  &lt;li
    v-for="todo in filteredTodos"
    v-bind:key="todo.id"
  &gt;
    <span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">    我们为每个 todo 准备了一个插槽，</span>
<span class="hljs-comment">    将 `todo` 对象作为一个插槽的 prop 传入。</span>
<span class="hljs-comment">    --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"todo"</span> <span class="hljs-attr">v-bind:todo</span>=<span class="hljs-string">"todo"</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 后备内容 --&gt;</span>
      {{ todo.text }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre>
<p>现在当我们使用 <code>&lt;todo-list&gt;</code> 组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以从子组件获取数据：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">todo-list</span> <span class="hljs-attr">v-bind:todos</span>=<span class="hljs-string">"todos"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:todo</span>=<span class="hljs-string">"{ todo }"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"todo.isComplete"</span>&gt;</span>✓<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    {{ todo.text }}
  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">todo-list</span>&gt;</span></code></pre>
<p>这只是作用域插槽用武之地的冰山一角。想了解更多现实生活中的作用域插槽的用法，我们推荐浏览诸如 <a class="link" href="https://github.com/Akryum/vue-virtual-scroller">Vue Virtual Scroller<i class="fas fa-external-link-alt"></i></a>、<a class="link" href="https://github.com/posva/vue-promised">Vue Promised<i class="fas fa-external-link-alt"></i></a> 和 <a class="link" href="https://github.com/LinusBorg/portal-vue">Portal Vue<i class="fas fa-external-link-alt"></i></a> 等库。</p>
<h2 id="废弃了的语法"><a class="link" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95">废弃了的语法<i class="fas fa-external-link-alt"></i></a></h2>
<blockquote>
<p><code>v-slot</code> 指令自 Vue 2.6.0 起被引入，提供更好的支持 <code>slot</code> 和 <code>slot-scope</code> attribute 的 API 替代方案。<code>v-slot</code> 完整的由来参见这份 <a class="link" href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md">RFC<i class="fas fa-external-link-alt"></i></a>。在接下来所有的 2.x 版本中 <code>slot</code> 和 <code>slot-scope</code> attribute 仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。</p>
</blockquote>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue学习笔记03-webpack</title>
    <url>/2020/05/05/vue/webpack/</url>
    <content><![CDATA[<h1>vue学习笔记03-webpack</h1>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/sunrise-1014712_1280.jpg" alt=""></p>
<hr>
<h1>Webpack</h1>
<p>什么是webpack？这个webpack还真不是一两句话可以说清楚的。<br>
我们先看看官方的解释：<br>
At its core, webpack is a static module bundler for modern JavaScript applications.<br>
从本质上来讲，<code>webpack是一个现代的JavaScript应用的静态模块打包工具。</code></p>
<p>但是它是什么呢？用概念解释概念，还是不清晰。</p>
<p>我们从两个点来解释上面这句话：<code>模块 和 打包</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916170737157.png" alt="image-20200916170737157"></p>
<h2 id="前端模块化">前端模块化</h2>
<p>在前面学习中，我已经用了大量的篇幅解释了为什么前端需要模块化。而且我也提到了目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。<br>
<code>并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。</code><br>
<code>而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。</code></p>
<p>而且不仅仅是JavaScript文件，我们的CSS、图片、json文件等等在webpack中都可以被当做模块来使用（在后续我们会看到）。<br>
这就是webpack中模块化的概念。</p>
<h2 id="打包">打包</h2>
<p>理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了。<br>
<code>就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)。</code><br>
<code>并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。</code><br>
但是打包的操作似乎grunt/gulp也可以帮助我们完成，它们有什么不同呢？</p>
<h2 id="和grunt-gulp的对比">和grunt/gulp的对比</h2>
<p>grunt/gulp的核心是Task。我们可以配置一系列的task，并且定义task要处理的事务（例如ES6、ts转化，图片压缩，scss转成css）<br>
之后让grunt/gulp来依次执行这些task，而且让整个流程自动化。<br>
所以grunt/gulp也被称为前端自动化任务管理工具。<br>
我们来看一个gulp的task</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171020257.png" alt="image-20200916171020257"></p>
<p>下面的task就是将src下面的所有js文件转成ES5的语法。并且最终输出到dist文件夹中。<br>
<code>什么时候用grunt/gulp呢？</code><br>
<code>如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。只需要进行简单的合并、压缩，就使用grunt/gulp即可。</code></p>
<p>但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack了。<br>
所以，grunt/gulp和webpack有什么不同呢？</p>
<p><code>grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心。</code><br>
<code>webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能。</code></p>
<h2 id="webpack安装">webpack安装</h2>
<p>安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm<br>
查看自己的node版本：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171124190.png" alt="image-20200916171124190"></p>
<p>全局安装webpack(这里我先指定版本号3.6.0，因为vue cli2依赖该版本)</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171142276.png" alt="image-20200916171142276"></p>
<p>局部安装webpack（后续才需要）</p>
<p>–save-dev`是开发时依赖，项目打包后不需要继续使用的。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171149910.png" alt="image-20200916171149910"></p>
<p>为什么全局安装后，还需要局部安装呢？<br>
在终端直接执行webpack命令，使用的全局安装的webpack。当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack</p>
<h2 id="webpack准备工作">webpack准备工作</h2>
<p>我们创建如下文件和文件夹：<br>
文件和文件夹解析：<br>
<code>dist文件夹：</code>用于存放之后打包的文件<br>
<code>src文件夹：</code>用于存放我们写的源文件</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171440074.png" alt="image-20200916171440074"></p>
<p><code>main.js：</code>项目的入口文件。具体内容查看下面详情。<br>
<code>mathUtils.js：</code>定义了一些数学工具函数，可以在其他地方引用，并且使用。具体内容查看下面的详情。<br>
<code>index.html：</code>浏览器打开展示的首页html<br>
<code>package.json：</code>通过npm init生成的，npm包管理的文件（暂时没有用上，后面才会用上）<br>
<code>mathUtils.js</code>文件中的代码：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171447743.png" alt="image-20200916171447743"></p>
<p><code>main.js</code>文件中的代码：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171452474.png" alt="image-20200916171452474"></p>
<p>现在的js文件中使用了模块化的方式进行开发，他们可以直接使用吗？不可以。</p>
<p>因为如果直接在index.html引入这两个js文件，浏览器并不识别其中的模块化代码。</p>
<p>另外，在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理。<br>
我们应该怎么做呢？使用webpack工具，对多个js文件进行打包。<br>
我们知道，webpack就是一个模块化的打包工具，所以它支持我们代码中写模块化，可以对模块化的代码进行处理。（如何处理的，待会儿在原理中，我会讲解）<br>
另外，如果<code>在处理完所有模块之间的关系后，将多个js打包到一个js文件中，引入时就变得非常方便了</code>。<br>
OK，如何打包呢？使用webpack的指令即可</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171609338.png" alt="image-20200916171609338"></p>
<p>打包后会在dist文件下，生成一个bundle.js文件。文件内容有些复杂，这里暂时先不看，后续再进行分析。<br>
bundle.js文件，是webpack处理了项目直接文件依赖后生成的一个js文件，我们只需要将这个js文件在index.html中引入即可。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171655376.png" alt="image-20200916171655376"></p>
<h2 id="webpack配置">webpack配置</h2>
<p>我们考虑一下，如果每次使用webpack的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一种方法可以将这两个参数写到配置中，在运行时，直接读取呢？<br>
当然可以，就是<code>创建一个webpack.config.js文件</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171752360.png" alt="image-20200916171752360"></p>
<p>目前，我们使用的webpack是全局的webpack，如果我们想使用局部来打包呢？因为一个项目往往依赖特定的webpack版本，全局的版本可能很这个项目的webpack版本不一致，导出打包出现问题。<br>
所以通常一个项目，都有自己局部的webpack。</p>
<p>第一步，项目中需要安装自己局部的webpack</p>
<p>这里我们让局部安装webpack3.6.0</p>
<p><code>见webpack安装</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172013536.png" alt="image-20200916172013536"></p>
<p>Vue CLI3中已经升级到webpack4，但是它将配置文件隐藏了起来，所以查看起来不是很方便。</p>
<p>第二步，通过node_modules/.bin/webpack启动webpack打包</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172022013.png" alt="image-20200916172022013"></p>
<h3 id="package-json中定义启动">package.json中定义启动</h3>
<p>但是，每次执行都敲这么一长串有没有觉得不方便呢？OK，我们可以在package.json的scripts中定义自己的执行脚本。<br>
package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172152264.png" alt="image-20200916172152264"></p>
<p>首先，会寻找本地的node_modules/.bin路径中对应的命令。<br>
如果没有找到，会去全局的环境变量中寻找。<br>
如何执行我们的build指令呢？</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172142724.png" alt="image-20200916172142724"></p>
<h2 id="loader">loader</h2>
<p>loader是webpack中一个非常核心的概念。webpack用来做什么呢？<br>
在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。<br>
但是，在开发中我们<code>不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</code></p>
<p>对于webpack本身的能力来说，对于这些转化是不支持的。那怎么办呢？给webpack扩展对应的loader就可以啦。<br>
loader使用过程：<br>
<code>步骤一：通过npm安装需要使用的loader</code><br>
<code>步骤二：在webpack.config.js中的modules关键字下进行配置</code></p>
<p>大部分loader我们都可以在webpack的官网中找到，并且学习对应的用法。</p>
<h3 id="css-loader和style-loader">css-loader和style-loader</h3>
<p>项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。<br>
在src目录中，创建一个css文件，其中创建一个normal.css文件。<br>
我们也可以重新组织文件的目录结构，将零散的js文件放在一个js文件夹中。<br>
normal.css中的代码非常简单，就是将body设置为red<br>
但是，这个时候normal.css中的样式会生效吗？<br>
当然不会，因为我们压根就没有引用它。<br>
webpack也不可能找到它，因为我们只有一个入口，webpack会从入口开始查找其他依赖的文件。</p>
<p>在入口文件中引用：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172345560.png" alt="image-20200916172345560"></p>
<p>重新打包，会出现如下错误：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172415658.png" alt="image-20200916172415658"></p>
<p>这个错误告诉我们：加载normal.css文件必须有对应的loader。</p>
<p>在webpack的官方中，我们可以找到如下关于样式的loader使用方法：按照官方配置webpack.config.js文件</p>
<p>注意：配置中有一个style-loader，我们并不知道它是什么，所以可以暂时不进行配置。</p>
<p>重新打包项目：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172509773.png" alt="image-20200916172509773"></p>
<p>但是，运行index.html，你会发现样式并没有生效。</p>
<p>原因是css-loader只负责加载css文件，但是并不负责将css具体样式嵌入到文档中。这个时候，我们还需要一个style-loader帮助我们处理。</p>
<p>我们来安装style-loader</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172609734.png" alt="image-20200916172609734"></p>
<p>注意：<code>style-loader需要放在css-loader的前面。</code><br>
疑惑：不对吧？按照我们的逻辑，在处理css文件过程中，应该是css-loader先加载css文件，再由style-loader来进行进一步的处理，为什么会将style-loader放在前面呢？<br>
<code>答案：这次因为webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</code><br>
目前，webpack.config.js的配置如下：</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172619418.png" alt="image-20200916172619418" style="zoom:80%;">
<h3 id="less-loader">less-loader</h3>
<p>如果我们希望在项目中使用less、scss、stylus来写样式，webpack是否可以帮助我们处理呢？我们这里以less为例，其他也是一样的。我们还是先创建一个less文件，依然放在css文件夹中.</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172804658.png" alt="image-20200916172804658"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172810288.png" alt="image-20200916172810288"></p>
<p>继续在官方中查找，我们会找到less-loader相关的使用说明<br>
首先，还是需要安装对应的loader</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172847439.png" alt="image-20200916172847439"></p>
<p>注意：我们这里还安装了less，因为webpack会使用less对less文件进行编译</p>
<p>其次，修改对应的配置文件<br>
添加一个rules选项，用于处理.less文件</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172854832.png" alt="image-20200916172854832"></p>
<h3 id="url-loader和file-loader">url-loader和file-loader</h3>
<p>首先，我们在项目中加入两张图片：<br>
一张较小的图片test01.jpg(小于8kb)，一张较大的图片test02.jpeg(大于8kb)</p>
<p>待会儿我们会针对这两张图片进行不同的处理。我们先考虑在css样式中引用图片的情况，所以我更改了normal.css中的样式：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173038912.png" alt="image-20200916173038912"></p>
<p>如果我们现在直接打包，会出现如下问题：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173043885.png" alt="image-20200916173043885"></p>
<p>图片处理，我们使用url-loader来处理，依然先安装url-loader</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173136102.png" alt="image-20200916173136102"></p>
<p>修改webpack.config.js配置文件：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173139980.png" alt="image-20200916173139980"></p>
<p>再次打包，运行index.html，就会发现我们的背景图片选出了出来。<br>
而仔细观察，你会发现背景图是通过base64显示出来的<br>
OK，这也是limit属性的作用，当图片小于8kb时，对图片进行base64编码</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173148926.png" alt="image-20200916173148926"></p>
<p>那么问题来了，如果大于8kb呢？我们将background的图片改成test02.jpg<br>
这次因为大于8kb的图片，会通过file-loader进行处理，但是我们的项目中并没有file-loader</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173210446.png" alt="image-20200916173210446"></p>
<p>所以，我们需要安装file-loader</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173215710.png" alt="image-20200916173215710"></p>
<p>再次打包，就会发现dist文件夹下多了一个图片文件</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173220793.png" alt="image-20200916173220793"></p>
<h4 id="图片文件处理-–-修改文件名称">图片文件处理 – 修改文件名称</h4>
<p>我们发现webpack自动帮助我们生成一个非常长的名字。这是一个32位hash值，目的是防止名字重复<br>
但是，真实开发中，我们可能对打包的图片名字有一定的要求<br>
比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复<br>
所以，我们可以在options中添加上如下选项：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173337012.png" alt="image-20200916173337012"></p>
<p><code>img：文件要打包到的文件夹</code><br>
<code>name：获取图片原来的名字，放在该位置</code><br>
<code>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位</code><br>
<code>ext：使用图片原来的扩展名</code></p>
<p>但是，我们发现图片并没有显示出来，这是因为图片使用的路径不正确<br>
默认情况下，webpack会将生成的路径直接返回给使用者<br>
但是，我们整个程序是打包在dist文件夹下的，所以这里我们需要在路径下再添加一个dist/</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173349429.png" alt="image-20200916173349429"></p>
<h3 id="babel-loader">babel-loader</h3>
<h4 id="ES6语法处理">ES6语法处理</h4>
<p>如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。<br>
在前面我们说过，如果希望将ES6的语法转成ES5，那么就需要使用babel。<br>
而在webpack中，我们直接使用babel对应的loader就可以了。</p>
<p><code>npm install --save-dev babel-loader@7 babel-core babel-preset-es2015</code></p>
<p>配置webpack.config.js文件</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173541318.png" alt="image-20200916173541318"></p>
<p>重新打包，查看bundle.js文件，发现其中的内容变成了ES5的语法</p>
<h3 id="配置vue">配置vue</h3>
<p>后续项目中，我们会使用Vuejs进行开发，而且会以特殊的文件来组织vue的组件。所以，下面我们来学习一下如何在我们的webpack环境中集成Vuejs<br>
现在，我们希望在项目中使用Vuejs，那么必然需要对其有依赖，所以需要先进行安装<br>
注：因为我们后续是在实际项目中也会使用vue的，所以并不是开发时依赖</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173644714.png" alt="image-20200916173644714"></p>
<p>那么，接下来就可以按照我们之前学习的方式来使用Vue了</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173649716.png" alt="image-20200916173649716"></p>
<p>修改完成后，重新打包，运行程序：<br>
打包过程没有任何错误(因为只是多打包了一个vue的js文件而已)<br>
但是运行程序，没有出现想要的效果，而且浏览器中有报错</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173711182.png" alt="image-20200916173711182"></p>
<p>这个错误说的是我们使用的是runtime-only版本的Vue，什么意思呢？<br>
这里我只说解决方案<code>：Vue不同版本构建，后续我具体讲解runtime-only和runtime-compiler的区别。</code></p>
<p>所以我们修改webpack的配置，添加如下内容即可</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173746318.png" alt="image-20200916173746318"></p>
<h2 id="el和template区别">el和template区别</h2>
<p>正常运行之后，我们来考虑另外一个问题：<br>
<code>如果我们希望将data中的数据显示在界面中，就必须是修改index.html</code><br>
<code>如果我们后面自定义了组件，也必须修改index.html来使用组件</code></p>
<p>但是html模板在之后的开发中，我并不希望手动的来频繁修改，是否可以做到呢？<br>
定义template属性：<br>
在前面的Vue实例中，我们定义了el属性，用于和index.html中的#app进行绑定，让Vue实例之后可以管理它其中的内容<br>
这里，我们可以将div元素中的内容删掉，只保留一个基本的id为div的元素<br>
但是如果我依然希望在其中显示的内容，应该怎么处理呢？<br>
我们可以再定义一个template属性，代码如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181202401.png" alt="image-20200916181202401"></p>
<p>重新打包，运行程序，显示一样的结果和HTML代码结构<br>
那么，el和template模板的关系是什么呢？</p>
<p>在我们之前的学习中，<code>我们知道el用于指定Vue要管理的DOM，可以帮助解析其中的指令、事件监听等等。</code><br>
<code>而如果Vue实例中同时指定了template，那么template模板的内容会替换掉挂载的对应el的模板。</code></p>
<p>这样做有什么好处呢？</p>
<p><code>这样做之后我们就不需要在以后的开发中再次操作index.html，只需要在template中写入对应的标签即可</code><br>
<code>但是，书写template模块非常麻烦怎么办呢？</code><br>
没有关系，稍后我们会将template模板中的内容进行抽离。<br>
会分成三部分书写：template、script、style，结构变得非常清晰。</p>
<h2 id="vue组件化开发的引入">vue组件化开发的引入</h2>
<p>在学习组件化开发的时候，我说过以后的Vue开发过程中，我们都会采用组件化开发的思想。<br>
那么，在当前项目中，如果我也想采用组件化的形式进行开发，应该怎么做呢？<br>
查看下面的代码：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181334306.png" alt="image-20200916181334306"></p>
<p>当然，我们也可以将下面的代码抽取到一个js文件中，并且导出。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181340309.png" alt="image-20200916181340309"></p>
<p>但是一个组件以一个js对象的形式进行组织和使用的时候是非常不方便的。一方面编写template模块非常的麻烦<br>
另外一方面如果有样式的话，我们写在哪里比较合适呢？现在，我们以一种全新的方式来组织一个vue的组件<br>
但是，这个时候这个文件可以被正确的加载吗？<br>
必然不可以，<code>这种特殊的文件以及特殊的格式，必须有人帮助我们处理。</code><br>
<code>谁来处理呢？vue-loader以及vue-template-compiler。</code></p>
<p>安装vue-loader和vue-template-compiler</p>
<p><code>npm install vue-loader vue-template-compiler --save-dev</code></p>
<p>修改webpack.config.js的配置文件：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181429212.png" alt="image-20200916181429212"></p>
<h2 id="plugin">plugin</h2>
<h3 id="plugin是什么？">plugin是什么？</h3>
<p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。<br>
webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</p>
<h3 id="loader和plugin区别">loader和plugin区别</h3>
<p>loader主要用于转换某些类型的模块，它是一个转换器。<br>
plugin是插件，它是对webpack本身的扩展，是一个扩展器。</p>
<h3 id="plugin的使用过程：">plugin的使用过程：</h3>
<p>步骤一：通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)<br>
步骤二：在webpack.config.js中的plugins中配置插件。</p>
<p>下面，我们就来看看可以通过哪些插件对现有的webpack打包过程进行扩容，让我们的webpack变得更加好用。</p>
<h3 id="版权声明插件">版权声明插件</h3>
<p>我们先来使用一个最简单的插件，为打包的文件添加版权声明<br>
该插件名字叫BannerPlugin，属于webpack自带的插件。<br>
按照下面的方式来修改webpack.config.js的文件：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181814895.png" alt="image-20200916181814895"></p>
<p>重新打包程序：查看bundle.js文件的头部，看到如下信息</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181821618.png" alt="image-20200916181821618"></p>
<h3 id="打包html插件">打包html插件</h3>
<p>目前，<code>我们的index.html文件是存放在项目的根目录下的。我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。</code></p>
<p>所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用<code>HtmlWebpackPlugin插件</code><br>
HtmlWebpackPlugin插件可以为我们做这些事情：<br>
自动生成一个index.html文件(可以指定模板来生成)<br>
将打包的js文件，自动通过script标签插入到body中<br>
安装HtmlWebpackPlugin插件</p>
<p><code>npm install html-webpack-plugin --save-dev</code></p>
<p>使用插件，修改webpack.config.js文件中plugins部分的内容如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181959390.png" alt="image-20200916181959390"></p>
<p>这里的template表示根据什么模板来生成index.html<br>
另外，我们需要删除之前在output中添加的publicPath属性<br>
否则插入的script标签中的src可能会有问题</p>
<h3 id="js压缩插件">js压缩插件</h3>
<p>在项目发布之前，我们必然需要对js等文件进行压缩处理<br>
这里，我们就对打包的js文件进行压缩<br>
我们使用一个第三方的插件<code>uglifyjs-webpack-plugin</code>，并且版本号指定1.1.1，和CLI2保持一致</p>
<p><code>npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</code></p>
<p>修改webpack.config.js文件，使用插件：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916182106424.png" alt="image-20200916182106424"></p>
<p>查看打包后的bunlde.js文件，是已经被压缩过了。</p>
<h2 id="搭建本地服务器">搭建本地服务器</h2>
<p>webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，<code>可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。</code><br>
不过它是一个单独的模块，在webpack中使用之前需要先安装它</p>
<p>devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：<br>
<code>contentBase：</code>为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist<br>
<code>port：</code>端口号<br>
<code>inline：</code>页面实时刷新<br>
<code>historyApiFallback：</code>在SPA页面中，依赖HTML5的history模式<br>
webpack.config.js文件配置修改如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916182215096.png" alt="image-20200916182215096"></p>
<p>我们可以再配置另外一个scripts：–open参数表示直接打开浏览器</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
