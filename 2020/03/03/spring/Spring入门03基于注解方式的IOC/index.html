<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Title -->
<title>Spring入门03基于注解方式的IOC - Hexo</title>

<!-- Icon -->
<link rel="icon" href="/favicon.ico">

<!-- Fonts -->
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" as="style" onload="this.onload=null, this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript>


    <!-- KaTeX -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" as="style" onload="this.onload=null, this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"></noscript>


<!-- Style -->

<link rel="stylesheet" href="/styles/main.css">

<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-pure@1.0.1/dist/main.css"> -->



    <meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>
    <body>
        <div class="main gt-bg-theme-color-first">
            <div class="main-content">
                <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/favicon.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            
        </div>
    </div>
    <button aria-label="Navbar Toggler" class="navbar-toggler" type="button" id="changeNavbar">
        <i class="gt-c-content-color-first" style="font-size: 18px;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" height="18px" fill="currentColor">
                <path d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" />
            </svg>
        </i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center; ">
            
                <div class="nav-item">
                    <a href="/" class="menu gt-a-link" target="_self">首页</a>
                </div>
            
                <div class="nav-item">
                    <a href="/archives/" class="menu gt-a-link" target="_self">归档</a>
                </div>
            
                <div class="nav-item">
                    <a href="/tags/" class="menu gt-a-link" target="_self">标签</a>
                </div>
            
                <div class="nav-item">
                    <a href="/friends/" class="menu gt-a-link" target="_self">友链</a>
                </div>
            
        </div>
    </div>
</nav>

<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function() {
        let element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else { 
            element.style.display = 'none';
        }
    }
</script>
                <div class="post-container">
    <div class="post-detail gt-bg-theme-color-second gt-c-content-color-first">
        <article class="gt-post-content">
            <h1 class="post-title">Spring入门03基于注解方式的IOC</h1>
            <div class="post-info">
                <time class="post-time gt-c-content-color-first">
                    · 2020-03-03 ·</time>
                
                    
                        <a href="/tags/JavaWeb/" class="post-tag">
                            #JavaWeb</a>
                    
                        <a href="/tags/Spring%E6%A1%86%E6%9E%B6/" class="post-tag">
                            #Spring框架</a>
                    
                
            </div>
            <hr>
            <div class="post-content gt-c-content-color-first">
                <hr>
<p><img src="https://cdn.pixabay.com/photo/2014/09/07/22/17/forest-438432_1280.jpg" alt=""></p>
<hr>
<h1>Spring入门03基于注解方式的IOC</h1>
<h2 id="1-配置环境">1 配置环境</h2>
<p>在 bean.xml 中导入约束</p>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span>
<span class="hljs-comment">注意：基于注解整合时，导入约束时需要多导入一个 context 名称空间下的约束。</span>
<span class="hljs-comment">--&gt;</span>
<span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span>
<span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context</span></span>
<span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span>
    
   <span class="hljs-comment">&lt;!-- 告知 spring 创建容器时要扫描的包 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.itheima"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre>
<h2 id="2-常用注解">2 常用注解</h2>
<h3 id="2-1-用于注入对象的">2.1 用于注入对象的</h3>
<pre><code class="hljs xml">&lt;！--相当于--&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">""</span>&gt;</span></code></pre>
<h4 id="Component-：">@Component  ：</h4>
<p>作用：把资源让 spring 来管理。相当于在 xml 中配置一个 bean。<br>
属性：value：指定 bean 的 id。<code>如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。</code></p>
<p>如果注解中有且只有一个属性要赋值时，且名称是 value， value 在赋值是可以不写。</p>
<p><code>下面三个注解都是针对 @Component 的衍生注解</code>，作用及属性都是一模一样的。只不过是提供了更加明确的语义化。</p>
<h4 id="Controller-：一般用于表现层的注解">@Controller ：一般用于表现层的注解</h4>
<h4 id="Service-：一般用于业务层的注解。">@Service ：一般用于业务层的注解。</h4>
<h4 id="Repository：-一般用于持久层的注解。">@Repository：  一般用于持久层的注解。</h4>
<h3 id="2-2-用于注入数据的">2.2 用于注入数据的</h3>
<pre><code class="hljs xml"><span class="hljs-comment">&lt;!--相当于--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">""</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span></code></pre>
<h4 id="Autowired-：">@Autowired  ：</h4>
<p>自动按照类型注入。当使用注解注入属性时， <code>set 方法可以省略</code>。它只能注入其他 bean 类型。当有多个<br>
类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到<br>
就报错</p>
<pre><code class="hljs java"><span class="hljs-meta">@AutoWired(required=false)</span><span class="hljs-comment">//这样指定如果找不到组件，也不会报错，默认为 null</span></code></pre>
<p>作用位置：构造器，参数，方法，属性</p>
<pre><code class="hljs java"><span class="hljs-comment">//方法上</span>
<span class="hljs-comment">//Spring 创建当前对象，就会调用该方法，完成赋值</span>
<span class="hljs-comment">//方法使用的参数，自定义类型的值从 ioc 容器中获取</span>
<span class="hljs-meta">@Autowired</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCar</span><span class="hljs-params">(Car car)</span></span>{
    <span class="hljs-keyword">this</span>.car=car;
}

<span class="hljs-comment">//构造器上</span>
<span class="hljs-comment">//默认情况下，在ioc的容器会自动调用无参构造方法创建对象，在进行初始化赋值等操作</span>
<span class="hljs-comment">//构造器使用的参数，自定义类型的值从 ioc 容器中获取</span>
<span class="hljs-comment">//如果组件只有一个有参构造器，那么 @AutoWired 可以省略，还是可以自动注入</span>
<span class="hljs-meta">@AutoWired</span>
<span class="hljs-keyword">public</span> Boss（Car car）{
    <span class="hljs-keyword">this</span>.car=car;
}

<span class="hljs-comment">//参数上</span>
<span class="hljs-keyword">public</span> Boss（<span class="hljs-meta">@AutoWired</span> Car car）{
    <span class="hljs-keyword">this</span>.car=car;
}


<span class="hljs-comment">//@Bean标注的方法创建对象的时候，方法参数默认从容器中获取,</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Color <span class="hljs-title">color</span><span class="hljs-params">(Car car)</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Color();
}</code></pre>
<h4 id="Qualifier-：">@Qualifier  ：</h4>
<p>作用：在自动按照类型注入的基础之上，明确指定按照 Bean 的 id 注入。它在给字段注入时不能独立使用，必须和<code>@Autowired </code>一起使用</p>
<p>但是给方法参数注入时，可以独立使用。<br>
属性：value：指定 bean 的 id。</p>
<h4 id="Resource">@Resource  :</h4>
<p>作用：直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。属于java 规范的注解，不是spring规范的注解，所以不会支持spring的注解。<br>
属性：name：指定 bean 的 id。</p>
<h4 id="Value">@Value  :</h4>
<p>作用：注入基本数据类型和 String 类型数据的<br>
属性：value：用于指定值 ，可以作用于参数上，可以使用${}取出配置文件中的值</p>
<pre><code class="hljs java"><span class="hljs-meta">@Bean(value = "dataSource")</span><span class="hljs-comment">// &lt;bean id="dataSource"</span>
    <span class="hljs-meta">@Lazy(false)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">newDataSource</span><span class="hljs-params">(<span class="hljs-meta">@Value("${jdbcDriver}")</span> String driverClass,<span class="hljs-meta">@Value("${jdbcUrl}")</span> String jdbcUrl,</span></span>
<span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Value("${jdbcUser}")</span> String username, <span class="hljs-meta">@Value("${jdbcPassword}")</span> String password)</span> </span>{

        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();
        dataSource.setUrl(jdbcUrl);
        dataSource.setDriverClassName(driverClass);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        <span class="hljs-comment">// 配置其他东西自行使用set方法设置</span>
        <span class="hljs-keyword">return</span> dataSource;
    }</code></pre>
<h4 id="Inject">@Inject</h4>
<p>使用前需要导入依赖 javax.inject，和 <code>@AutoWired</code> 的功能一样，但没有其他属性。属于java 规范的注解，不是spring规范的注解，所以不会支持spring的注解。</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependncy</span>&gt;</span>
</code></pre>
<h4 id="使用底层组件的方法">使用底层组件的方法</h4>
<p>自定义的组件想要使用Spring底层的一些组件（ApplicationContext，BeanFactory,…），自定义组件需实现<code>XXXAware</code>，创建对象时，会调用接口的方法注入相关的组件，（<code>XXXAware</code>的功能是通过 <code>XXXProcessor</code> 的后置处理器来返回我们需要的组件）</p>
<img src="https://img.sky123.top/spring/image-20200619222247286.png" alt="image-20200619222247286" style="zoom: 80%;">
<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hnust.domain;
<span class="hljs-keyword">import</span> org.springframework.beans.BeansException;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanNameAware;
<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;
<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContextAware;
<span class="hljs-keyword">import</span> org.springframework.context.EmbeddedValueResolverAware;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> org.springframework.util.StringValueResolver;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span>, <span class="hljs-title">BeanNameAware</span>, <span class="hljs-title">EmbeddedValueResolverAware</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String name)</span> </span>{
        System.out.println(<span class="hljs-string">"当前bean的名字："</span>+name);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        <span class="hljs-comment">//获取ioc容器</span>
        System.out.println(applicationContext);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver resolver)</span> </span>{
        <span class="hljs-comment">//用于解析字符串的组件</span>
        String str=resolver.resolveStringValue(<span class="hljs-string">"你好${os.name}"</span>);
        System.out.println(str);
    }
}java
</code></pre>
<h3 id="2-3-用于改变作用范围的：">2.3 用于改变作用范围的：</h3>
<pre><code class="hljs xml">&lt;！--相当于--&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">""</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">""</span>&gt;</span></code></pre>
<h4 id="Scope">@Scope</h4>
<p>作用：指定 bean 的作用范围。<br>
属性：value：指定范围的值。<br>
取值：<code> singleton</code> <code> prototype</code> <code>request </code> <code>session</code> <code>globalsession </code></p>
<h4 id="Lazy">@Lazy</h4>
<p>作用：容器启动时不创建对象，第一次使用（获取）Bean创建对象，并初始化。注意要和注入组件的注解一起用。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Bean("person")</span>
<span class="hljs-meta">@Lazy</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Persion <span class="hljs-title">getPersion</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();
}</code></pre>
<h3 id="2-4-和生命周期相关的">2.4 和生命周期相关的</h3>
<p>bean的生命周期：创建------初始化------销毁</p>
<ul>
<li>创建：可以使用构造方法
<ul>
<li>容器创建时单例对象被创建</li>
<li>使用（获取）时多例对象被创建</li>
</ul>
</li>
<li>初始化：对象创建完成，并赋值好，调用初始化方法</li>
<li>销毁：
<ul>
<li>容器关闭时，销毁单实例</li>
<li>容器关闭时，不会管理多实例，即不会调用销毁方法</li>
</ul>
</li>
</ul>
<h4 id="使用注解管理生命周期的几种方法：">使用注解管理生命周期的几种方法：</h4>
<ol>
<li>
<p>通过 @Bean 的<code>init-method</code>和 <code>destroy-method</code> 属性（在对象的方法中选择）</p>
</li>
<li>
<p>通过让 Bean 实现  <code>InitializingBean</code>(定义初始化逻辑)  和  <code>DisposableBean</code> (定义销毁逻辑)</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> domain;

<span class="hljs-keyword">import</span> org.springframework.beans.factory.DisposableBean;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.InitializingBean;

<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">DisposableBean</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        System.out.println(<span class="hljs-string">"销毁方法"</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        System.out.println(<span class="hljs-string">"初始化方法"</span>);
    }
}
</code></pre>
</li>
<li>
<p>使用以下的注解</p>
</li>
</ol>
<pre><code class="hljs xml">&lt;！--相当于--&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">""</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">""</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">""</span>&gt;</span></code></pre>
<h4 id="PostConstruct">@PostConstruct</h4>
<p>作用：用于指定初始化方法。直接标注在方法上，在对象创建并赋值之后调用</p>
<h4 id="PreDestroy">@PreDestroy</h4>
<p>作用：用于指定销毁方法。  直接标注在方法上，在对象销毁之前调用</p>
<ol start="4">
<li>
<p>使用<code>BeanPostProcessor</code>后置处理器（该处理器可用于识别注入数据的注解）</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> config;

<span class="hljs-keyword">import</span> org.springframework.beans.BeansException;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-meta">@Component</span><span class="hljs-comment">//将后置处理器加入容器中，所有的组件初始化前后都会经过它</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanPostProcessor</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * </span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bean 创建的实例</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName 创建的实例的名字</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 直接返回 bean</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> BeansException</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        System.out.println(<span class="hljs-string">"创建完成之后，初始化之前调用"</span>);
        <span class="hljs-keyword">return</span> bean;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>{
        System.out.println(<span class="hljs-string">"初始化之后调用，销毁之前"</span>);
        <span class="hljs-keyword">return</span> bean;
    }
}
</code></pre>
</li>
</ol>
<h3 id="2-5-和配置相关">2.5 和配置相关</h3>
<h4 id="Configuration">@Configuration</h4>
<p>作用：用于指定当前类是一个 Spring 配置类， 当创建容器时会从该类上加载注解。</p>
<p>属性：value:用于指定配置类的字节码</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* spring 的配置类，相当于 bean.xml 文件</span>
<span class="hljs-comment">* <span class="hljs-doctag">@author</span> </span>
<span class="hljs-comment">* <span class="hljs-doctag">@Company</span> </span>
<span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span> </span>{
}

<span class="hljs-comment">//注意：我们已经把配置文件用类来代替了， 但是如何配置创建容器时要扫描的包呢？请看下一个注解。</span></code></pre>
<h4 id="ComponentScan">@ComponentScan</h4>
<p>作用：用于指定 spring 在初始化容器时要扫描注解的包。 作用和在 spring 的 xml 配置文件中的：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.itheima"</span>/&gt;</span></code></pre>
<p>是一样的。<br>
属性：basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。</p>
<p><code>excludeFilters</code>：按照哪些规则（type属性）排除哪些组件（classes属性）</p>
<p><code>includeFilters</code>：扫描的时候只要哪些组件，注意加入 （ useDefaultFilters = false ）</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* spring 的配置类，相当于 bean.xml 文件</span>
<span class="hljs-comment">* <span class="hljs-doctag">@author</span> 黑马程序员</span>
<span class="hljs-comment">* <span class="hljs-doctag">@Company</span> http://www.ithiema.com</span>
<span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = {"dao","service"},excludeFilters = {</span>
<span class="hljs-meta">        @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {Service.class}),//指定注解</span>
<span class="hljs-meta">    @ComponentScan.Filter(type= FilterType.ASIGNABLE_TYPE,classes = {UserServiceImpl.class})，//指定类型</span>
<span class="hljs-meta">    @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {MyFilter.class})  //指定自定义类型  </span>
<span class="hljs-meta">})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span> </span>{
}
<span class="hljs-comment">//注意：我们已经配置好了要扫描的包，但是数据源和 JdbcTemplate 对象如何从配置文件中移除呢？请看下一个注解。</span></code></pre>
<p>自定义类型过滤类，根据  <code>excludeFilters </code>（true为排除，false为包含），<code>includeFilters </code>反之</p>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> config;

<span class="hljs-keyword">import</span> org.springframework.core.io.Resource;
<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotationMetadata;
<span class="hljs-keyword">import</span> org.springframework.core.type.ClassMetadata;
<span class="hljs-keyword">import</span> org.springframework.core.type.classreading.MetadataReader;
<span class="hljs-keyword">import</span> org.springframework.core.type.classreading.MetadataReaderFactory;
<span class="hljs-keyword">import</span> org.springframework.core.type.filter.TypeFilter;

<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">TypeFilter</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metadataReader  读取当前正在扫描的类的信息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metadataReaderFactory 可以获取到其他类的信息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span><span class="hljs-params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        <span class="hljs-comment">//获取当前类注解的信息</span>
        AnnotationMetadata annotationMetadata=metadataReader.getAnnotationMetadata();
        <span class="hljs-comment">//获取当前正在扫描的类信息</span>
        ClassMetadata classMetadata=metadataReader.getClassMetadata();
        <span class="hljs-comment">//获取当前类资源信息（类路径）</span>
        Resource resource=metadataReader.getResource();
        
        System.out.println(classMetadata.getClassName());
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
}
</code></pre>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = {"dao","service"},includeFilters = {</span>
<span class="hljs-meta">        @ComponentScan.Filter(type= FilterType.ANNOTATION,classes = {Service.class})</span>
<span class="hljs-meta">},useDefaultFilters=false)</span></code></pre>
<h4 id="Bean">@Bean</h4>
<p>作用：该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。默认方法名是其 id</p>
<p>属性：name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 连接数据库的配置类</span>
<span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcConfig</span> </span>{
    
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个数据源，并存入 spring 容器中</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Bean(name="dataSource")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">try</span> {
ComboPooledDataSource ds = <span class="hljs-keyword">new</span> ComboPooledDataSource();
ds.setUser(<span class="hljs-string">"root"</span>);
ds.setPassword(<span class="hljs-string">"1234"</span>);
ds.setDriverClass(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);
ds.setJdbcUrl(<span class="hljs-string">"jdbc:mysql:///spring_day02"</span>);
<span class="hljs-keyword">return</span> ds;
} <span class="hljs-keyword">catch</span> (Exception e) {
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
}
}
    
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个 DBAssit，并且也存入 spring 容器中</span>
<span class="hljs-comment">* <span class="hljs-doctag">@param</span> dataSource</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Bean(name="dbAssit")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> DBAssit <span class="hljs-title">createDBAssit</span><span class="hljs-params">(DataSource dataSource)</span> </span>{
<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DBAssit(dataSource);
}
}
<span class="hljs-comment">//注意:</span>
<span class="hljs-comment">/*我们已经把数据源和 DBAssit 从配置文件中移除了，此时可以删除 bean.xml 了。</span>
<span class="hljs-comment">但是由于没有了配置文件，创建数据源的配置又都写死在类中了。*/</span></code></pre>
<h4 id="Conditional">@Conditional</h4>
<p>作用：根据条件决定是否加载注解的组件进入容器，注意要和注入组件的注解一起用。放在类上，表示该类所有注册bean的方法都会有该条件。</p>
<p>属性：判断条件（类实现了 <code>Conditional</code>接口）</p>
<pre><code class="hljs java"><span class="hljs-meta">@Bean</span>
<span class="hljs-meta">@Conditional({MyCondition.class})</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">now</span><span class="hljs-params">()</span></span>{
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Date();
   }</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> config;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.BeanFactory;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Condition;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.ConditionContext;
<span class="hljs-keyword">import</span> org.springframework.core.env.Environment;
<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 判断条件能使用的上下文环境</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metadata 注释信息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true则加载，false则不加载</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>{
        <span class="hljs-comment">//获取Ioc使用的 BeanFactory</span>
        BeanFactory beanFactory=context.getBeanFactory();
        <span class="hljs-comment">//获取类加载器</span>
        ClassLoader classLoader = context.getClassLoader();
        <span class="hljs-comment">//获取当前环境信息</span>
        Environment environment = context.getEnvironment();
        <span class="hljs-comment">//获取到 bean 定义的注册类</span>
        BeanDefinitionRegistry registry = context.getRegistry();

        String property = environment.getProperty(<span class="hljs-string">"os.name"</span>);
        System.out.println(property);
        <span class="hljs-keyword">assert</span> property != <span class="hljs-keyword">null</span>;
        <span class="hljs-comment">//return property.contains("Windows");//根据环境来判断</span>
        <span class="hljs-keyword">return</span> registry.containsBeanDefinition(<span class="hljs-string">"accountDaoImpl"</span>);<span class="hljs-comment">//根据是否包含某个id的组件来判断</span>
    }
}
</code></pre>
<h4 id="PropertySource">@PropertySource</h4>
<p>作用：用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到</p>
<p>properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。</p>
<p>属性：value[]：用于指定多个 properties 文件位置。如果是在类路径下，需要写上 classpath:</p>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* 连接数据库的配置类</span>
<span class="hljs-comment">* <span class="hljs-doctag">@author</span> 黑马程序员</span>
<span class="hljs-comment">* <span class="hljs-doctag">@Company</span> http://www.ithiema.com</span>
<span class="hljs-comment">* <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@PropertySource("classpath:jdbc.properties")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcConfig</span> </span>{
<span class="hljs-meta">@Value("${jdbc.driver}")</span>
<span class="hljs-keyword">private</span> String driver;
<span class="hljs-meta">@Value("${jdbc.url}")</span>
<span class="hljs-keyword">private</span> String url;
<span class="hljs-meta">@Value("${jdbc.username}")</span>
<span class="hljs-keyword">private</span> String username;
<span class="hljs-meta">@Value("${jdbc.password}")</span>
<span class="hljs-keyword">private</span> String password;
<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 创建一个数据源，并存入 spring 容器中</span>
<span class="hljs-comment">* <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">*/</span>
<span class="hljs-meta">@Bean(name="dataSource")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span> </span>{
<span class="hljs-keyword">try</span> {
ComboPooledDataSource ds = <span class="hljs-keyword">new</span> ComboPooledDataSource();
ds.setDriverClass(driver);
ds.setJdbcUrl(url);
ds.setUser(username);
ds.setPassword(password);
<span class="hljs-keyword">return</span> ds;
} <span class="hljs-keyword">catch</span> (Exception e) {
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
}
}
}</code></pre>
<p>配置文件中的值默认加到了环境中</p>
<pre><code class="hljs java">ConfigurableEnvironment environment=(ConfigurableEnvironment) ac.getEnvironment();
String property=environment.getProperty(<span class="hljs-string">"jdbc.url"</span>);</code></pre>
<h4 id="Import">@Import</h4>
<p>作用：用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。 当然，写上也没问<br>
题。<br>
属性：value[]：用于指定其他配置类的字节码。</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ComponentScan(basePackages = "com.itheima.spring")</span>
<span class="hljs-meta">@Import({ JdbcConfig.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfiguration</span> </span>{
}


<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@PropertySource("classpath:jdbc.properties")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcConfig</span></span>{
}</code></pre>
<p>除了直接指定类的字节码外，也可以配置导入类（实现<code> ImportSelector</code>接口）来导入</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import({MyImportSelector.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>{
}</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> config;

<span class="hljs-keyword">import</span> org.springframework.context.annotation.ImportSelector;
<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotationMetadata;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * </span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> importingClassMetadata 当前标注 <span class="hljs-doctag">@Import</span> 注解的类的所有信息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 就是要导入到容器容器中的全类名，可以返回空数组，但不要返回null</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]{<span class="hljs-string">"com.hnust.XXXX"</span>};
<span class="hljs-comment">//        return new String[0];</span>
    }
}
</code></pre>
<p>配置注册类（实现<code>ImportBeanDefinitionRegistrar</code> 接口）</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@Import({MyImportBeanRegistrer.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>{
}</code></pre>
<pre><code class="hljs java"><span class="hljs-keyword">package</span> config;

<span class="hljs-keyword">import</span> dao.impl.AccountDaoImpl;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.support.RootBeanDefinition;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.ImportBeanDefinitionRegistrar;
<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotationMetadata;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportBeanRegistrer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> importingClassMetadata 当前类的注解信息</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> registry BeanDefinitionRegistry 注册类，可以用于组件的注册，手动的注册组件</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>{
        <span class="hljs-comment">//如果容器中没有该组件，就手动注册该组件    </span>
        <span class="hljs-keyword">if</span>(!registry.containsBeanDefinition(<span class="hljs-string">"now"</span>)){
            <span class="hljs-comment">//指定 Bean 的类型</span>
                RootBeanDefinition rootBeanDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition(AccountDaoImpl.class)
                    <span class="hljs-comment">//注册一个Bean</span>
                registry.registerBeanDefinition(<span class="hljs-string">"now"</span>,rootBeanDefinition);
            }
    }
}
</code></pre>
<h4 id="Primary">@Primary</h4>
<p>和注入对象的注解一起用，用该注解的组件，其他组件要用到该类型的组件时，会优先使用它，但注意优先级比 @Qualifier 低。</p>
<h4 id="Profile">@Profile</h4>
<p>作用：指定组件在哪个环境下才能注册到容器中，加了环境标识的bean ，只有环境被激活的时候才会加载到容器中，没有标注  @Profile 的组件在任何环境下都能加载。</p>
<p>Profile：Spring 为我们提供的可以根据当前环境（开发环境，测试环境，生产环境），动态的激活和切换一系列组件的功能</p>
<p>作用位置：@Bean方法上，类上</p>
<p>环境的激活：</p>
<ol>
<li>
<p><code>-Dspring.profiles.active=test,dev,pro</code>（虚拟机参数配置,可以配置多个）</p>
</li>
<li>
<p>代码实现：注意此时舍弃原来的有参构造创建容器的方法</p>
<pre><code class="hljs java">AnnotationConfigApplicationContext acac=<span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();
acac.getEnvironment().setActiveProfiles(<span class="hljs-string">"test"</span>,<span class="hljs-string">"dev"</span>);
acac.register(ApplicationContext.class);
acac.refresh();</code></pre>
</li>
</ol>
<pre><code class="hljs java"><span class="hljs-meta">@Profile("test")</span>
<span class="hljs-meta">@Configuration</span><span class="hljs-comment">//只有指定环境激活时，整个配置类才能生效</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> class <span class="hljs-title">SqlConfig</span><span class="hljs-params">()</span></span>{
   
    <span class="hljs-meta">@Profile("test")</span>
    <span class="hljs-meta">@Bean("testDataSource")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">XXXtest</span><span class="hljs-params">()</span></span>{
        ........
        <span class="hljs-keyword">return</span> dataSource;
    }

    <span class="hljs-meta">@Profile("dev")</span>
    <span class="hljs-meta">@Bean("developDataSource")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">XXXdevelop</span><span class="hljs-params">()</span></span>{
        ........
        <span class="hljs-keyword">return</span> dataSource;
    }

    <span class="hljs-meta">@Profile("pro")</span>
    <span class="hljs-meta">@Bean("productDataSource")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">XXXproduct</span><span class="hljs-params">()</span></span>{
        ........
        <span class="hljs-keyword">return</span> dataSource;
    }
}</code></pre>
<h3 id="2-6-使用注解给容器中注册组件的几种方法：">2.6 使用注解给容器中注册组件的几种方法：</h3>
<ol>
<li>
<p>包扫描+组件注解（<code>@Controller/@Service/@Respority/@Component</code>）</p>
</li>
<li>
<p>@Bean 导入第三方包里面的组件</p>
</li>
<li>
<p>@Import 快速给容器中导入组件：</p>
<ol>
<li>@Import（要导入的组件.class）: id 默认是全类名</li>
<li>importSelector：导入需要的组件的全类名</li>
<li>ImportBeanDefinitionRegistrar：手动注册组件</li>
</ol>
</li>
<li>
<p>使用 FactoryBean 对象：</p>
</li>
<li>
<pre><code class="language-java">@Bean
    public PersonFactoryBean personFactoryBean(){
        return new PersonFactoryBean();
    }
<pre><code class="hljs java">
```java
<span class="hljs-keyword">package</span> config;

<span class="hljs-keyword">import</span> domain.Person;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.FactoryBean;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Person</span>&gt; </span>{
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回的对象是容器中注册的组件</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();
    }

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回组件的类型</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Class&lt;Person&gt; <span class="hljs-title">getObjectType</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Person.class;
    }

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     *</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否为单例</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}
</code></pre>

<pre><code class="hljs java">        Object bean1=ac2.getBean(<span class="hljs-string">"personFactoryBean"</span>);
        Object bean2=ac2.getBean(<span class="hljs-string">"&amp;personFactoryBean"</span>);
        System.out.println(bean1);
        System.out.println(bean2);
<span class="hljs-comment">//获取的时候直接用 id 是获取到组件对象</span>
<span class="hljs-comment">// 用 &amp;+id 是获取到工厂对象</span></code></pre>


</code></pre>
</li>
</ol>
<p>获取容器时需要使用 <code>AnnotationApplicationContext</code>(有@Configuration 注解的类.class)</p>
<pre><code class="hljs java">ApplicationContext ac =<span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration.class);</code></pre>
<pre><code class="hljs java"><span class="hljs-meta">@Test</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>{
       String[] names=ac.getBeanDefinitionNames();
       <span class="hljs-keyword">for</span>(String name:names){
           System.out.println(name);
       }
   }</code></pre>
<p>测试结果</p>
<pre><code class="hljs java"><span class="hljs-comment">//使用注解后容器中自动就有的对象</span>
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalRequiredAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
    
<span class="hljs-comment">//配置对象</span>
springConfig

<span class="hljs-comment">//自己注入的对象    </span>
accountDaoImpl 
accountServiceImpl
now</code></pre>

            </div>
        </article>
    </div>
    <br>
    
        <div class="next-prev-post">
            
                <div class="prev-post">
                    <div class="prev gt-c-content-color-first">
                        上一篇：<a href="/2020/03/04/spring/Spring%E5%85%A5%E9%97%A804Spring%E6%95%B4%E5%90%88JUnit/" 
                            class="post-title gt-a-link">Spring入门04Spring整合JUnit</a>
                    </div>
                </div>
            
            
                <div class="next-post">
                    <div class="next gt-c-content-color-first">
                        下一篇：<a href="/2020/03/02/spring/Spring%E5%85%A5%E9%97%A802%E5%9F%BA%E4%BA%8EXML%E6%96%B9%E5%BC%8F%E7%9A%84IOC/" 
                            class="post-title gt-a-link">Spring入门02基于XML方式的IOC</a>
                    </div>
                </div>
            
        </div>
    
    
</div>
                <div class="site-footer gt-c-content-color-first">
    <div class="footer-main">
        <!-- 建议保留版权信息或者添加主题信息到友链，感谢您的理解 -->
        <!-- 文件位置：layout/_includes/footer.ejs -->
        <span style="text-align: right; float: right;">Theme <a 
            href="https://github.com/renbaoshuo/hexo-theme-pure" target="_blank">Pure</a> | Powered by <a 
            href="https://hexo.io" target="_blank">Hexo</a></span>
        <span style="text-align: left;">Footer HTML
</span>
    </div>
</div>

            </div>
        </div>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>