<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="大白小怪兽">
    
    <title>
        
            vue 学习笔记 03-webpack |
        
        大白小怪兽
    </title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="shortcut icon" href="/images/blog.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"blog.sky123.top","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#f22f27","avatar":"/images/avatar.jpg","favicon":"/images/blog.png","article_img_align":"left","left_side_width":"240px","content_max_width":"940px","hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"乐于有所得，苦于无知"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"trigger":"auto","unescape":false,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.1"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                大白小怪兽
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        
            <div class="article-cover">
                <img class="cover" src=https://img.sky123.top/img/shells-792912_1280.jpg>
            </div>
        
        <div class="article-title">
            <span class="title-hover-animation">vue 学习笔记 03-webpack</span>
        </div>
        
            <div class="article-header">
                <div class="info">
                    <div class="meta-info">
                        <div class="article-meta-info">
    <!--日期-->
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2020-05-05
    </span>

    <!--字数统计-->
    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5.2k 字</span>
        </span>
    

    <!--阅读时长-->
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>19 分钟</span>
        </span>
    

    <!--阅读人数-->
    

    <!--分类-->
    

    <!--标签-->
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/vue/">vue</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1>Webpack</h1>
<p>什么是 webpack？这个 webpack 还真不是一两句话可以说清楚的。<br>
我们先看看官方的解释：<br>
At its core, webpack is a static module bundler for modern JavaScript applications.<br>
从本质上来讲，<code>webpack 是一个现代的 JavaScript 应用的静态模块打包工具。</code></p>
<p>但是它是什么呢？用概念解释概念，还是不清晰。</p>
<p>我们从两个点来解释上面这句话：<code>模块 和 打包</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916170737157.png" alt="image-20200916170737157"></p>
<h2 id="前端模块化">前端模块化</h2>
<p>在前面学习中，我已经用了大量的篇幅解释了为什么前端需要模块化。而且我也提到了目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。在 ES6 之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。<br>
<code>并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。</code><br>
<code>而 webpack 其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。</code></p>
<p>而且不仅仅是 JavaScript 文件，我们的 CSS、图片、json 文件等等在 webpack 中都可以被当做模块来使用（在后续我们会看到）。<br>
这就是 webpack 中模块化的概念。</p>
<h2 id="打包">打包</h2>
<p>理解了 webpack 可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了。<br>
<code>就是将 webpack 中的各种资源模块进行打包合并成一个或多个包(Bundle)。</code><br>
<code>并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将 scss 转成 css，将 ES6 语法转成 ES5 语法，将 TypeScript 转成 JavaScript 等等操作。</code><br>
但是打包的操作似乎 grunt/gulp 也可以帮助我们完成，它们有什么不同呢？</p>
<h2 id="和 grunt-gulp 的对比">和 grunt/gulp 的对比</h2>
<p>grunt/gulp 的核心是 Task。我们可以配置一系列的 task，并且定义 task 要处理的事务（例如 ES6、ts 转化，图片压缩，scss 转成 css）<br>
之后让 grunt/gulp 来依次执行这些 task，而且让整个流程自动化。<br>
所以 grunt/gulp 也被称为前端自动化任务管理工具。<br>
我们来看一个 gulp 的 task</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171020257.png" alt="image-20200916171020257"></p>
<p>下面的 task 就是将 src 下面的所有 js 文件转成 ES5 的语法。并且最终输出到 dist 文件夹中。<br>
<code>什么时候用 grunt/gulp 呢？</code><br>
<code>如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。只需要进行简单的合并、压缩，就使用 grunt/gulp 即可。</code></p>
<p>但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的 webpack 了。<br>
所以，grunt/gulp 和 webpack 有什么不同呢？</p>
<p><code>grunt/gulp 更加强调的是前端流程的自动化，模块化不是它的核心。</code><br>
<code>webpack 更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能。</code></p>
<h2 id="webpack 安装">webpack 安装</h2>
<p>安装 webpack 首先需要安装 Node.js，Node.js 自带了软件包管理工具 npm<br>
查看自己的 node 版本：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171124190.png" alt="image-20200916171124190"></p>
<p>全局安装 webpack(这里我先指定版本号 3.6.0，因为 vue cli2 依赖该版本)</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171142276.png" alt="image-20200916171142276"></p>
<p>局部安装 webpack（后续才需要）</p>
<p>–save-dev` 是开发时依赖，项目打包后不需要继续使用的。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171149910.png" alt="image-20200916171149910"></p>
<p>为什么全局安装后，还需要局部安装呢？<br>
在终端直接执行 webpack 命令，使用的全局安装的 webpack。当在 package.json 中定义了 scripts 时，其中包含了 webpack 命令，那么使用的是局部 webpack</p>
<h2 id="webpack 准备工作">webpack 准备工作</h2>
<p>我们创建如下文件和文件夹：<br>
文件和文件夹解析：<br>
<code>dist 文件夹：</code>用于存放之后打包的文件<br>
<code>src 文件夹：</code>用于存放我们写的源文件</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171440074.png" alt="image-20200916171440074"></p>
<p><code>main.js：</code>项目的入口文件。具体内容查看下面详情。<br>
<code>mathUtils.js：</code>定义了一些数学工具函数，可以在其他地方引用，并且使用。具体内容查看下面的详情。<br>
<code>index.html：</code>浏览器打开展示的首页 html<br>
<code>package.json：</code>通过 npm init 生成的，npm 包管理的文件（暂时没有用上，后面才会用上）<br>
<code>mathUtils.js</code>文件中的代码：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171447743.png" alt="image-20200916171447743"></p>
<p><code>main.js</code>文件中的代码：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171452474.png" alt="image-20200916171452474"></p>
<p>现在的 js 文件中使用了模块化的方式进行开发，他们可以直接使用吗？不可以。</p>
<p>因为如果直接在 index.html 引入这两个 js 文件，浏览器并不识别其中的模块化代码。</p>
<p>另外，在真实项目中当有许多这样的 js 文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理。<br>
我们应该怎么做呢？使用 webpack 工具，对多个 js 文件进行打包。<br>
我们知道，webpack 就是一个模块化的打包工具，所以它支持我们代码中写模块化，可以对模块化的代码进行处理。（如何处理的，待会儿在原理中，我会讲解）<br>
另外，如果 <code> 在处理完所有模块之间的关系后，将多个 js 打包到一个 js 文件中，引入时就变得非常方便了</code>。<br>
OK，如何打包呢？使用 webpack 的指令即可</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171609338.png" alt="image-20200916171609338"></p>
<p>打包后会在 dist 文件下，生成一个 bundle.js 文件。文件内容有些复杂，这里暂时先不看，后续再进行分析。<br>
bundle.js 文件，是 webpack 处理了项目直接文件依赖后生成的一个 js 文件，我们只需要将这个 js 文件在 index.html 中引入即可。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171655376.png" alt="image-20200916171655376"></p>
<h2 id="webpack 配置">webpack 配置</h2>
<p>我们考虑一下，如果每次使用 webpack 的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一种方法可以将这两个参数写到配置中，在运行时，直接读取呢？<br>
当然可以，就是 <code> 创建一个 webpack.config.js 文件</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916171752360.png" alt="image-20200916171752360"></p>
<p>目前，我们使用的 webpack 是全局的 webpack，如果我们想使用局部来打包呢？因为一个项目往往依赖特定的 webpack 版本，全局的版本可能很这个项目的 webpack 版本不一致，导出打包出现问题。<br>
所以通常一个项目，都有自己局部的 webpack。</p>
<p>第一步，项目中需要安装自己局部的 webpack</p>
<p>这里我们让局部安装 webpack3.6.0</p>
<p><code>见 webpack 安装</code></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172013536.png" alt="image-20200916172013536"></p>
<p>Vue CLI3 中已经升级到 webpack4，但是它将配置文件隐藏了起来，所以查看起来不是很方便。</p>
<p>第二步，通过 node_modules/.bin/webpack 启动 webpack 打包</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172022013.png" alt="image-20200916172022013"></p>
<h3 id="package-json 中定义启动">package.json 中定义启动</h3>
<p>但是，每次执行都敲这么一长串有没有觉得不方便呢？OK，我们可以在 package.json 的 scripts 中定义自己的执行脚本。<br>
package.json 中的 scripts 的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172152264.png" alt="image-20200916172152264"></p>
<p>首先，会寻找本地的 node_modules/.bin 路径中对应的命令。<br>
如果没有找到，会去全局的环境变量中寻找。<br>
如何执行我们的 build 指令呢？</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172142724.png" alt="image-20200916172142724"></p>
<h2 id="loader">loader</h2>
<p>loader 是 webpack 中一个非常核心的概念。webpack 用来做什么呢？<br>
在我们之前的实例中，我们主要是用 webpack 来处理我们写的 js 代码，并且 webpack 会自动处理 js 之间相关的依赖。<br>
但是，在开发中我们 <code> 不仅仅有基本的 js 代码处理，我们也需要加载 css、图片，也包括一些高级的将 ES6 转成 ES5 代码，将 TypeScript 转成 ES5 代码，将 scss、less 转成 css，将.jsx、.vue 文件转成 js 文件等等。</code></p>
<p>对于 webpack 本身的能力来说，对于这些转化是不支持的。那怎么办呢？给 webpack 扩展对应的 loader 就可以啦。<br>
loader 使用过程：<br>
<code>步骤一：通过 npm 安装需要使用的 loader</code><br>
<code>步骤二：在 webpack.config.js 中的 modules 关键字下进行配置</code></p>
<p>大部分 loader 我们都可以在 webpack 的官网中找到，并且学习对应的用法。</p>
<h3 id="css-loader 和 style-loader">css-loader 和 style-loader</h3>
<p>项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。<br>
在 src 目录中，创建一个 css 文件，其中创建一个 normal.css 文件。<br>
我们也可以重新组织文件的目录结构，将零散的 js 文件放在一个 js 文件夹中。<br>
normal.css 中的代码非常简单，就是将 body 设置为 red<br>
但是，这个时候 normal.css 中的样式会生效吗？<br>
当然不会，因为我们压根就没有引用它。<br>
webpack 也不可能找到它，因为我们只有一个入口，webpack 会从入口开始查找其他依赖的文件。</p>
<p>在入口文件中引用：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172345560.png" alt="image-20200916172345560"></p>
<p>重新打包，会出现如下错误：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172415658.png" alt="image-20200916172415658"></p>
<p>这个错误告诉我们：加载 normal.css 文件必须有对应的 loader。</p>
<p>在 webpack 的官方中，我们可以找到如下关于样式的 loader 使用方法：按照官方配置 webpack.config.js 文件</p>
<p>注意：配置中有一个 style-loader，我们并不知道它是什么，所以可以暂时不进行配置。</p>
<p>重新打包项目：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172509773.png" alt="image-20200916172509773"></p>
<p>但是，运行 index.html，你会发现样式并没有生效。</p>
<p>原因是 css-loader 只负责加载 css 文件，但是并不负责将 css 具体样式嵌入到文档中。这个时候，我们还需要一个 style-loader 帮助我们处理。</p>
<p>我们来安装 style-loader</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172609734.png" alt="image-20200916172609734"></p>
<p>注意：<code>style-loader 需要放在 css-loader 的前面。</code><br>
疑惑：不对吧？按照我们的逻辑，在处理 css 文件过程中，应该是 css-loader 先加载 css 文件，再由 style-loader 来进行进一步的处理，为什么会将 style-loader 放在前面呢？<br>
<code>答案：这次因为 webpack 在读取使用的 loader 的过程中，是按照从右向左的顺序读取的。</code><br>
目前，webpack.config.js 的配置如下：</p>
<img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172619418.png" alt="image-20200916172619418" style="zoom:80%;">
<h3 id="less-loader">less-loader</h3>
<p>如果我们希望在项目中使用 less、scss、stylus 来写样式，webpack 是否可以帮助我们处理呢？我们这里以 less 为例，其他也是一样的。我们还是先创建一个 less 文件，依然放在 css 文件夹中.</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172804658.png" alt="image-20200916172804658"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172810288.png" alt="image-20200916172810288"></p>
<p>继续在官方中查找，我们会找到 less-loader 相关的使用说明<br>
首先，还是需要安装对应的 loader</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172847439.png" alt="image-20200916172847439"></p>
<p>注意：我们这里还安装了 less，因为 webpack 会使用 less 对 less 文件进行编译</p>
<p>其次，修改对应的配置文件<br>
添加一个 rules 选项，用于处理.less 文件</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916172854832.png" alt="image-20200916172854832"></p>
<h3 id="url-loader 和 file-loader">url-loader 和 file-loader</h3>
<p>首先，我们在项目中加入两张图片：<br>
一张较小的图片 test01.jpg(小于 8kb)，一张较大的图片 test02.jpeg(大于 8kb)</p>
<p>待会儿我们会针对这两张图片进行不同的处理。我们先考虑在 css 样式中引用图片的情况，所以我更改了 normal.css 中的样式：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173038912.png" alt="image-20200916173038912"></p>
<p>如果我们现在直接打包，会出现如下问题：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173043885.png" alt="image-20200916173043885"></p>
<p>图片处理，我们使用 url-loader 来处理，依然先安装 url-loader</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173136102.png" alt="image-20200916173136102"></p>
<p>修改 webpack.config.js 配置文件：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173139980.png" alt="image-20200916173139980"></p>
<p>再次打包，运行 index.html，就会发现我们的背景图片选出了出来。<br>
而仔细观察，你会发现背景图是通过 base64 显示出来的<br>
OK，这也是 limit 属性的作用，当图片小于 8kb 时，对图片进行 base64 编码</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173148926.png" alt="image-20200916173148926"></p>
<p>那么问题来了，如果大于 8kb 呢？我们将 background 的图片改成 test02.jpg<br>
这次因为大于 8kb 的图片，会通过 file-loader 进行处理，但是我们的项目中并没有 file-loader</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173210446.png" alt="image-20200916173210446"></p>
<p>所以，我们需要安装 file-loader</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173215710.png" alt="image-20200916173215710"></p>
<p>再次打包，就会发现 dist 文件夹下多了一个图片文件</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173220793.png" alt="image-20200916173220793"></p>
<h4 id="图片文件处理 -–- 修改文件名称">图片文件处理 – 修改文件名称</h4>
<p>我们发现 webpack 自动帮助我们生成一个非常长的名字。这是一个 32 位 hash 值，目的是防止名字重复<br>
但是，真实开发中，我们可能对打包的图片名字有一定的要求<br>
比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复<br>
所以，我们可以在 options 中添加上如下选项：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173337012.png" alt="image-20200916173337012"></p>
<p><code>img：文件要打包到的文件夹</code><br>
<code>name：获取图片原来的名字，放在该位置</code><br>
<code>hash:8：为了防止图片名称冲突，依然使用 hash，但是我们只保留 8 位</code><br>
<code>ext：使用图片原来的扩展名</code></p>
<p>但是，我们发现图片并没有显示出来，这是因为图片使用的路径不正确<br>
默认情况下，webpack 会将生成的路径直接返回给使用者<br>
但是，我们整个程序是打包在 dist 文件夹下的，所以这里我们需要在路径下再添加一个 dist/</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173349429.png" alt="image-20200916173349429"></p>
<h3 id="babel-loader">babel-loader</h3>
<h4 id="ES6 语法处理">ES6 语法处理</h4>
<p>如果你仔细阅读 webpack 打包的 js 文件，发现写的 ES6 语法并没有转成 ES5，那么就意味着可能一些对 ES6 还不支持的浏览器没有办法很好的运行我们的代码。<br>
在前面我们说过，如果希望将 ES6 的语法转成 ES5，那么就需要使用 babel。<br>
而在 webpack 中，我们直接使用 babel 对应的 loader 就可以了。</p>
<p><code>npm install --save-dev babel-loader@7 babel-core babel-preset-es2015</code></p>
<p>配置 webpack.config.js 文件</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173541318.png" alt="image-20200916173541318"></p>
<p>重新打包，查看 bundle.js 文件，发现其中的内容变成了 ES5 的语法</p>
<h3 id="配置 vue">配置 vue</h3>
<p>后续项目中，我们会使用 Vuejs 进行开发，而且会以特殊的文件来组织 vue 的组件。所以，下面我们来学习一下如何在我们的 webpack 环境中集成 Vuejs<br>
现在，我们希望在项目中使用 Vuejs，那么必然需要对其有依赖，所以需要先进行安装<br>
注：因为我们后续是在实际项目中也会使用 vue 的，所以并不是开发时依赖</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173644714.png" alt="image-20200916173644714"></p>
<p>那么，接下来就可以按照我们之前学习的方式来使用 Vue 了</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173649716.png" alt="image-20200916173649716"></p>
<p>修改完成后，重新打包，运行程序：<br>
打包过程没有任何错误(因为只是多打包了一个 vue 的 js 文件而已)<br>
但是运行程序，没有出现想要的效果，而且浏览器中有报错</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173711182.png" alt="image-20200916173711182"></p>
<p>这个错误说的是我们使用的是 runtime-only 版本的 Vue，什么意思呢？<br>
这里我只说解决方案<code>：Vue 不同版本构建，后续我具体讲解 runtime-only 和 runtime-compiler 的区别。</code></p>
<p>所以我们修改 webpack 的配置，添加如下内容即可</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916173746318.png" alt="image-20200916173746318"></p>
<h2 id="el 和 template 区别">el 和 template 区别</h2>
<p>正常运行之后，我们来考虑另外一个问题：<br>
<code>如果我们希望将 data 中的数据显示在界面中，就必须是修改 index.html</code><br>
<code>如果我们后面自定义了组件，也必须修改 index.html 来使用组件</code></p>
<p>但是 html 模板在之后的开发中，我并不希望手动的来频繁修改，是否可以做到呢？<br>
定义 template 属性：<br>
在前面的 Vue 实例中，我们定义了 el 属性，用于和 index.html 中的 #app 进行绑定，让 Vue 实例之后可以管理它其中的内容<br>
这里，我们可以将 div 元素中的内容删掉，只保留一个基本的 id 为 div 的元素<br>
但是如果我依然希望在其中显示的内容，应该怎么处理呢？<br>
我们可以再定义一个 template 属性，代码如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181202401.png" alt="image-20200916181202401"></p>
<p>重新打包，运行程序，显示一样的结果和 HTML 代码结构<br>
那么，el 和 template 模板的关系是什么呢？</p>
<p>在我们之前的学习中，<code>我们知道 el 用于指定 Vue 要管理的 DOM，可以帮助解析其中的指令、事件监听等等。</code><br>
<code>而如果 Vue 实例中同时指定了 template，那么 template 模板的内容会替换掉挂载的对应 el 的模板。</code></p>
<p>这样做有什么好处呢？</p>
<p><code>这样做之后我们就不需要在以后的开发中再次操作 index.html，只需要在 template 中写入对应的标签即可</code><br>
<code>但是，书写 template 模块非常麻烦怎么办呢？</code><br>
没有关系，稍后我们会将 template 模板中的内容进行抽离。<br>
会分成三部分书写：template、script、style，结构变得非常清晰。</p>
<h2 id="vue 组件化开发的引入">vue 组件化开发的引入</h2>
<p>在学习组件化开发的时候，我说过以后的 Vue 开发过程中，我们都会采用组件化开发的思想。<br>
那么，在当前项目中，如果我也想采用组件化的形式进行开发，应该怎么做呢？<br>
查看下面的代码：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181334306.png" alt="image-20200916181334306"></p>
<p>当然，我们也可以将下面的代码抽取到一个 js 文件中，并且导出。</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181340309.png" alt="image-20200916181340309"></p>
<p>但是一个组件以一个 js 对象的形式进行组织和使用的时候是非常不方便的。一方面编写 template 模块非常的麻烦<br>
另外一方面如果有样式的话，我们写在哪里比较合适呢？现在，我们以一种全新的方式来组织一个 vue 的组件<br>
但是，这个时候这个文件可以被正确的加载吗？<br>
必然不可以，<code>这种特殊的文件以及特殊的格式，必须有人帮助我们处理。</code><br>
<code>谁来处理呢？vue-loader 以及 vue-template-compiler。</code></p>
<p>安装 vue-loader 和 vue-template-compiler</p>
<p><code>npm install vue-loader vue-template-compiler --save-dev</code></p>
<p>修改 webpack.config.js 的配置文件：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181429212.png" alt="image-20200916181429212"></p>
<h2 id="plugin">plugin</h2>
<h3 id="plugin 是什么？">plugin 是什么？</h3>
<p>plugin 是插件的意思，通常是用于对某个现有的架构进行扩展。<br>
webpack 中的插件，就是对 webpack 现有功能的各种扩展，比如打包优化，文件压缩等等。</p>
<h3 id="loader 和 plugin 区别">loader 和 plugin 区别</h3>
<p>loader 主要用于转换某些类型的模块，它是一个转换器。<br>
plugin 是插件，它是对 webpack 本身的扩展，是一个扩展器。</p>
<h3 id="plugin 的使用过程：">plugin 的使用过程：</h3>
<p>步骤一：通过 npm 安装需要使用的 plugins(某些 webpack 已经内置的插件不需要安装)<br>
步骤二：在 webpack.config.js 中的 plugins 中配置插件。</p>
<p>下面，我们就来看看可以通过哪些插件对现有的 webpack 打包过程进行扩容，让我们的 webpack 变得更加好用。</p>
<h3 id="版权声明插件">版权声明插件</h3>
<p>我们先来使用一个最简单的插件，为打包的文件添加版权声明<br>
该插件名字叫 BannerPlugin，属于 webpack 自带的插件。<br>
按照下面的方式来修改 webpack.config.js 的文件：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181814895.png" alt="image-20200916181814895"></p>
<p>重新打包程序：查看 bundle.js 文件的头部，看到如下信息</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181821618.png" alt="image-20200916181821618"></p>
<h3 id="打包 html 插件">打包 html 插件</h3>
<p>目前，<code>我们的 index.html 文件是存放在项目的根目录下的。我们知道，在真实发布项目时，发布的是 dist 文件夹中的内容，但是 dist 文件夹中如果没有 index.html 文件，那么打包的 js 等文件也就没有意义了。</code></p>
<p>所以，我们需要将 index.html 文件打包到 dist 文件夹中，这个时候就可以使用<code>HtmlWebpackPlugin 插件</code><br>
HtmlWebpackPlugin 插件可以为我们做这些事情：<br>
自动生成一个 index.html 文件(可以指定模板来生成)<br>
将打包的 js 文件，自动通过 script 标签插入到 body 中<br>
安装 HtmlWebpackPlugin 插件</p>
<p><code>npm install html-webpack-plugin --save-dev</code></p>
<p>使用插件，修改 webpack.config.js 文件中 plugins 部分的内容如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916181959390.png" alt="image-20200916181959390"></p>
<p>这里的 template 表示根据什么模板来生成 index.html<br>
另外，我们需要删除之前在 output 中添加的 publicPath 属性<br>
否则插入的 script 标签中的 src 可能会有问题</p>
<h3 id="js 压缩插件">js 压缩插件</h3>
<p>在项目发布之前，我们必然需要对 js 等文件进行压缩处理<br>
这里，我们就对打包的 js 文件进行压缩<br>
我们使用一个第三方的插件<code>uglifyjs-webpack-plugin</code>，并且版本号指定 1.1.1，和 CLI2 保持一致</p>
<p><code>npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</code></p>
<p>修改 webpack.config.js 文件，使用插件：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916182106424.png" alt="image-20200916182106424"></p>
<p>查看打包后的 bunlde.js 文件，是已经被压缩过了。</p>
<h2 id="搭建本地服务器">搭建本地服务器</h2>
<p>webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 搭建，内部使用 express 框架，<code>可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。</code><br>
不过它是一个单独的模块，在 webpack 中使用之前需要先安装它</p>
<p>devserver 也是作为 webpack 中的一个选项，选项本身可以设置如下属性：<br>
<code>contentBase：</code>为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist<br>
<code>port：</code>端口号<br>
<code>inline：</code>页面实时刷新<br>
<code>historyApiFallback：</code>在 SPA 页面中，依赖 HTML5 的 history 模式<br>
webpack.config.js 文件配置修改如下：</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://img.sky123.top/img/image-20200916182215096.png" alt="image-20200916182215096"></p>
<p>我们可以再配置另外一个 scripts：–open 参数表示直接打开浏览器</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2020/05/05/vue/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8CVueCLI%E7%9A%84%E4%BD%BF%E7%94%A8/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">vue 学习笔记 04- 前端模块化和 vueCli 的使用</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2020/05/05/vue/Vue%E6%8F%92%E6%A7%BD%E5%92%8C%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%8C%96/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">vue 学习笔记 02-vue 的插槽和组件化开发</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">大白小怪兽</a>
        </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.1</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list show">
        <!--隐藏放大缩小字体和全屏模式-->
        <li class="tools-item tool-font-adjust-plus flex-center" style="display: none">
            <i class="fas fa-search-plus"></i>
        </li>
        <li class="tools-item tool-font-adjust-minus flex-center" style="display: none">
            <i class="fas fa-search-minus"></i>
        </li>
        <li class="tools-item tool-expand-width flex-center" style="display: none">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">Webpack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-text">前端模块化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8C%85"><span class="nav-text">打包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%92%8C%20grunt-gulp%20%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">和 grunt&#x2F;gulp 的对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack%20%E5%AE%89%E8%A3%85"><span class="nav-text">webpack 安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack%20%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-text">webpack 准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#webpack%20%E9%85%8D%E7%BD%AE"><span class="nav-text">webpack 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#package-json%20%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8"><span class="nav-text">package.json 中定义启动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#loader"><span class="nav-text">loader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#css-loader%20%E5%92%8C%20style-loader"><span class="nav-text">css-loader 和 style-loader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#less-loader"><span class="nav-text">less-loader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#url-loader%20%E5%92%8C%20file-loader"><span class="nav-text">url-loader 和 file-loader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%89%87%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%20-%E2%80%93-%20%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0"><span class="nav-text">图片文件处理 – 修改文件名称</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#babel-loader"><span class="nav-text">babel-loader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6%20%E8%AF%AD%E6%B3%95%E5%A4%84%E7%90%86"><span class="nav-text">ES6 语法处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%20vue"><span class="nav-text">配置 vue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#el%20%E5%92%8C%20template%20%E5%8C%BA%E5%88%AB"><span class="nav-text">el 和 template 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%20%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-text">vue 组件化开发的引入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#plugin"><span class="nav-text">plugin</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#plugin%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">plugin 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loader%20%E5%92%8C%20plugin%20%E5%8C%BA%E5%88%AB"><span class="nav-text">loader 和 plugin 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#plugin%20%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-text">plugin 的使用过程：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E6%8F%92%E4%BB%B6"><span class="nav-text">版权声明插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%8C%85%20html%20%E6%8F%92%E4%BB%B6"><span class="nav-text">打包 html 插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js%20%E5%8E%8B%E7%BC%A9%E6%8F%92%E4%BB%B6"><span class="nav-text">js 压缩插件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">搭建本地服务器</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.1/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
