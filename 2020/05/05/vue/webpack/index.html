<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Title -->
<title>vue学习笔记03-webpack - Hexo</title>

<!-- Icon -->
<link rel="icon" href="/favicon.ico">

<!-- Fonts -->
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" as="style" onload="this.onload=null, this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript>



<!-- Style -->

<link rel="stylesheet" href="/styles/main.css">

<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-pure@1.0.1/dist/main.css"> -->



    <meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>
    <body>
        <div class="main gt-bg-theme-color-first">
            <div class="main-content">
                <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/favicon.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            
        </div>
    </div>
    <button aria-label="Navbar Toggler" class="navbar-toggler" type="button" id="changeNavbar">
        <i class="gt-c-content-color-first" style="font-size: 18px;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" height="18px" fill="currentColor">
                <path d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" />
            </svg>
        </i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center; ">
            
                <div class="nav-item">
                    <a href="/" class="menu gt-a-link" target="_self">首页</a>
                </div>
            
                <div class="nav-item">
                    <a href="/archives/" class="menu gt-a-link" target="_self">归档</a>
                </div>
            
                <div class="nav-item">
                    <a href="/tags/" class="menu gt-a-link" target="_self">标签</a>
                </div>
            
                <div class="nav-item">
                    <a href="/friends/" class="menu gt-a-link" target="_self">友链</a>
                </div>
            
        </div>
    </div>
</nav>

<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function() {
        let element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else { 
            element.style.display = 'none';
        }
    }
</script>
                <div class="post-container">
    <div class="post-detail gt-bg-theme-color-second gt-c-content-color-first">
        <article class="gt-post-content">
            <h1 class="post-title">vue学习笔记03-webpack</h1>
            <div class="post-info">
                <time class="post-time gt-c-content-color-first">
                    · 2020-05-05 ·</time>
                
                    
                        <a href="/tags/%E5%89%8D%E7%AB%AF/" class="post-tag">
                            #前端</a>
                    
                        <a href="/tags/vue/" class="post-tag">
                            #vue</a>
                    
                
            </div>
            <hr>
            <div class="post-content gt-c-content-color-first">
                <h1 id="vue学习笔记03-webpack"><a href="#vue学习笔记03-webpack" class="headerlink" title="vue学习笔记03-webpack"></a>vue学习笔记03-webpack</h1><hr>
<p><img src="https://img.sky123.top/img/sunrise-1014712_1280.jpg"></p>
<hr>
<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><p>什么是webpack？这个webpack还真不是一两句话可以说清楚的。<br>我们先看看官方的解释：<br>At its core, webpack is a static module bundler for modern JavaScript applications.<br>从本质上来讲，<code>webpack是一个现代的JavaScript应用的静态模块打包工具。</code></p>
<p>但是它是什么呢？用概念解释概念，还是不清晰。</p>
<p>我们从两个点来解释上面这句话：<code>模块 和 打包</code></p>
<p><img src="https://img.sky123.top/img/image-20200916170737157.png" alt="image-20200916170737157"></p>
<h2 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h2><p>在前面学习中，我已经用了大量的篇幅解释了为什么前端需要模块化。而且我也提到了目前使用前端模块化的一些方案：AMD、CMD、CommonJS、ES6。在ES6之前，我们要想进行模块化开发，就必须借助于其他的工具，让我们可以进行模块化开发。<br><code>并且在通过模块化开发完成了项目后，还需要处理模块间的各种依赖，并且将其进行整合打包。</code><br><code>而webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系。</code></p>
<p>而且不仅仅是JavaScript文件，我们的CSS、图片、json文件等等在webpack中都可以被当做模块来使用（在后续我们会看到）。<br>这就是webpack中模块化的概念。</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>理解了webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就非常好理解了。<br><code>就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)。</code><br><code>并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。</code><br>但是打包的操作似乎grunt/gulp也可以帮助我们完成，它们有什么不同呢？</p>
<h2 id="和grunt-gulp的对比"><a href="#和grunt-gulp的对比" class="headerlink" title="和grunt/gulp的对比"></a>和grunt/gulp的对比</h2><p>grunt/gulp的核心是Task。我们可以配置一系列的task，并且定义task要处理的事务（例如ES6、ts转化，图片压缩，scss转成css）<br>之后让grunt/gulp来依次执行这些task，而且让整个流程自动化。<br>所以grunt/gulp也被称为前端自动化任务管理工具。<br>我们来看一个gulp的task</p>
<p><img src="https://img.sky123.top/img/image-20200916171020257.png" alt="image-20200916171020257"></p>
<p>下面的task就是将src下面的所有js文件转成ES5的语法。并且最终输出到dist文件夹中。<br><code>什么时候用grunt/gulp呢？</code><br><code>如果你的工程模块依赖非常简单，甚至是没有用到模块化的概念。只需要进行简单的合并、压缩，就使用grunt/gulp即可。</code></p>
<p>但是如果整个项目使用了模块化管理，而且相互依赖非常强，我们就可以使用更加强大的webpack了。<br>所以，grunt/gulp和webpack有什么不同呢？</p>
<p><code>grunt/gulp更加强调的是前端流程的自动化，模块化不是它的核心。</code><br><code>webpack更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他附带的功能。</code></p>
<h2 id="webpack安装"><a href="#webpack安装" class="headerlink" title="webpack安装"></a>webpack安装</h2><p>安装webpack首先需要安装Node.js，Node.js自带了软件包管理工具npm<br>查看自己的node版本：</p>
<p><img src="https://img.sky123.top/img/image-20200916171124190.png" alt="image-20200916171124190"></p>
<p>全局安装webpack(这里我先指定版本号3.6.0，因为vue cli2依赖该版本)</p>
<p><img src="https://img.sky123.top/img/image-20200916171142276.png" alt="image-20200916171142276"></p>
<p>局部安装webpack（后续才需要）</p>
<p>–save-dev`是开发时依赖，项目打包后不需要继续使用的。</p>
<p><img src="https://img.sky123.top/img/image-20200916171149910.png" alt="image-20200916171149910"></p>
<p>为什么全局安装后，还需要局部安装呢？<br>在终端直接执行webpack命令，使用的全局安装的webpack。当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack</p>
<h2 id="webpack准备工作"><a href="#webpack准备工作" class="headerlink" title="webpack准备工作"></a>webpack准备工作</h2><p>我们创建如下文件和文件夹：<br>文件和文件夹解析：<br><code>dist文件夹：</code>用于存放之后打包的文件<br><code>src文件夹：</code>用于存放我们写的源文件</p>
<p><img src="https://img.sky123.top/img/image-20200916171440074.png" alt="image-20200916171440074"></p>
<p><code>main.js：</code>项目的入口文件。具体内容查看下面详情。<br><code>mathUtils.js：</code>定义了一些数学工具函数，可以在其他地方引用，并且使用。具体内容查看下面的详情。<br><code>index.html：</code>浏览器打开展示的首页html<br><code>package.json：</code>通过npm init生成的，npm包管理的文件（暂时没有用上，后面才会用上）<br><code>mathUtils.js</code>文件中的代码：</p>
<p><img src="https://img.sky123.top/img/image-20200916171447743.png" alt="image-20200916171447743"></p>
<p><code>main.js</code>文件中的代码：</p>
<p><img src="https://img.sky123.top/img/image-20200916171452474.png" alt="image-20200916171452474"></p>
<p>现在的js文件中使用了模块化的方式进行开发，他们可以直接使用吗？不可以。</p>
<p>因为如果直接在index.html引入这两个js文件，浏览器并不识别其中的模块化代码。</p>
<p>另外，在真实项目中当有许多这样的js文件时，我们一个个引用非常麻烦，并且后期非常不方便对它们进行管理。<br>我们应该怎么做呢？使用webpack工具，对多个js文件进行打包。<br>我们知道，webpack就是一个模块化的打包工具，所以它支持我们代码中写模块化，可以对模块化的代码进行处理。（如何处理的，待会儿在原理中，我会讲解）<br>另外，如果<code>在处理完所有模块之间的关系后，将多个js打包到一个js文件中，引入时就变得非常方便了</code>。<br>OK，如何打包呢？使用webpack的指令即可</p>
<p><img src="https://img.sky123.top/img/image-20200916171609338.png" alt="image-20200916171609338"></p>
<p>打包后会在dist文件下，生成一个bundle.js文件。文件内容有些复杂，这里暂时先不看，后续再进行分析。<br>bundle.js文件，是webpack处理了项目直接文件依赖后生成的一个js文件，我们只需要将这个js文件在index.html中引入即可。</p>
<p><img src="https://img.sky123.top/img/image-20200916171655376.png" alt="image-20200916171655376"></p>
<h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>我们考虑一下，如果每次使用webpack的命令都需要写上入口和出口作为参数，就非常麻烦，有没有一种方法可以将这两个参数写到配置中，在运行时，直接读取呢？<br>当然可以，就是<code>创建一个webpack.config.js文件</code></p>
<p><img src="https://img.sky123.top/img/image-20200916171752360.png" alt="image-20200916171752360"></p>
<p>目前，我们使用的webpack是全局的webpack，如果我们想使用局部来打包呢？因为一个项目往往依赖特定的webpack版本，全局的版本可能很这个项目的webpack版本不一致，导出打包出现问题。<br>所以通常一个项目，都有自己局部的webpack。</p>
<p>第一步，项目中需要安装自己局部的webpack</p>
<p>这里我们让局部安装webpack3.6.0</p>
<p><code>见webpack安装</code></p>
<p><img src="https://img.sky123.top/img/image-20200916172013536.png" alt="image-20200916172013536"></p>
<p>Vue CLI3中已经升级到webpack4，但是它将配置文件隐藏了起来，所以查看起来不是很方便。</p>
<p>第二步，通过node_modules/.bin/webpack启动webpack打包</p>
<p><img src="https://img.sky123.top/img/image-20200916172022013.png" alt="image-20200916172022013"></p>
<h3 id="package-json中定义启动"><a href="#package-json中定义启动" class="headerlink" title="package.json中定义启动"></a>package.json中定义启动</h3><p>但是，每次执行都敲这么一长串有没有觉得不方便呢？OK，我们可以在package.json的scripts中定义自己的执行脚本。<br>package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。</p>
<p><img src="https://img.sky123.top/img/image-20200916172152264.png" alt="image-20200916172152264"></p>
<p>首先，会寻找本地的node_modules/.bin路径中对应的命令。<br>如果没有找到，会去全局的环境变量中寻找。<br>如何执行我们的build指令呢？</p>
<p><img src="https://img.sky123.top/img/image-20200916172142724.png" alt="image-20200916172142724"></p>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader是webpack中一个非常核心的概念。webpack用来做什么呢？<br>在我们之前的实例中，我们主要是用webpack来处理我们写的js代码，并且webpack会自动处理js之间相关的依赖。<br>但是，在开发中我们<code>不仅仅有基本的js代码处理，我们也需要加载css、图片，也包括一些高级的将ES6转成ES5代码，将TypeScript转成ES5代码，将scss、less转成css，将.jsx、.vue文件转成js文件等等。</code></p>
<p>对于webpack本身的能力来说，对于这些转化是不支持的。那怎么办呢？给webpack扩展对应的loader就可以啦。<br>loader使用过程：<br><code>步骤一：通过npm安装需要使用的loader</code><br><code>步骤二：在webpack.config.js中的modules关键字下进行配置</code></p>
<p>大部分loader我们都可以在webpack的官网中找到，并且学习对应的用法。</p>
<h3 id="css-loader和style-loader"><a href="#css-loader和style-loader" class="headerlink" title="css-loader和style-loader"></a>css-loader和style-loader</h3><p>项目开发过程中，我们必然需要添加很多的样式，而样式我们往往写到一个单独的文件中。<br>在src目录中，创建一个css文件，其中创建一个normal.css文件。<br>我们也可以重新组织文件的目录结构，将零散的js文件放在一个js文件夹中。<br>normal.css中的代码非常简单，就是将body设置为red<br>但是，这个时候normal.css中的样式会生效吗？<br>当然不会，因为我们压根就没有引用它。<br>webpack也不可能找到它，因为我们只有一个入口，webpack会从入口开始查找其他依赖的文件。</p>
<p>在入口文件中引用：</p>
<p><img src="https://img.sky123.top/img/image-20200916172345560.png" alt="image-20200916172345560"></p>
<p>重新打包，会出现如下错误：</p>
<p><img src="https://img.sky123.top/img/image-20200916172415658.png" alt="image-20200916172415658"></p>
<p>这个错误告诉我们：加载normal.css文件必须有对应的loader。</p>
<p>在webpack的官方中，我们可以找到如下关于样式的loader使用方法：按照官方配置webpack.config.js文件</p>
<p>注意：配置中有一个style-loader，我们并不知道它是什么，所以可以暂时不进行配置。</p>
<p>重新打包项目：</p>
<p><img src="https://img.sky123.top/img/image-20200916172509773.png" alt="image-20200916172509773"></p>
<p>但是，运行index.html，你会发现样式并没有生效。</p>
<p>原因是css-loader只负责加载css文件，但是并不负责将css具体样式嵌入到文档中。这个时候，我们还需要一个style-loader帮助我们处理。</p>
<p>我们来安装style-loader</p>
<p><img src="https://img.sky123.top/img/image-20200916172609734.png" alt="image-20200916172609734"></p>
<p>注意：<code>style-loader需要放在css-loader的前面。</code><br>疑惑：不对吧？按照我们的逻辑，在处理css文件过程中，应该是css-loader先加载css文件，再由style-loader来进行进一步的处理，为什么会将style-loader放在前面呢？<br><code>答案：这次因为webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</code><br>目前，webpack.config.js的配置如下：</p>
<img src="https://img.sky123.top/img/image-20200916172619418.png" alt="image-20200916172619418" style="zoom:80%;">

<h3 id="less-loader"><a href="#less-loader" class="headerlink" title="less-loader"></a>less-loader</h3><p>如果我们希望在项目中使用less、scss、stylus来写样式，webpack是否可以帮助我们处理呢？我们这里以less为例，其他也是一样的。我们还是先创建一个less文件，依然放在css文件夹中.</p>
<p><img src="https://img.sky123.top/img/image-20200916172804658.png" alt="image-20200916172804658"></p>
<p><img src="https://img.sky123.top/img/image-20200916172810288.png" alt="image-20200916172810288"></p>
<p>继续在官方中查找，我们会找到less-loader相关的使用说明<br>首先，还是需要安装对应的loader</p>
<p><img src="https://img.sky123.top/img/image-20200916172847439.png" alt="image-20200916172847439"></p>
<p>注意：我们这里还安装了less，因为webpack会使用less对less文件进行编译</p>
<p>其次，修改对应的配置文件<br>添加一个rules选项，用于处理.less文件</p>
<p><img src="https://img.sky123.top/img/image-20200916172854832.png" alt="image-20200916172854832"></p>
<h3 id="url-loader和file-loader"><a href="#url-loader和file-loader" class="headerlink" title="url-loader和file-loader"></a>url-loader和file-loader</h3><p>首先，我们在项目中加入两张图片：<br>一张较小的图片test01.jpg(小于8kb)，一张较大的图片test02.jpeg(大于8kb)</p>
<p>待会儿我们会针对这两张图片进行不同的处理。我们先考虑在css样式中引用图片的情况，所以我更改了normal.css中的样式：</p>
<p><img src="https://img.sky123.top/img/image-20200916173038912.png" alt="image-20200916173038912"></p>
<p>如果我们现在直接打包，会出现如下问题：</p>
<p><img src="https://img.sky123.top/img/image-20200916173043885.png" alt="image-20200916173043885"></p>
<p>图片处理，我们使用url-loader来处理，依然先安装url-loader</p>
<p><img src="https://img.sky123.top/img/image-20200916173136102.png" alt="image-20200916173136102"></p>
<p>修改webpack.config.js配置文件：</p>
<p><img src="https://img.sky123.top/img/image-20200916173139980.png" alt="image-20200916173139980"></p>
<p>再次打包，运行index.html，就会发现我们的背景图片选出了出来。<br>而仔细观察，你会发现背景图是通过base64显示出来的<br>OK，这也是limit属性的作用，当图片小于8kb时，对图片进行base64编码</p>
<p><img src="https://img.sky123.top/img/image-20200916173148926.png" alt="image-20200916173148926"></p>
<p>那么问题来了，如果大于8kb呢？我们将background的图片改成test02.jpg<br>这次因为大于8kb的图片，会通过file-loader进行处理，但是我们的项目中并没有file-loader</p>
<p><img src="https://img.sky123.top/img/image-20200916173210446.png" alt="image-20200916173210446"></p>
<p>所以，我们需要安装file-loader</p>
<p><img src="https://img.sky123.top/img/image-20200916173215710.png" alt="image-20200916173215710"></p>
<p>再次打包，就会发现dist文件夹下多了一个图片文件</p>
<p><img src="https://img.sky123.top/img/image-20200916173220793.png" alt="image-20200916173220793"></p>
<h4 id="图片文件处理-–-修改文件名称"><a href="#图片文件处理-–-修改文件名称" class="headerlink" title="图片文件处理 – 修改文件名称"></a>图片文件处理 – 修改文件名称</h4><p>我们发现webpack自动帮助我们生成一个非常长的名字。这是一个32位hash值，目的是防止名字重复<br>但是，真实开发中，我们可能对打包的图片名字有一定的要求<br>比如，将所有的图片放在一个文件夹中，跟上图片原来的名称，同时也要防止重复<br>所以，我们可以在options中添加上如下选项：</p>
<p><img src="https://img.sky123.top/img/image-20200916173337012.png" alt="image-20200916173337012"></p>
<p><code>img：文件要打包到的文件夹</code><br><code>name：获取图片原来的名字，放在该位置</code><br><code>hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位</code><br><code>ext：使用图片原来的扩展名</code></p>
<p>但是，我们发现图片并没有显示出来，这是因为图片使用的路径不正确<br>默认情况下，webpack会将生成的路径直接返回给使用者<br>但是，我们整个程序是打包在dist文件夹下的，所以这里我们需要在路径下再添加一个dist/</p>
<p><img src="https://img.sky123.top/img/image-20200916173349429.png" alt="image-20200916173349429"></p>
<h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><h4 id="ES6语法处理"><a href="#ES6语法处理" class="headerlink" title="ES6语法处理"></a>ES6语法处理</h4><p>如果你仔细阅读webpack打包的js文件，发现写的ES6语法并没有转成ES5，那么就意味着可能一些对ES6还不支持的浏览器没有办法很好的运行我们的代码。<br>在前面我们说过，如果希望将ES6的语法转成ES5，那么就需要使用babel。<br>而在webpack中，我们直接使用babel对应的loader就可以了。</p>
<p><code>npm install --save-dev babel-loader@7 babel-core babel-preset-es2015</code></p>
<p>配置webpack.config.js文件</p>
<p><img src="https://img.sky123.top/img/image-20200916173541318.png" alt="image-20200916173541318"></p>
<p>重新打包，查看bundle.js文件，发现其中的内容变成了ES5的语法</p>
<h3 id="配置vue"><a href="#配置vue" class="headerlink" title="配置vue"></a>配置vue</h3><p>后续项目中，我们会使用Vuejs进行开发，而且会以特殊的文件来组织vue的组件。所以，下面我们来学习一下如何在我们的webpack环境中集成Vuejs<br>现在，我们希望在项目中使用Vuejs，那么必然需要对其有依赖，所以需要先进行安装<br>注：因为我们后续是在实际项目中也会使用vue的，所以并不是开发时依赖</p>
<p><img src="https://img.sky123.top/img/image-20200916173644714.png" alt="image-20200916173644714"></p>
<p>那么，接下来就可以按照我们之前学习的方式来使用Vue了</p>
<p><img src="https://img.sky123.top/img/image-20200916173649716.png" alt="image-20200916173649716"></p>
<p>修改完成后，重新打包，运行程序：<br>打包过程没有任何错误(因为只是多打包了一个vue的js文件而已)<br>但是运行程序，没有出现想要的效果，而且浏览器中有报错</p>
<p><img src="https://img.sky123.top/img/image-20200916173711182.png" alt="image-20200916173711182"></p>
<p>这个错误说的是我们使用的是runtime-only版本的Vue，什么意思呢？<br>这里我只说解决方案<code>：Vue不同版本构建，后续我具体讲解runtime-only和runtime-compiler的区别。</code></p>
<p>所以我们修改webpack的配置，添加如下内容即可</p>
<p><img src="https://img.sky123.top/img/image-20200916173746318.png" alt="image-20200916173746318"></p>
<h2 id="el和template区别"><a href="#el和template区别" class="headerlink" title="el和template区别"></a>el和template区别</h2><p>正常运行之后，我们来考虑另外一个问题：<br><code>如果我们希望将data中的数据显示在界面中，就必须是修改index.html</code><br><code>如果我们后面自定义了组件，也必须修改index.html来使用组件</code></p>
<p>但是html模板在之后的开发中，我并不希望手动的来频繁修改，是否可以做到呢？<br>定义template属性：<br>在前面的Vue实例中，我们定义了el属性，用于和index.html中的#app进行绑定，让Vue实例之后可以管理它其中的内容<br>这里，我们可以将div元素中的内容删掉，只保留一个基本的id为div的元素<br>但是如果我依然希望在其中显示的内容，应该怎么处理呢？<br>我们可以再定义一个template属性，代码如下：</p>
<p><img src="https://img.sky123.top/img/image-20200916181202401.png" alt="image-20200916181202401"></p>
<p>重新打包，运行程序，显示一样的结果和HTML代码结构<br>那么，el和template模板的关系是什么呢？</p>
<p>在我们之前的学习中，<code>我们知道el用于指定Vue要管理的DOM，可以帮助解析其中的指令、事件监听等等。</code><br><code>而如果Vue实例中同时指定了template，那么template模板的内容会替换掉挂载的对应el的模板。</code></p>
<p>这样做有什么好处呢？</p>
<p><code>这样做之后我们就不需要在以后的开发中再次操作index.html，只需要在template中写入对应的标签即可</code><br><code>但是，书写template模块非常麻烦怎么办呢？</code><br>没有关系，稍后我们会将template模板中的内容进行抽离。<br>会分成三部分书写：template、script、style，结构变得非常清晰。</p>
<h2 id="vue组件化开发的引入"><a href="#vue组件化开发的引入" class="headerlink" title="vue组件化开发的引入"></a>vue组件化开发的引入</h2><p>在学习组件化开发的时候，我说过以后的Vue开发过程中，我们都会采用组件化开发的思想。<br>那么，在当前项目中，如果我也想采用组件化的形式进行开发，应该怎么做呢？<br>查看下面的代码：    </p>
<p><img src="https://img.sky123.top/img/image-20200916181334306.png" alt="image-20200916181334306"></p>
<p>当然，我们也可以将下面的代码抽取到一个js文件中，并且导出。</p>
<p><img src="https://img.sky123.top/img/image-20200916181340309.png" alt="image-20200916181340309"></p>
<p>但是一个组件以一个js对象的形式进行组织和使用的时候是非常不方便的。一方面编写template模块非常的麻烦<br>另外一方面如果有样式的话，我们写在哪里比较合适呢？现在，我们以一种全新的方式来组织一个vue的组件<br>但是，这个时候这个文件可以被正确的加载吗？<br>必然不可以，<code>这种特殊的文件以及特殊的格式，必须有人帮助我们处理。</code><br><code>谁来处理呢？vue-loader以及vue-template-compiler。</code></p>
<p>安装vue-loader和vue-template-compiler</p>
<p><code>npm install vue-loader vue-template-compiler --save-dev</code></p>
<p>修改webpack.config.js的配置文件：</p>
<p><img src="https://img.sky123.top/img/image-20200916181429212.png" alt="image-20200916181429212"></p>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><h3 id="plugin是什么？"><a href="#plugin是什么？" class="headerlink" title="plugin是什么？"></a>plugin是什么？</h3><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。<br>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</p>
<h3 id="loader和plugin区别"><a href="#loader和plugin区别" class="headerlink" title="loader和plugin区别"></a>loader和plugin区别</h3><p>loader主要用于转换某些类型的模块，它是一个转换器。<br>plugin是插件，它是对webpack本身的扩展，是一个扩展器。</p>
<h3 id="plugin的使用过程："><a href="#plugin的使用过程：" class="headerlink" title="plugin的使用过程："></a>plugin的使用过程：</h3><p>步骤一：通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)<br>步骤二：在webpack.config.js中的plugins中配置插件。</p>
<p>下面，我们就来看看可以通过哪些插件对现有的webpack打包过程进行扩容，让我们的webpack变得更加好用。</p>
<h3 id="版权声明插件"><a href="#版权声明插件" class="headerlink" title="版权声明插件"></a>版权声明插件</h3><p>我们先来使用一个最简单的插件，为打包的文件添加版权声明<br>该插件名字叫BannerPlugin，属于webpack自带的插件。<br>按照下面的方式来修改webpack.config.js的文件：</p>
<p><img src="https://img.sky123.top/img/image-20200916181814895.png" alt="image-20200916181814895"></p>
<p>重新打包程序：查看bundle.js文件的头部，看到如下信息</p>
<p><img src="https://img.sky123.top/img/image-20200916181821618.png" alt="image-20200916181821618"></p>
<h3 id="打包html插件"><a href="#打包html插件" class="headerlink" title="打包html插件"></a>打包html插件</h3><p>目前，<code>我们的index.html文件是存放在项目的根目录下的。我们知道，在真实发布项目时，发布的是dist文件夹中的内容，但是dist文件夹中如果没有index.html文件，那么打包的js等文件也就没有意义了。</code></p>
<p>所以，我们需要将index.html文件打包到dist文件夹中，这个时候就可以使用<code>HtmlWebpackPlugin插件</code><br>HtmlWebpackPlugin插件可以为我们做这些事情：<br>自动生成一个index.html文件(可以指定模板来生成)<br>将打包的js文件，自动通过script标签插入到body中<br>安装HtmlWebpackPlugin插件</p>
<p><code>npm install html-webpack-plugin --save-dev</code></p>
<p>使用插件，修改webpack.config.js文件中plugins部分的内容如下：</p>
<p><img src="https://img.sky123.top/img/image-20200916181959390.png" alt="image-20200916181959390"></p>
<p>这里的template表示根据什么模板来生成index.html<br>另外，我们需要删除之前在output中添加的publicPath属性<br>否则插入的script标签中的src可能会有问题</p>
<h3 id="js压缩插件"><a href="#js压缩插件" class="headerlink" title="js压缩插件"></a>js压缩插件</h3><p>在项目发布之前，我们必然需要对js等文件进行压缩处理<br>这里，我们就对打包的js文件进行压缩<br>我们使用一个第三方的插件<code>uglifyjs-webpack-plugin</code>，并且版本号指定1.1.1，和CLI2保持一致</p>
<p><code>npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</code></p>
<p>修改webpack.config.js文件，使用插件：</p>
<p><img src="https://img.sky123.top/img/image-20200916182106424.png" alt="image-20200916182106424"></p>
<p>查看打包后的bunlde.js文件，是已经被压缩过了。</p>
<h2 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h2><p>webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js搭建，内部使用express框架，<code>可以实现我们想要的让浏览器自动刷新显示我们修改后的结果。</code><br>不过它是一个单独的模块，在webpack中使用之前需要先安装它</p>
<p>devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：<br><code>contentBase：</code>为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist<br><code>port：</code>端口号<br><code>inline：</code>页面实时刷新<br><code>historyApiFallback：</code>在SPA页面中，依赖HTML5的history模式<br>webpack.config.js文件配置修改如下：</p>
<p><img src="https://img.sky123.top/img/image-20200916182215096.png" alt="image-20200916182215096"></p>
<p>我们可以再配置另外一个scripts：–open参数表示直接打开浏览器</p>

            </div>
        </article>
    </div>
    <br>
    
        <div class="next-prev-post">
            
                <div class="prev-post">
                    <div class="prev gt-c-content-color-first">
                        上一篇：<a href="/2020/05/05/vue/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8CVueCLI%E7%9A%84%E4%BD%BF%E7%94%A8/" 
                            class="post-title gt-a-link">vue学习笔记04-前端模块化和vueCli的使用</a>
                    </div>
                </div>
            
            
                <div class="next-post">
                    <div class="next gt-c-content-color-first">
                        下一篇：<a href="/2020/05/05/vue/Vue%E6%8F%92%E6%A7%BD%E5%92%8C%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%8C%96/" 
                            class="post-title gt-a-link">vue学习笔记02-vue的插槽和组件化开发</a>
                    </div>
                </div>
            
        </div>
    
    
</div>
                <div class="site-footer gt-c-content-color-first">
    <div class="footer-main">
        <!-- 建议保留版权信息或者添加主题信息到友链，感谢您的理解 -->
        <!-- 文件位置：layout/_includes/footer.ejs -->
        <span style="text-align: right; float: right;">Theme <a 
            href="https://github.com/renbaoshuo/hexo-theme-pure" target="_blank">Pure</a> | Powered by <a 
            href="https://hexo.io" target="_blank">Hexo</a></span>
        <span style="text-align: left;">Footer HTML
</span>
    </div>
</div>

            </div>
        </div>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>